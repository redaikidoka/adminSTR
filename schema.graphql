# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
  query: Query
  mutation: Mutation
}

"An object with a globally unique `ID`."
interface Node {
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
}

type AdmAccess implements Node {
  "Reads a single `AdmApp` that is related to this `AdmAccess`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `AdmAccess`."
  admUserByIdAdmUser: AdmUser
  idAdmAccess: Int!
  idAdmApp: Int!
  idAdmUser: Int!
  idUserType: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `RefUserType` that is related to this `AdmAccess`."
  refUserTypeByIdUserType: RefUserType
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `AdmAccess` values."
type AdmAccessesConnection {
  "A list of edges which contains the `AdmAccess` and cursor to aid in pagination."
  edges: [AdmAccessesEdge!]!
  "A list of `AdmAccess` objects."
  nodes: [AdmAccess]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmAccess` you could get from the connection."
  totalCount: Int!
}

"A `AdmAccess` edge in the connection."
type AdmAccessesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmAccess` at the end of the edge."
  node: AdmAccess
}

type AdmApp implements Node {
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesConnection!
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!]
  ): [AdmAccess!]!
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesConnection!
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!]
  ): [AdmDefaultTemplate!]!
  "Reads and enables pagination through a set of `AdmDistrikt`."
  admDistriktsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDistriktCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDistriktsConnection!
  "Reads and enables pagination through a set of `AdmDistrikt`."
  admDistriktsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDistriktCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!]
  ): [AdmDistrikt!]!
  "Reads and enables pagination through a set of `AdmDocCategory`."
  admDocCategoriesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesConnection!
  "Reads and enables pagination through a set of `AdmDocCategory`."
  admDocCategoriesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!]
  ): [AdmDocCategory!]!
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsConnection!
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!]
  ): [AdmDocSuggest!]!
  "Reads and enables pagination through a set of `AdmFramework`."
  admFrameworksByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksConnection!
  "Reads and enables pagination through a set of `AdmFramework`."
  admFrameworksByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!]
  ): [AdmFramework!]!
  "Reads and enables pagination through a set of `AdmNarrative`."
  admNarrativesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesConnection!
  "Reads and enables pagination through a set of `AdmNarrative`."
  admNarrativesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!]
  ): [AdmNarrative!]!
  "Reads and enables pagination through a set of `AdmPeriod`."
  admPeriodsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsConnection!
  "Reads and enables pagination through a set of `AdmPeriod`."
  admPeriodsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!]
  ): [AdmPeriod!]!
  "Reads and enables pagination through a set of `AdmSkool`."
  admSkoolsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsConnection!
  "Reads and enables pagination through a set of `AdmSkool`."
  admSkoolsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!]
  ): [AdmSkool!]!
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsConnection!
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!]
  ): [AdmStrTypeMap!]!
  "Reads and enables pagination through a set of `AdmStrType`."
  admStrTypesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesConnection!
  "Reads and enables pagination through a set of `AdmStrType`."
  admStrTypesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!]
  ): [AdmStrType!]!
  "Reads and enables pagination through a set of `AdmTemplate`."
  admTemplatesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmTemplatesConnection!
  "Reads and enables pagination through a set of `AdmTemplate`."
  admTemplatesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!]
  ): [AdmTemplate!]!
  appPreferences: JSON
  description: String
  helpCalibrate: String
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads and enables pagination through a set of `RefRelation`."
  refRelationsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefRelationCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRelationsConnection!
  "Reads and enables pagination through a set of `RefRelation`."
  refRelationsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefRelationCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!]
  ): [RefRelation!]!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsConnection!
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!]
  ): [UsrDoc!]!
  "Reads and enables pagination through a set of `UsrNotify`."
  usrNotifiesByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesConnection!
  "Reads and enables pagination through a set of `UsrNotify`."
  usrNotifiesByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!]
  ): [UsrNotify!]!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsConnection!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!]
  ): [UsrRelationship!]!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
  "Reads and enables pagination through a set of `VwSeason`."
  vwSeasonsByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSeasonCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwSeason`."
    orderBy: [VwSeasonsOrderBy!] = [NATURAL]
  ): VwSeasonsConnection!
  "Reads and enables pagination through a set of `VwSeason`."
  vwSeasonsByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSeasonCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwSeason`."
    orderBy: [VwSeasonsOrderBy!]
  ): [VwSeason!]!
  "Reads and enables pagination through a set of `VwUser`."
  vwUsersByIdAdmApp(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwUser`."
    orderBy: [VwUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwUsersConnection!
  "Reads and enables pagination through a set of `VwUser`."
  vwUsersByIdAdmAppList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwUser`."
    orderBy: [VwUsersOrderBy!]
  ): [VwUser!]!
}

"A connection to a list of `AdmApp` values."
type AdmAppsConnection {
  "A list of edges which contains the `AdmApp` and cursor to aid in pagination."
  edges: [AdmAppsEdge!]!
  "A list of `AdmApp` objects."
  nodes: [AdmApp]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmApp` you could get from the connection."
  totalCount: Int!
}

"A `AdmApp` edge in the connection."
type AdmAppsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmApp` at the end of the edge."
  node: AdmApp
}

"A connection to a list of `AdmCapacity` values."
type AdmCapacitiesConnection {
  "A list of edges which contains the `AdmCapacity` and cursor to aid in pagination."
  edges: [AdmCapacitiesEdge!]!
  "A list of `AdmCapacity` objects."
  nodes: [AdmCapacity]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmCapacity` you could get from the connection."
  totalCount: Int!
}

"A `AdmCapacity` edge in the connection."
type AdmCapacitiesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmCapacity` at the end of the edge."
  node: AdmCapacity
}

type AdmCapacity implements Node {
  "Reads a single `AdmDomain` that is related to this `AdmCapacity`."
  admDomainByIdAdmDomain: AdmDomain
  "Reads and enables pagination through a set of `AdmPractice`."
  admPracticesByIdAdmCapacity(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesConnection!
  "Reads and enables pagination through a set of `AdmPractice`."
  admPracticesByIdAdmCapacityList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!]
  ): [AdmPractice!]!
  capacityDescription: String!
  capacityExemplar: String
  capacityName: String!
  capacityTag: String!
  idAdmCapacity: Int!
  idAdmDomain: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdAdmCapacity(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesConnection!
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdAdmCapacityList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!]
  ): [UsrCapacity!]!
}

type AdmDefaultTemplate implements Node {
  "Reads a single `AdmApp` that is related to this `AdmDefaultTemplate`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmNarrative` that is related to this `AdmDefaultTemplate`."
  admNarrativeByIdAdmNarrative: AdmNarrative
  "Reads a single `AdmStrType` that is related to this `AdmDefaultTemplate`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmTemplate` that is related to this `AdmDefaultTemplate`."
  admTemplateByIdTemplate: AdmTemplate
  idAdmApp: Int
  idAdmDefaultNt: Int!
  idAdmNarrative: Int!
  idAdmStrType: Int!
  idTemplate: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `AdmDefaultTemplate` values."
type AdmDefaultTemplatesConnection {
  "A list of edges which contains the `AdmDefaultTemplate` and cursor to aid in pagination."
  edges: [AdmDefaultTemplatesEdge!]!
  "A list of `AdmDefaultTemplate` objects."
  nodes: [AdmDefaultTemplate]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmDefaultTemplate` you could get from the connection."
  totalCount: Int!
}

"A `AdmDefaultTemplate` edge in the connection."
type AdmDefaultTemplatesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmDefaultTemplate` at the end of the edge."
  node: AdmDefaultTemplate
}

type AdmDistrikt implements Node {
  "Reads a single `AdmApp` that is related to this `AdmDistrikt`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmSkool`."
  admSkoolsByIdDistrictNces(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsConnection!
  "Reads and enables pagination through a set of `AdmSkool`."
  admSkoolsByIdDistrictNcesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!]
  ): [AdmSkool!]!
  districtAbbr: String
  districtName: String
  districtNameLocal: String
  emailManager: String
  emailStaff: String
  idAdmApp: Int
  idDistrictNces: Int!
  isActive: Boolean!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  regionName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
}

"A connection to a list of `AdmDistrikt` values."
type AdmDistriktsConnection {
  "A list of edges which contains the `AdmDistrikt` and cursor to aid in pagination."
  edges: [AdmDistriktsEdge!]!
  "A list of `AdmDistrikt` objects."
  nodes: [AdmDistrikt]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmDistrikt` you could get from the connection."
  totalCount: Int!
}

"A `AdmDistrikt` edge in the connection."
type AdmDistriktsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmDistrikt` at the end of the edge."
  node: AdmDistrikt
}

"A connection to a list of `AdmDocCategory` values."
type AdmDocCategoriesConnection {
  "A list of edges which contains the `AdmDocCategory` and cursor to aid in pagination."
  edges: [AdmDocCategoriesEdge!]!
  "A list of `AdmDocCategory` objects."
  nodes: [AdmDocCategory]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmDocCategory` you could get from the connection."
  totalCount: Int!
}

"A `AdmDocCategory` edge in the connection."
type AdmDocCategoriesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmDocCategory` at the end of the edge."
  node: AdmDocCategory
}

type AdmDocCategory implements Node {
  "Reads a single `AdmApp` that is related to this `AdmDocCategory`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmDocCategory(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsConnection!
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmDocCategoryList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!]
  ): [AdmDocSuggest!]!
  "Reads a single `AdmStrType` that is related to this `AdmDocCategory`."
  admStrTypeByIdAdmStrType: AdmStrType
  docCategoryName: String
  idAdmApp: Int!
  idAdmDocCategory: Int!
  idAdmStrType: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

type AdmDocSuggest implements Node {
  "Reads a single `AdmApp` that is related to this `AdmDocSuggest`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDocCategory` that is related to this `AdmDocSuggest`."
  admDocCategoryByIdAdmDocCategory: AdmDocCategory
  "Reads a single `AdmStrType` that is related to this `AdmDocSuggest`."
  admStrTypeByIdAdmStrType: AdmStrType
  docNotes: Int
  docTitle: String!
  idAdmApp: Int!
  idAdmDocCategory: Int!
  idAdmDocSuggest: Int!
  idAdmStrType: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

"A connection to a list of `AdmDocSuggest` values."
type AdmDocSuggestsConnection {
  "A list of edges which contains the `AdmDocSuggest` and cursor to aid in pagination."
  edges: [AdmDocSuggestsEdge!]!
  "A list of `AdmDocSuggest` objects."
  nodes: [AdmDocSuggest]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmDocSuggest` you could get from the connection."
  totalCount: Int!
}

"A `AdmDocSuggest` edge in the connection."
type AdmDocSuggestsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmDocSuggest` at the end of the edge."
  node: AdmDocSuggest
}

type AdmDomain implements Node {
  "Reads and enables pagination through a set of `AdmCapacity`."
  admCapacitiesByIdAdmDomain(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmCapacitiesConnection!
  "Reads and enables pagination through a set of `AdmCapacity`."
  admCapacitiesByIdAdmDomainList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!]
  ): [AdmCapacity!]!
  "Reads a single `AdmFramework` that is related to this `AdmDomain`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads and enables pagination through a set of `AdmNarrative`."
  admNarrativesByIdAdmDomain(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesConnection!
  "Reads and enables pagination through a set of `AdmNarrative`."
  admNarrativesByIdAdmDomainList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!]
  ): [AdmNarrative!]!
  domainDescription: String!
  domainGapClosure: BigFloat
  domainName: String!
  domainOrder: Int
  domainShort: String
  domainTag: String
  exemplar: String
  idAdmDomain: Int!
  idAdmFramework: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads and enables pagination through a set of `UsrDomain`."
  usrDomainsByIdAdmDomain(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsConnection!
  "Reads and enables pagination through a set of `UsrDomain`."
  usrDomainsByIdAdmDomainList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!]
  ): [UsrDomain!]!
}

"A connection to a list of `AdmDomain` values."
type AdmDomainsConnection {
  "A list of edges which contains the `AdmDomain` and cursor to aid in pagination."
  edges: [AdmDomainsEdge!]!
  "A list of `AdmDomain` objects."
  nodes: [AdmDomain]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmDomain` you could get from the connection."
  totalCount: Int!
}

"A `AdmDomain` edge in the connection."
type AdmDomainsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmDomain` at the end of the edge."
  node: AdmDomain
}

type AdmEngagement implements Node {
  "Reads a single `AdmSkool` that is related to this `AdmEngagement`."
  admSkoolByIdSchoolNces: AdmSkool
  engagementKind: String
  engagementType: String
  idAdmEngagement: Int!
  idEngagementKind: Int
  idEngagementType: Int
  idSchoolNces: BigInt!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int!
}

"A connection to a list of `AdmEngagement` values."
type AdmEngagementsConnection {
  "A list of edges which contains the `AdmEngagement` and cursor to aid in pagination."
  edges: [AdmEngagementsEdge!]!
  "A list of `AdmEngagement` objects."
  nodes: [AdmEngagement]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmEngagement` you could get from the connection."
  totalCount: Int!
}

"A `AdmEngagement` edge in the connection."
type AdmEngagementsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmEngagement` at the end of the edge."
  node: AdmEngagement
}

type AdmFramework implements Node {
  "Reads a single `AdmApp` that is related to this `AdmFramework`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmDomain`."
  admDomainsByIdAdmFramework(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDomainsConnection!
  "Reads and enables pagination through a set of `AdmDomain`."
  admDomainsByIdAdmFrameworkList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!]
  ): [AdmDomain!]!
  "Reads and enables pagination through a set of `AdmPractice`."
  admPracticesByIdAdmFramework(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesConnection!
  "Reads and enables pagination through a set of `AdmPractice`."
  admPracticesByIdAdmFrameworkList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!]
  ): [AdmPractice!]!
  "Reads and enables pagination through a set of `AdmRubric`."
  admRubricsByIdAdmFramework(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricsConnection!
  "Reads and enables pagination through a set of `AdmRubric`."
  admRubricsByIdAdmFrameworkList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!]
  ): [AdmRubric!]!
  "Reads a single `AdmScale` that is related to this `AdmFramework`."
  admScaleByIdAdmScale: AdmScale
  "Reads and enables pagination through a set of `AdmStrType`."
  admStrTypesByIdAdmFramework(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesConnection!
  "Reads and enables pagination through a set of `AdmStrType`."
  admStrTypesByIdAdmFrameworkList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!]
  ): [AdmStrType!]!
  effectiveDate: Datetime
  endDate: Datetime
  frameworkName: String
  frameworkVersion: Int
  idAdmApp: Int
  idAdmFramework: Int!
  idAdmScale: Int
  isActive: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmFramework(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmFrameworkList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"A connection to a list of `AdmFramework` values."
type AdmFrameworksConnection {
  "A list of edges which contains the `AdmFramework` and cursor to aid in pagination."
  edges: [AdmFrameworksEdge!]!
  "A list of `AdmFramework` objects."
  nodes: [AdmFramework]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmFramework` you could get from the connection."
  totalCount: Int!
}

"A `AdmFramework` edge in the connection."
type AdmFrameworksEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmFramework` at the end of the edge."
  node: AdmFramework
}

type AdmNarrative implements Node {
  "Reads a single `AdmApp` that is related to this `AdmNarrative`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmNarrative(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesConnection!
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmNarrativeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!]
  ): [AdmDefaultTemplate!]!
  "Reads a single `AdmDomain` that is related to this `AdmNarrative`."
  admDomainByIdAdmDomain: AdmDomain
  idAdmApp: Int!
  idAdmDomain: Int
  idAdmNarrative: Int!
  narrativeName: String
  narrativeTags: String
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  trialTags: [String]
}

"A connection to a list of `AdmNarrative` values."
type AdmNarrativesConnection {
  "A list of edges which contains the `AdmNarrative` and cursor to aid in pagination."
  edges: [AdmNarrativesEdge!]!
  "A list of `AdmNarrative` objects."
  nodes: [AdmNarrative]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmNarrative` you could get from the connection."
  totalCount: Int!
}

"A `AdmNarrative` edge in the connection."
type AdmNarrativesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmNarrative` at the end of the edge."
  node: AdmNarrative
}

type AdmPeriod implements Node {
  "Reads a single `AdmApp` that is related to this `AdmPeriod`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmStrType` that is related to this `AdmPeriod`."
  admStrTypeByIdAdmStrType: AdmStrType
  idAdmApp: Int
  idAdmPeriod: Int!
  idAdmStrType: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  periodEndMonth: Int!
  periodName: String!
  periodStartMonth: Int!
  periodTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  startsNewSequence: Boolean!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmPeriod(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmPeriodList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"A connection to a list of `AdmPeriod` values."
type AdmPeriodsConnection {
  "A list of edges which contains the `AdmPeriod` and cursor to aid in pagination."
  edges: [AdmPeriodsEdge!]!
  "A list of `AdmPeriod` objects."
  nodes: [AdmPeriod]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmPeriod` you could get from the connection."
  totalCount: Int!
}

"A `AdmPeriod` edge in the connection."
type AdmPeriodsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmPeriod` at the end of the edge."
  node: AdmPeriod
}

type AdmPractice implements Node {
  "Reads a single `AdmCapacity` that is related to this `AdmPractice`."
  admCapacityByIdAdmCapacity: AdmCapacity
  "Reads a single `AdmFramework` that is related to this `AdmPractice`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads and enables pagination through a set of `AdmRubricMap`."
  admRubricMapsByIdAdmPractice(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsConnection!
  "Reads and enables pagination through a set of `AdmRubricMap`."
  admRubricMapsByIdAdmPracticeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!]
  ): [AdmRubricMap!]!
  analysisName: String
  idAdmCapacity: Int!
  idAdmFramework: Int
  idAdmPractice: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  practiceDescription: String!
  practiceExemplar: String
  practiceGrouping: String
  practiceName: String!
  practiceTag: String!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
  uidPractice: String
  "Reads and enables pagination through a set of `UsrFocus`."
  usrFociByIdAdmPractice(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociConnection!
  "Reads and enables pagination through a set of `UsrFocus`."
  usrFociByIdAdmPracticeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!]
  ): [UsrFocus!]!
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdAdmPractice(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesConnection!
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdAdmPracticeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!]
  ): [UsrPractice!]!
}

"A connection to a list of `AdmPractice` values."
type AdmPracticesConnection {
  "A list of edges which contains the `AdmPractice` and cursor to aid in pagination."
  edges: [AdmPracticesEdge!]!
  "A list of `AdmPractice` objects."
  nodes: [AdmPractice]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmPractice` you could get from the connection."
  totalCount: Int!
}

"A `AdmPractice` edge in the connection."
type AdmPracticesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmPractice` at the end of the edge."
  node: AdmPractice
}

"list of rubrics - subsets of frameworks"
type AdmRubric implements Node {
  "Reads a single `AdmFramework` that is related to this `AdmRubric`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads and enables pagination through a set of `AdmRubricMap`."
  admRubricMapsByIdAdmRubric(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsConnection!
  "Reads and enables pagination through a set of `AdmRubricMap`."
  admRubricMapsByIdAdmRubricList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!]
  ): [AdmRubricMap!]!
  idAdmFramework: Int!
  idAdmRubric: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  rubricDescription: String!
  rubricName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmRubric(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmRubricList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"Maps practices from a framework to the rubric"
type AdmRubricMap implements Node {
  "Reads a single `AdmPractice` that is related to this `AdmRubricMap`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmRubric` that is related to this `AdmRubricMap`."
  admRubricByIdAdmRubric: AdmRubric
  idAdmPractice: Int!
  idAdmRubric: Int!
  idAdmRubricMap: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `AdmRubricMap` values."
type AdmRubricMapsConnection {
  "A list of edges which contains the `AdmRubricMap` and cursor to aid in pagination."
  edges: [AdmRubricMapsEdge!]!
  "A list of `AdmRubricMap` objects."
  nodes: [AdmRubricMap]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmRubricMap` you could get from the connection."
  totalCount: Int!
}

"A `AdmRubricMap` edge in the connection."
type AdmRubricMapsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmRubricMap` at the end of the edge."
  node: AdmRubricMap
}

"A connection to a list of `AdmRubric` values."
type AdmRubricsConnection {
  "A list of edges which contains the `AdmRubric` and cursor to aid in pagination."
  edges: [AdmRubricsEdge!]!
  "A list of `AdmRubric` objects."
  nodes: [AdmRubric]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmRubric` you could get from the connection."
  totalCount: Int!
}

"A `AdmRubric` edge in the connection."
type AdmRubricsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmRubric` at the end of the edge."
  node: AdmRubric
}

type AdmScale implements Node {
  "Reads and enables pagination through a set of `AdmFramework`."
  admFrameworksByIdAdmScale(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksConnection!
  "Reads and enables pagination through a set of `AdmFramework`."
  admFrameworksByIdAdmScaleList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!]
  ): [AdmFramework!]!
  "Reads and enables pagination through a set of `AdmScore`."
  admScoresByIdAdmScale(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScoresConnection!
  "Reads and enables pagination through a set of `AdmScore`."
  admScoresByIdAdmScaleList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!]
  ): [AdmScore!]!
  displayOrder: Int
  idAdmScale: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scaleDescription: String
  scaleGraphicUrl: String
  scaleName: String
}

"A connection to a list of `AdmScale` values."
type AdmScalesConnection {
  "A list of edges which contains the `AdmScale` and cursor to aid in pagination."
  edges: [AdmScalesEdge!]!
  "A list of `AdmScale` objects."
  nodes: [AdmScale]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmScale` you could get from the connection."
  totalCount: Int!
}

"A `AdmScale` edge in the connection."
type AdmScalesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmScale` at the end of the edge."
  node: AdmScale
}

type AdmScore implements Node {
  "Reads a single `AdmScale` that is related to this `AdmScore`."
  admScaleByIdAdmScale: AdmScale
  consistency: String
  displayOrder: Int
  frequency: String
  idAdmScale: Int
  idAdmScore: Int!
  intentionality: String
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  ownership: String
  quality: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scoreDescription: String
  scoreName: String
  scoreValue: Int
}

"A connection to a list of `AdmScore` values."
type AdmScoresConnection {
  "A list of edges which contains the `AdmScore` and cursor to aid in pagination."
  edges: [AdmScoresEdge!]!
  "A list of `AdmScore` objects."
  nodes: [AdmScore]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmScore` you could get from the connection."
  totalCount: Int!
}

"A `AdmScore` edge in the connection."
type AdmScoresEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmScore` at the end of the edge."
  node: AdmScore
}

type AdmSkool implements Node {
  "Reads a single `AdmApp` that is related to this `AdmSkool`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDistrikt` that is related to this `AdmSkool`."
  admDistriktByIdDistrictNces: AdmDistrikt
  "Reads and enables pagination through a set of `AdmEngagement`."
  admEngagementsByIdSchoolNces(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmEngagementCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmEngagementsConnection!
  "Reads and enables pagination through a set of `AdmEngagement`."
  admEngagementsByIdSchoolNcesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmEngagementCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!]
  ): [AdmEngagement!]!
  emailManager: String
  emailStaff: String
  id: Int!
  idAdmApp: Int
  idAdmUser: Int
  idDistrictNces: Int
  idSchoolNces: BigInt!
  isActive: Boolean!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  schoolNameLocal: String
  tags: String
  uidSchool: String
  "Reads and enables pagination through a set of `UsrFocus`."
  usrFociByIdSchoolNces(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociConnection!
  "Reads and enables pagination through a set of `UsrFocus`."
  usrFociByIdSchoolNcesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!]
  ): [UsrFocus!]!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdSchoolNces(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdSchoolNcesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"A connection to a list of `AdmSkool` values."
type AdmSkoolsConnection {
  "A list of edges which contains the `AdmSkool` and cursor to aid in pagination."
  edges: [AdmSkoolsEdge!]!
  "A list of `AdmSkool` objects."
  nodes: [AdmSkool]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmSkool` you could get from the connection."
  totalCount: Int!
}

"A `AdmSkool` edge in the connection."
type AdmSkoolsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmSkool` at the end of the edge."
  node: AdmSkool
}

type AdmStrSequence implements Node {
  idAdmStrSequence: Int!
  idUserStrPrev: Int
  "first str in the sequence!"
  idUsrStr: Int
  idUsrStrNext: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  reason: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `AdmStrSequence` values."
type AdmStrSequencesConnection {
  "A list of edges which contains the `AdmStrSequence` and cursor to aid in pagination."
  edges: [AdmStrSequencesEdge!]!
  "A list of `AdmStrSequence` objects."
  nodes: [AdmStrSequence]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmStrSequence` you could get from the connection."
  totalCount: Int!
}

"A `AdmStrSequence` edge in the connection."
type AdmStrSequencesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmStrSequence` at the end of the edge."
  node: AdmStrSequence
}

type AdmStrType implements Node {
  "Reads a single `AdmApp` that is related to this `AdmStrType`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesConnection!
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!]
  ): [AdmDefaultTemplate!]!
  "Reads and enables pagination through a set of `AdmDocCategory`."
  admDocCategoriesByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesConnection!
  "Reads and enables pagination through a set of `AdmDocCategory`."
  admDocCategoriesByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!]
  ): [AdmDocCategory!]!
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsConnection!
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  admDocSuggestsByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!]
  ): [AdmDocSuggest!]!
  "Reads a single `AdmFramework` that is related to this `AdmStrType`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads and enables pagination through a set of `AdmPeriod`."
  admPeriodsByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsConnection!
  "Reads and enables pagination through a set of `AdmPeriod`."
  admPeriodsByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!]
  ): [AdmPeriod!]!
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsConnection!
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!]
  ): [AdmStrTypeMap!]!
  contributeToStrType: Int
  editAction: String
  hasGoals: Boolean
  hasPeriod: Boolean!
  hasSchool: Boolean!
  hasSummary: Boolean!
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmStrType: Int!
  idObject: Int
  initialIdRelation: Int
  isCalibrated: Boolean
  isExported: Boolean
  isOfficialRecord: Boolean
  nextStrType: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  prevStrType: Int
  printAction: String
  requireBaseline: Boolean!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  summaryAction: String
  typeDescription: String
  typeIcon: String
  typeName: String
  typeTag: String
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
  viewAction: String
  "Reads and enables pagination through a set of `VwDefaultTemplate`."
  vwDefaultTemplatesByIdAdmStrType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDefaultTemplate`."
    orderBy: [VwDefaultTemplatesOrderBy!] = [NATURAL]
  ): VwDefaultTemplatesConnection!
  "Reads and enables pagination through a set of `VwDefaultTemplate`."
  vwDefaultTemplatesByIdAdmStrTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDefaultTemplate`."
    orderBy: [VwDefaultTemplatesOrderBy!]
  ): [VwDefaultTemplate!]!
}

"Maps the relationships endemic to each str type"
type AdmStrTypeMap implements Node {
  "Reads a single `AdmApp` that is related to this `AdmStrTypeMap`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmStrType` that is related to this `AdmStrTypeMap`."
  admStrTypeByIdAdmStrType: AdmStrType
  displayOrder: Int
  idAdmApp: Int
  idAdmStrType: Int
  idAdmStrTypeMap: Int!
  idRelation: Int
  nextIdRelation: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `RefRelation` that is related to this `AdmStrTypeMap`."
  refRelationByIdRelation: RefRelation
  relationStrTypeId: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `AdmStrTypeMap` values."
type AdmStrTypeMapsConnection {
  "A list of edges which contains the `AdmStrTypeMap` and cursor to aid in pagination."
  edges: [AdmStrTypeMapsEdge!]!
  "A list of `AdmStrTypeMap` objects."
  nodes: [AdmStrTypeMap]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmStrTypeMap` you could get from the connection."
  totalCount: Int!
}

"A `AdmStrTypeMap` edge in the connection."
type AdmStrTypeMapsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmStrTypeMap` at the end of the edge."
  node: AdmStrTypeMap
}

"A connection to a list of `AdmStrType` values."
type AdmStrTypesConnection {
  "A list of edges which contains the `AdmStrType` and cursor to aid in pagination."
  edges: [AdmStrTypesEdge!]!
  "A list of `AdmStrType` objects."
  nodes: [AdmStrType]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmStrType` you could get from the connection."
  totalCount: Int!
}

"A `AdmStrType` edge in the connection."
type AdmStrTypesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmStrType` at the end of the edge."
  node: AdmStrType
}

type AdmTemplate implements Node {
  "Reads a single `AdmApp` that is related to this `AdmTemplate`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdTemplate(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesConnection!
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  admDefaultTemplatesByIdTemplateList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!]
  ): [AdmDefaultTemplate!]!
  idAdmApp: Int!
  idTemplate: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  tags: String
  templateDescription: String
  templateLink: String
  templateName: String!
  templateText: String!
}

"A connection to a list of `AdmTemplate` values."
type AdmTemplatesConnection {
  "A list of edges which contains the `AdmTemplate` and cursor to aid in pagination."
  edges: [AdmTemplatesEdge!]!
  "A list of `AdmTemplate` objects."
  nodes: [AdmTemplate]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmTemplate` you could get from the connection."
  totalCount: Int!
}

"A `AdmTemplate` edge in the connection."
type AdmTemplatesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmTemplate` at the end of the edge."
  node: AdmTemplate
}

type AdmUser implements Node {
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesConnection!
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!]
  ): [AdmAccess!]!
  "Reads a single `AdmUser` that is related to this `AdmUser`."
  admUserByIdManager: AdmUser
  "Reads and enables pagination through a set of `AdmUser`."
  admUsersByIdManager(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmUsersConnection!
  "Reads and enables pagination through a set of `AdmUser`."
  admUsersByIdManagerList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!]
  ): [AdmUser!]!
  idAdmUser: Int!
  idManager: Int
  imageLink: String
  imageUrl: String
  isActive: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  spare: Int
  tags: String
  userEmail: String
  userName: String
  userPreferences: JSON
  userScore: Int
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsConnection!
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!]
  ): [UsrDoc!]!
  "Reads and enables pagination through a set of `UsrNotify`."
  usrNotifiesByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesConnection!
  "Reads and enables pagination through a set of `UsrNotify`."
  usrNotifiesByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!]
  ): [UsrNotify!]!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsConnection!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!]
  ): [UsrRelationship!]!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"A connection to a list of `AdmUser` values."
type AdmUsersConnection {
  "A list of edges which contains the `AdmUser` and cursor to aid in pagination."
  edges: [AdmUsersEdge!]!
  "A list of `AdmUser` objects."
  nodes: [AdmUser]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `AdmUser` you could get from the connection."
  totalCount: Int!
}

"A `AdmUser` edge in the connection."
type AdmUsersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `AdmUser` at the end of the edge."
  node: AdmUser
}

"The output of our create `AdmAccess` mutation."
type CreateAdmAccessPayload {
  "The `AdmAccess` that was created by this mutation."
  admAccess: AdmAccess
  "An edge for our `AdmAccess`. May be used by Relay 1."
  admAccessEdge(
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesEdge
  "Reads a single `AdmApp` that is related to this `AdmAccess`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `AdmAccess`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefUserType` that is related to this `AdmAccess`."
  refUserTypeByIdUserType: RefUserType
}

"The output of our create `AdmApp` mutation."
type CreateAdmAppPayload {
  "The `AdmApp` that was created by this mutation."
  admApp: AdmApp
  "An edge for our `AdmApp`. May be used by Relay 1."
  admAppEdge(
    "The method to use when ordering `AdmApp`."
    orderBy: [AdmAppsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAppsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmCapacity` mutation."
type CreateAdmCapacityPayload {
  "The `AdmCapacity` that was created by this mutation."
  admCapacity: AdmCapacity
  "An edge for our `AdmCapacity`. May be used by Relay 1."
  admCapacityEdge(
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmCapacitiesEdge
  "Reads a single `AdmDomain` that is related to this `AdmCapacity`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmDefaultTemplate` mutation."
type CreateAdmDefaultTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmDefaultTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDefaultTemplate` that was created by this mutation."
  admDefaultTemplate: AdmDefaultTemplate
  "An edge for our `AdmDefaultTemplate`. May be used by Relay 1."
  admDefaultTemplateEdge(
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesEdge
  "Reads a single `AdmNarrative` that is related to this `AdmDefaultTemplate`."
  admNarrativeByIdAdmNarrative: AdmNarrative
  "Reads a single `AdmStrType` that is related to this `AdmDefaultTemplate`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmTemplate` that is related to this `AdmDefaultTemplate`."
  admTemplateByIdTemplate: AdmTemplate
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmDistrikt` mutation."
type CreateAdmDistriktPayload {
  "Reads a single `AdmApp` that is related to this `AdmDistrikt`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDistrikt` that was created by this mutation."
  admDistrikt: AdmDistrikt
  "An edge for our `AdmDistrikt`. May be used by Relay 1."
  admDistriktEdge(
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDistriktsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmDocCategory` mutation."
type CreateAdmDocCategoryPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocCategory`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDocCategory` that was created by this mutation."
  admDocCategory: AdmDocCategory
  "An edge for our `AdmDocCategory`. May be used by Relay 1."
  admDocCategoryEdge(
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocCategory`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmDocSuggest` mutation."
type CreateAdmDocSuggestPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocSuggest`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDocCategory` that is related to this `AdmDocSuggest`."
  admDocCategoryByIdAdmDocCategory: AdmDocCategory
  "The `AdmDocSuggest` that was created by this mutation."
  admDocSuggest: AdmDocSuggest
  "An edge for our `AdmDocSuggest`. May be used by Relay 1."
  admDocSuggestEdge(
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocSuggest`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmDomain` mutation."
type CreateAdmDomainPayload {
  "The `AdmDomain` that was created by this mutation."
  admDomain: AdmDomain
  "An edge for our `AdmDomain`. May be used by Relay 1."
  admDomainEdge(
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDomainsEdge
  "Reads a single `AdmFramework` that is related to this `AdmDomain`."
  admFrameworkByIdAdmFramework: AdmFramework
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmEngagement` mutation."
type CreateAdmEngagementPayload {
  "The `AdmEngagement` that was created by this mutation."
  admEngagement: AdmEngagement
  "An edge for our `AdmEngagement`. May be used by Relay 1."
  admEngagementEdge(
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmEngagementsEdge
  "Reads a single `AdmSkool` that is related to this `AdmEngagement`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmFramework` mutation."
type CreateAdmFrameworkPayload {
  "Reads a single `AdmApp` that is related to this `AdmFramework`."
  admAppByIdAdmApp: AdmApp
  "The `AdmFramework` that was created by this mutation."
  admFramework: AdmFramework
  "An edge for our `AdmFramework`. May be used by Relay 1."
  admFrameworkEdge(
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksEdge
  "Reads a single `AdmScale` that is related to this `AdmFramework`."
  admScaleByIdAdmScale: AdmScale
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmNarrative` mutation."
type CreateAdmNarrativePayload {
  "Reads a single `AdmApp` that is related to this `AdmNarrative`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDomain` that is related to this `AdmNarrative`."
  admDomainByIdAdmDomain: AdmDomain
  "The `AdmNarrative` that was created by this mutation."
  admNarrative: AdmNarrative
  "An edge for our `AdmNarrative`. May be used by Relay 1."
  admNarrativeEdge(
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmPeriod` mutation."
type CreateAdmPeriodPayload {
  "Reads a single `AdmApp` that is related to this `AdmPeriod`."
  admAppByIdAdmApp: AdmApp
  "The `AdmPeriod` that was created by this mutation."
  admPeriod: AdmPeriod
  "An edge for our `AdmPeriod`. May be used by Relay 1."
  admPeriodEdge(
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsEdge
  "Reads a single `AdmStrType` that is related to this `AdmPeriod`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmPractice` mutation."
type CreateAdmPracticePayload {
  "Reads a single `AdmCapacity` that is related to this `AdmPractice`."
  admCapacityByIdAdmCapacity: AdmCapacity
  "Reads a single `AdmFramework` that is related to this `AdmPractice`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmPractice` that was created by this mutation."
  admPractice: AdmPractice
  "An edge for our `AdmPractice`. May be used by Relay 1."
  admPracticeEdge(
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmRubricMap` mutation."
type CreateAdmRubricMapPayload {
  "Reads a single `AdmPractice` that is related to this `AdmRubricMap`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmRubric` that is related to this `AdmRubricMap`."
  admRubricByIdAdmRubric: AdmRubric
  "The `AdmRubricMap` that was created by this mutation."
  admRubricMap: AdmRubricMap
  "An edge for our `AdmRubricMap`. May be used by Relay 1."
  admRubricMapEdge(
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmRubric` mutation."
type CreateAdmRubricPayload {
  "Reads a single `AdmFramework` that is related to this `AdmRubric`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmRubric` that was created by this mutation."
  admRubric: AdmRubric
  "An edge for our `AdmRubric`. May be used by Relay 1."
  admRubricEdge(
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmScale` mutation."
type CreateAdmScalePayload {
  "The `AdmScale` that was created by this mutation."
  admScale: AdmScale
  "An edge for our `AdmScale`. May be used by Relay 1."
  admScaleEdge(
    "The method to use when ordering `AdmScale`."
    orderBy: [AdmScalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScalesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmScore` mutation."
type CreateAdmScorePayload {
  "Reads a single `AdmScale` that is related to this `AdmScore`."
  admScaleByIdAdmScale: AdmScale
  "The `AdmScore` that was created by this mutation."
  admScore: AdmScore
  "An edge for our `AdmScore`. May be used by Relay 1."
  admScoreEdge(
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScoresEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmSkool` mutation."
type CreateAdmSkoolPayload {
  "Reads a single `AdmApp` that is related to this `AdmSkool`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDistrikt` that is related to this `AdmSkool`."
  admDistriktByIdDistrictNces: AdmDistrikt
  "The `AdmSkool` that was created by this mutation."
  admSkool: AdmSkool
  "An edge for our `AdmSkool`. May be used by Relay 1."
  admSkoolEdge(
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmStrSequence` mutation."
type CreateAdmStrSequencePayload {
  "The `AdmStrSequence` that was created by this mutation."
  admStrSequence: AdmStrSequence
  "An edge for our `AdmStrSequence`. May be used by Relay 1."
  admStrSequenceEdge(
    "The method to use when ordering `AdmStrSequence`."
    orderBy: [AdmStrSequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrSequencesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmStrTypeMap` mutation."
type CreateAdmStrTypeMapPayload {
  "Reads a single `AdmApp` that is related to this `AdmStrTypeMap`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmStrType` that is related to this `AdmStrTypeMap`."
  admStrTypeByIdAdmStrType: AdmStrType
  "The `AdmStrTypeMap` that was created by this mutation."
  admStrTypeMap: AdmStrTypeMap
  "An edge for our `AdmStrTypeMap`. May be used by Relay 1."
  admStrTypeMapEdge(
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `AdmStrTypeMap`."
  refRelationByIdRelation: RefRelation
}

"The output of our create `AdmStrType` mutation."
type CreateAdmStrTypePayload {
  "Reads a single `AdmApp` that is related to this `AdmStrType`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `AdmStrType`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmStrType` that was created by this mutation."
  admStrType: AdmStrType
  "An edge for our `AdmStrType`. May be used by Relay 1."
  admStrTypeEdge(
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmTemplate` mutation."
type CreateAdmTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmTemplate` that was created by this mutation."
  admTemplate: AdmTemplate
  "An edge for our `AdmTemplate`. May be used by Relay 1."
  admTemplateEdge(
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmTemplatesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `AdmUser` mutation."
type CreateAdmUserPayload {
  "The `AdmUser` that was created by this mutation."
  admUser: AdmUser
  "Reads a single `AdmUser` that is related to this `AdmUser`."
  admUserByIdManager: AdmUser
  "An edge for our `AdmUser`. May be used by Relay 1."
  admUserEdge(
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmUsersEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `FlywaySchemaHistory` mutation."
type CreateFlywaySchemaHistoryPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "The `FlywaySchemaHistory` that was created by this mutation."
  flywaySchemaHistory: FlywaySchemaHistory
  "An edge for our `FlywaySchemaHistory`. May be used by Relay 1."
  flywaySchemaHistoryEdge(
    "The method to use when ordering `FlywaySchemaHistory`."
    orderBy: [FlywaySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlywaySchemaHistoriesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `Post` mutation."
type CreatePostPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "The `Post` that was created by this mutation."
  post: Post
  "An edge for our `Post`. May be used by Relay 1."
  postEdge(
    "The method to use when ordering `Post`."
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our create `RefObject` mutation."
type CreateRefObjectPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefObject` that was created by this mutation."
  refObject: RefObject
  "An edge for our `RefObject`. May be used by Relay 1."
  refObjectEdge(
    "The method to use when ordering `RefObject`."
    orderBy: [RefObjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefObjectsEdge
}

"The output of our create `RefRelation` mutation."
type CreateRefRelationPayload {
  "Reads a single `AdmApp` that is related to this `RefRelation`."
  admAppByIdAdmApp: AdmApp
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefRelation` that was created by this mutation."
  refRelation: RefRelation
  "An edge for our `RefRelation`. May be used by Relay 1."
  refRelationEdge(
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRelationsEdge
}

"The output of our create `RefStatus` mutation."
type CreateRefStatusPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefStatus` that was created by this mutation."
  refStatus: RefStatus
  "An edge for our `RefStatus`. May be used by Relay 1."
  refStatusEdge(
    "The method to use when ordering `RefStatus`."
    orderBy: [RefStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefStatusesEdge
}

"The output of our create `RefUserType` mutation."
type CreateRefUserTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefUserType` that was created by this mutation."
  refUserType: RefUserType
  "An edge for our `RefUserType`. May be used by Relay 1."
  refUserTypeEdge(
    "The method to use when ordering `RefUserType`."
    orderBy: [RefUserTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefUserTypesEdge
}

"The output of our create `SActivity` mutation."
type CreateSActivityPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SActivity` that was created by this mutation."
  sActivity: SActivity
  "An edge for our `SActivity`. May be used by Relay 1."
  sActivityEdge(
    "The method to use when ordering `SActivity`."
    orderBy: [SActivitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SActivitiesEdge
}

"The output of our create `SErr` mutation."
type CreateSErrPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SErr` that was created by this mutation."
  sErr: SErr
  "An edge for our `SErr`. May be used by Relay 1."
  sErrEdge(
    "The method to use when ordering `SErr`."
    orderBy: [SErrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SErrsEdge
}

"The output of our create `SLogCode` mutation."
type CreateSLogCodePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogCode` that was created by this mutation."
  sLogCode: SLogCode
  "An edge for our `SLogCode`. May be used by Relay 1."
  sLogCodeEdge(
    "The method to use when ordering `SLogCode`."
    orderBy: [SLogCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogCodesEdge
}

"The output of our create `SLogDetail` mutation."
type CreateSLogDetailPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogDetail` that was created by this mutation."
  sLogDetail: SLogDetail
  "An edge for our `SLogDetail`. May be used by Relay 1."
  sLogDetailEdge(
    "The method to use when ordering `SLogDetail`."
    orderBy: [SLogDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogDetailsEdge
}

"The output of our create `SLog` mutation."
type CreateSLogPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLog` that was created by this mutation."
  sLog: SLog
  "An edge for our `SLog`. May be used by Relay 1."
  sLogEdge(
    "The method to use when ordering `SLog`."
    orderBy: [SLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogsEdge
}

"The output of our create `STable` mutation."
type CreateSTablePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STable` that was created by this mutation."
  sTable: STable
  "An edge for our `STable`. May be used by Relay 1."
  sTableEdge(
    "The method to use when ordering `STable`."
    orderBy: [STablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STablesEdge
}

"The output of our create `STableType` mutation."
type CreateSTableTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STableType` that was created by this mutation."
  sTableType: STableType
  "An edge for our `STableType`. May be used by Relay 1."
  sTableTypeEdge(
    "The method to use when ordering `STableType`."
    orderBy: [STableTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STableTypesEdge
}

"The output of our create `UsrCapacity` mutation."
type CreateUsrCapacityPayload {
  "Reads a single `AdmCapacity` that is related to this `UsrCapacity`."
  admCapacityByIdAdmCapacity: AdmCapacity
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrCapacity` that was created by this mutation."
  usrCapacity: UsrCapacity
  "An edge for our `UsrCapacity`. May be used by Relay 1."
  usrCapacityEdge(
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesEdge
  "Reads a single `UsrDomain` that is related to this `UsrCapacity`."
  usrDomainByIdUsrDomain: UsrDomain
  "Reads a single `UsrStr` that is related to this `UsrCapacity`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our create `UsrDoc` mutation."
type CreateUsrDocPayload {
  "Reads a single `AdmApp` that is related to this `UsrDoc`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrDoc`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDoc` that was created by this mutation."
  usrDoc: UsrDoc
  "An edge for our `UsrDoc`. May be used by Relay 1."
  usrDocEdge(
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsEdge
  "Reads a single `UsrStr` that is related to this `UsrDoc`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our create `UsrDomain` mutation."
type CreateUsrDomainPayload {
  "Reads a single `AdmDomain` that is related to this `UsrDomain`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDomain` that was created by this mutation."
  usrDomain: UsrDomain
  "An edge for our `UsrDomain`. May be used by Relay 1."
  usrDomainEdge(
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsEdge
  "Reads a single `UsrStr` that is related to this `UsrDomain`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our create `UsrFocus` mutation."
type CreateUsrFocusPayload {
  "Reads a single `AdmPractice` that is related to this `UsrFocus`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmSkool` that is related to this `UsrFocus`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrFocus` that was created by this mutation."
  usrFocus: UsrFocus
  "An edge for our `UsrFocus`. May be used by Relay 1."
  usrFocusEdge(
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociEdge
}

"The output of our create `UsrNotify` mutation."
type CreateUsrNotifyPayload {
  "Reads a single `AdmApp` that is related to this `UsrNotify`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrNotify`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrNotify` that was created by this mutation."
  usrNotify: UsrNotify
  "An edge for our `UsrNotify`. May be used by Relay 1."
  usrNotifyEdge(
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesEdge
}

"The output of our create `UsrPractice` mutation."
type CreateUsrPracticePayload {
  "Reads a single `AdmPractice` that is related to this `UsrPractice`."
  admPracticeByIdAdmPractice: AdmPractice
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrCapacity` that is related to this `UsrPractice`."
  usrCapacityByIdUsrCapacity: UsrCapacity
  "The `UsrPractice` that was created by this mutation."
  usrPractice: UsrPractice
  "An edge for our `UsrPractice`. May be used by Relay 1."
  usrPracticeEdge(
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesEdge
  "Reads a single `UsrStr` that is related to this `UsrPractice`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our create `UsrRelationship` mutation."
type CreateUsrRelationshipPayload {
  "Reads a single `AdmApp` that is related to this `UsrRelationship`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrRelationship`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `UsrRelationship`."
  refRelationByIdRelation: RefRelation
  "The `UsrRelationship` that was created by this mutation."
  usrRelationship: UsrRelationship
  "An edge for our `UsrRelationship`. May be used by Relay 1."
  usrRelationshipEdge(
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsEdge
  "Reads a single `UsrStr` that is related to this `UsrRelationship`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our create `UsrStr` mutation."
type CreateUsrStrPayload {
  "Reads a single `AdmApp` that is related to this `UsrStr`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `UsrStr`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads a single `AdmPeriod` that is related to this `UsrStr`."
  admPeriodByIdAdmPeriod: AdmPeriod
  "Reads a single `AdmRubric` that is related to this `UsrStr`."
  admRubricByIdAdmRubric: AdmRubric
  "Reads a single `AdmSkool` that is related to this `UsrStr`."
  admSkoolByIdSchoolNces: AdmSkool
  "Reads a single `AdmStrType` that is related to this `UsrStr`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmUser` that is related to this `UsrStr`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrRelationship` that is related to this `UsrStr`."
  usrRelationshipByCurrentIdUsrRelationship: UsrRelationship
  "The `UsrStr` that was created by this mutation."
  usrStr: UsrStr
  "An edge for our `UsrStr`. May be used by Relay 1."
  usrStrEdge(
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsEdge
}

"The output of our create `VwDistrict` mutation."
type CreateVwDistrictPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `VwDistrict` that was created by this mutation."
  vwDistrict: VwDistrict
  "An edge for our `VwDistrict`. May be used by Relay 1."
  vwDistrictEdge(
    "The method to use when ordering `VwDistrict`."
    orderBy: [VwDistrictsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDistrictsEdge
}

"The output of our create `VwTestApp` mutation."
type CreateVwTestAppPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `VwTestApp` that was created by this mutation."
  vwTestApp: VwTestApp
  "An edge for our `VwTestApp`. May be used by Relay 1."
  vwTestAppEdge(
    "The method to use when ordering `VwTestApp`."
    orderBy: [VwTestAppsOrderBy!] = [NATURAL]
  ): VwTestAppsEdge
}

"The output of our `currentreviewer` mutation."
type CurrentreviewerPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `currentreviewuser` mutation."
type CurrentreviewuserPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmAccess` mutation."
type DeleteAdmAccessPayload {
  "The `AdmAccess` that was deleted by this mutation."
  admAccess: AdmAccess
  "An edge for our `AdmAccess`. May be used by Relay 1."
  admAccessEdge(
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesEdge
  "Reads a single `AdmApp` that is related to this `AdmAccess`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `AdmAccess`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmAccessId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefUserType` that is related to this `AdmAccess`."
  refUserTypeByIdUserType: RefUserType
}

"The output of our delete `AdmApp` mutation."
type DeleteAdmAppPayload {
  "The `AdmApp` that was deleted by this mutation."
  admApp: AdmApp
  "An edge for our `AdmApp`. May be used by Relay 1."
  admAppEdge(
    "The method to use when ordering `AdmApp`."
    orderBy: [AdmAppsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAppsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmAppId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmCapacity` mutation."
type DeleteAdmCapacityPayload {
  "The `AdmCapacity` that was deleted by this mutation."
  admCapacity: AdmCapacity
  "An edge for our `AdmCapacity`. May be used by Relay 1."
  admCapacityEdge(
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmCapacitiesEdge
  "Reads a single `AdmDomain` that is related to this `AdmCapacity`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmCapacityId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmDefaultTemplate` mutation."
type DeleteAdmDefaultTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmDefaultTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDefaultTemplate` that was deleted by this mutation."
  admDefaultTemplate: AdmDefaultTemplate
  "An edge for our `AdmDefaultTemplate`. May be used by Relay 1."
  admDefaultTemplateEdge(
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesEdge
  "Reads a single `AdmNarrative` that is related to this `AdmDefaultTemplate`."
  admNarrativeByIdAdmNarrative: AdmNarrative
  "Reads a single `AdmStrType` that is related to this `AdmDefaultTemplate`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmTemplate` that is related to this `AdmDefaultTemplate`."
  admTemplateByIdTemplate: AdmTemplate
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmDefaultTemplateId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmDistrikt` mutation."
type DeleteAdmDistriktPayload {
  "Reads a single `AdmApp` that is related to this `AdmDistrikt`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDistrikt` that was deleted by this mutation."
  admDistrikt: AdmDistrikt
  "An edge for our `AdmDistrikt`. May be used by Relay 1."
  admDistriktEdge(
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDistriktsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmDistriktId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmDocCategory` mutation."
type DeleteAdmDocCategoryPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocCategory`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDocCategory` that was deleted by this mutation."
  admDocCategory: AdmDocCategory
  "An edge for our `AdmDocCategory`. May be used by Relay 1."
  admDocCategoryEdge(
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocCategory`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmDocCategoryId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmDocSuggest` mutation."
type DeleteAdmDocSuggestPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocSuggest`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDocCategory` that is related to this `AdmDocSuggest`."
  admDocCategoryByIdAdmDocCategory: AdmDocCategory
  "The `AdmDocSuggest` that was deleted by this mutation."
  admDocSuggest: AdmDocSuggest
  "An edge for our `AdmDocSuggest`. May be used by Relay 1."
  admDocSuggestEdge(
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocSuggest`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmDocSuggestId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmDomain` mutation."
type DeleteAdmDomainPayload {
  "The `AdmDomain` that was deleted by this mutation."
  admDomain: AdmDomain
  "An edge for our `AdmDomain`. May be used by Relay 1."
  admDomainEdge(
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDomainsEdge
  "Reads a single `AdmFramework` that is related to this `AdmDomain`."
  admFrameworkByIdAdmFramework: AdmFramework
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmDomainId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmEngagement` mutation."
type DeleteAdmEngagementPayload {
  "The `AdmEngagement` that was deleted by this mutation."
  admEngagement: AdmEngagement
  "An edge for our `AdmEngagement`. May be used by Relay 1."
  admEngagementEdge(
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmEngagementsEdge
  "Reads a single `AdmSkool` that is related to this `AdmEngagement`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmEngagementId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmFramework` mutation."
type DeleteAdmFrameworkPayload {
  "Reads a single `AdmApp` that is related to this `AdmFramework`."
  admAppByIdAdmApp: AdmApp
  "The `AdmFramework` that was deleted by this mutation."
  admFramework: AdmFramework
  "An edge for our `AdmFramework`. May be used by Relay 1."
  admFrameworkEdge(
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksEdge
  "Reads a single `AdmScale` that is related to this `AdmFramework`."
  admScaleByIdAdmScale: AdmScale
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmFrameworkId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmNarrative` mutation."
type DeleteAdmNarrativePayload {
  "Reads a single `AdmApp` that is related to this `AdmNarrative`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDomain` that is related to this `AdmNarrative`."
  admDomainByIdAdmDomain: AdmDomain
  "The `AdmNarrative` that was deleted by this mutation."
  admNarrative: AdmNarrative
  "An edge for our `AdmNarrative`. May be used by Relay 1."
  admNarrativeEdge(
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmNarrativeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmPeriod` mutation."
type DeleteAdmPeriodPayload {
  "Reads a single `AdmApp` that is related to this `AdmPeriod`."
  admAppByIdAdmApp: AdmApp
  "The `AdmPeriod` that was deleted by this mutation."
  admPeriod: AdmPeriod
  "An edge for our `AdmPeriod`. May be used by Relay 1."
  admPeriodEdge(
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsEdge
  "Reads a single `AdmStrType` that is related to this `AdmPeriod`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmPeriodId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmPractice` mutation."
type DeleteAdmPracticePayload {
  "Reads a single `AdmCapacity` that is related to this `AdmPractice`."
  admCapacityByIdAdmCapacity: AdmCapacity
  "Reads a single `AdmFramework` that is related to this `AdmPractice`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmPractice` that was deleted by this mutation."
  admPractice: AdmPractice
  "An edge for our `AdmPractice`. May be used by Relay 1."
  admPracticeEdge(
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmPracticeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmRubricMap` mutation."
type DeleteAdmRubricMapPayload {
  "Reads a single `AdmPractice` that is related to this `AdmRubricMap`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmRubric` that is related to this `AdmRubricMap`."
  admRubricByIdAdmRubric: AdmRubric
  "The `AdmRubricMap` that was deleted by this mutation."
  admRubricMap: AdmRubricMap
  "An edge for our `AdmRubricMap`. May be used by Relay 1."
  admRubricMapEdge(
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmRubricMapId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmRubric` mutation."
type DeleteAdmRubricPayload {
  "Reads a single `AdmFramework` that is related to this `AdmRubric`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmRubric` that was deleted by this mutation."
  admRubric: AdmRubric
  "An edge for our `AdmRubric`. May be used by Relay 1."
  admRubricEdge(
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmRubricId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmScale` mutation."
type DeleteAdmScalePayload {
  "The `AdmScale` that was deleted by this mutation."
  admScale: AdmScale
  "An edge for our `AdmScale`. May be used by Relay 1."
  admScaleEdge(
    "The method to use when ordering `AdmScale`."
    orderBy: [AdmScalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScalesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmScaleId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmScore` mutation."
type DeleteAdmScorePayload {
  "Reads a single `AdmScale` that is related to this `AdmScore`."
  admScaleByIdAdmScale: AdmScale
  "The `AdmScore` that was deleted by this mutation."
  admScore: AdmScore
  "An edge for our `AdmScore`. May be used by Relay 1."
  admScoreEdge(
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScoresEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmScoreId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmSkool` mutation."
type DeleteAdmSkoolPayload {
  "Reads a single `AdmApp` that is related to this `AdmSkool`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDistrikt` that is related to this `AdmSkool`."
  admDistriktByIdDistrictNces: AdmDistrikt
  "The `AdmSkool` that was deleted by this mutation."
  admSkool: AdmSkool
  "An edge for our `AdmSkool`. May be used by Relay 1."
  admSkoolEdge(
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmSkoolId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmStrSequence` mutation."
type DeleteAdmStrSequencePayload {
  "The `AdmStrSequence` that was deleted by this mutation."
  admStrSequence: AdmStrSequence
  "An edge for our `AdmStrSequence`. May be used by Relay 1."
  admStrSequenceEdge(
    "The method to use when ordering `AdmStrSequence`."
    orderBy: [AdmStrSequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrSequencesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmStrSequenceId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmStrTypeMap` mutation."
type DeleteAdmStrTypeMapPayload {
  "Reads a single `AdmApp` that is related to this `AdmStrTypeMap`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmStrType` that is related to this `AdmStrTypeMap`."
  admStrTypeByIdAdmStrType: AdmStrType
  "The `AdmStrTypeMap` that was deleted by this mutation."
  admStrTypeMap: AdmStrTypeMap
  "An edge for our `AdmStrTypeMap`. May be used by Relay 1."
  admStrTypeMapEdge(
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmStrTypeMapId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `AdmStrTypeMap`."
  refRelationByIdRelation: RefRelation
}

"The output of our delete `AdmStrType` mutation."
type DeleteAdmStrTypePayload {
  "Reads a single `AdmApp` that is related to this `AdmStrType`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `AdmStrType`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmStrType` that was deleted by this mutation."
  admStrType: AdmStrType
  "An edge for our `AdmStrType`. May be used by Relay 1."
  admStrTypeEdge(
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmStrTypeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmTemplate` mutation."
type DeleteAdmTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmTemplate` that was deleted by this mutation."
  admTemplate: AdmTemplate
  "An edge for our `AdmTemplate`. May be used by Relay 1."
  admTemplateEdge(
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmTemplatesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmTemplateId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `AdmUser` mutation."
type DeleteAdmUserPayload {
  "The `AdmUser` that was deleted by this mutation."
  admUser: AdmUser
  "Reads a single `AdmUser` that is related to this `AdmUser`."
  admUserByIdManager: AdmUser
  "An edge for our `AdmUser`. May be used by Relay 1."
  admUserEdge(
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmUsersEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAdmUserId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `FlywaySchemaHistory` mutation."
type DeleteFlywaySchemaHistoryPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedFlywaySchemaHistoryId: ID
  "The `FlywaySchemaHistory` that was deleted by this mutation."
  flywaySchemaHistory: FlywaySchemaHistory
  "An edge for our `FlywaySchemaHistory`. May be used by Relay 1."
  flywaySchemaHistoryEdge(
    "The method to use when ordering `FlywaySchemaHistory`."
    orderBy: [FlywaySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlywaySchemaHistoriesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `Post` mutation."
type DeletePostPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedPostId: ID
  "The `Post` that was deleted by this mutation."
  post: Post
  "An edge for our `Post`. May be used by Relay 1."
  postEdge(
    "The method to use when ordering `Post`."
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our delete `RefObject` mutation."
type DeleteRefObjectPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedRefObjectId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefObject` that was deleted by this mutation."
  refObject: RefObject
  "An edge for our `RefObject`. May be used by Relay 1."
  refObjectEdge(
    "The method to use when ordering `RefObject`."
    orderBy: [RefObjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefObjectsEdge
}

"The output of our delete `RefRelation` mutation."
type DeleteRefRelationPayload {
  "Reads a single `AdmApp` that is related to this `RefRelation`."
  admAppByIdAdmApp: AdmApp
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedRefRelationId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefRelation` that was deleted by this mutation."
  refRelation: RefRelation
  "An edge for our `RefRelation`. May be used by Relay 1."
  refRelationEdge(
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRelationsEdge
}

"The output of our delete `RefStatus` mutation."
type DeleteRefStatusPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedRefStatusId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefStatus` that was deleted by this mutation."
  refStatus: RefStatus
  "An edge for our `RefStatus`. May be used by Relay 1."
  refStatusEdge(
    "The method to use when ordering `RefStatus`."
    orderBy: [RefStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefStatusesEdge
}

"The output of our delete `RefUserType` mutation."
type DeleteRefUserTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedRefUserTypeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefUserType` that was deleted by this mutation."
  refUserType: RefUserType
  "An edge for our `RefUserType`. May be used by Relay 1."
  refUserTypeEdge(
    "The method to use when ordering `RefUserType`."
    orderBy: [RefUserTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefUserTypesEdge
}

"The output of our delete `SActivity` mutation."
type DeleteSActivityPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSActivityId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SActivity` that was deleted by this mutation."
  sActivity: SActivity
  "An edge for our `SActivity`. May be used by Relay 1."
  sActivityEdge(
    "The method to use when ordering `SActivity`."
    orderBy: [SActivitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SActivitiesEdge
}

"The output of our delete `SErr` mutation."
type DeleteSErrPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSErrId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SErr` that was deleted by this mutation."
  sErr: SErr
  "An edge for our `SErr`. May be used by Relay 1."
  sErrEdge(
    "The method to use when ordering `SErr`."
    orderBy: [SErrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SErrsEdge
}

"The output of our delete `SLogCode` mutation."
type DeleteSLogCodePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSLogCodeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogCode` that was deleted by this mutation."
  sLogCode: SLogCode
  "An edge for our `SLogCode`. May be used by Relay 1."
  sLogCodeEdge(
    "The method to use when ordering `SLogCode`."
    orderBy: [SLogCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogCodesEdge
}

"The output of our delete `SLogDetail` mutation."
type DeleteSLogDetailPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSLogDetailId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogDetail` that was deleted by this mutation."
  sLogDetail: SLogDetail
  "An edge for our `SLogDetail`. May be used by Relay 1."
  sLogDetailEdge(
    "The method to use when ordering `SLogDetail`."
    orderBy: [SLogDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogDetailsEdge
}

"The output of our delete `SLog` mutation."
type DeleteSLogPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSLogId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLog` that was deleted by this mutation."
  sLog: SLog
  "An edge for our `SLog`. May be used by Relay 1."
  sLogEdge(
    "The method to use when ordering `SLog`."
    orderBy: [SLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogsEdge
}

"The output of our delete `STable` mutation."
type DeleteSTablePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSTableId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STable` that was deleted by this mutation."
  sTable: STable
  "An edge for our `STable`. May be used by Relay 1."
  sTableEdge(
    "The method to use when ordering `STable`."
    orderBy: [STablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STablesEdge
}

"The output of our delete `STableType` mutation."
type DeleteSTableTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSTableTypeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STableType` that was deleted by this mutation."
  sTableType: STableType
  "An edge for our `STableType`. May be used by Relay 1."
  sTableTypeEdge(
    "The method to use when ordering `STableType`."
    orderBy: [STableTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STableTypesEdge
}

"The output of our delete `UsrCapacity` mutation."
type DeleteUsrCapacityPayload {
  "Reads a single `AdmCapacity` that is related to this `UsrCapacity`."
  admCapacityByIdAdmCapacity: AdmCapacity
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrCapacityId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrCapacity` that was deleted by this mutation."
  usrCapacity: UsrCapacity
  "An edge for our `UsrCapacity`. May be used by Relay 1."
  usrCapacityEdge(
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesEdge
  "Reads a single `UsrDomain` that is related to this `UsrCapacity`."
  usrDomainByIdUsrDomain: UsrDomain
  "Reads a single `UsrStr` that is related to this `UsrCapacity`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our delete `UsrDoc` mutation."
type DeleteUsrDocPayload {
  "Reads a single `AdmApp` that is related to this `UsrDoc`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrDoc`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrDocId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDoc` that was deleted by this mutation."
  usrDoc: UsrDoc
  "An edge for our `UsrDoc`. May be used by Relay 1."
  usrDocEdge(
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsEdge
  "Reads a single `UsrStr` that is related to this `UsrDoc`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our delete `UsrDomain` mutation."
type DeleteUsrDomainPayload {
  "Reads a single `AdmDomain` that is related to this `UsrDomain`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrDomainId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDomain` that was deleted by this mutation."
  usrDomain: UsrDomain
  "An edge for our `UsrDomain`. May be used by Relay 1."
  usrDomainEdge(
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsEdge
  "Reads a single `UsrStr` that is related to this `UsrDomain`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our delete `UsrFocus` mutation."
type DeleteUsrFocusPayload {
  "Reads a single `AdmPractice` that is related to this `UsrFocus`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmSkool` that is related to this `UsrFocus`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrFocusId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrFocus` that was deleted by this mutation."
  usrFocus: UsrFocus
  "An edge for our `UsrFocus`. May be used by Relay 1."
  usrFocusEdge(
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociEdge
}

"The output of our delete `UsrNotify` mutation."
type DeleteUsrNotifyPayload {
  "Reads a single `AdmApp` that is related to this `UsrNotify`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrNotify`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrNotifyId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrNotify` that was deleted by this mutation."
  usrNotify: UsrNotify
  "An edge for our `UsrNotify`. May be used by Relay 1."
  usrNotifyEdge(
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesEdge
}

"The output of our delete `UsrPractice` mutation."
type DeleteUsrPracticePayload {
  "Reads a single `AdmPractice` that is related to this `UsrPractice`."
  admPracticeByIdAdmPractice: AdmPractice
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrPracticeId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrCapacity` that is related to this `UsrPractice`."
  usrCapacityByIdUsrCapacity: UsrCapacity
  "The `UsrPractice` that was deleted by this mutation."
  usrPractice: UsrPractice
  "An edge for our `UsrPractice`. May be used by Relay 1."
  usrPracticeEdge(
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesEdge
  "Reads a single `UsrStr` that is related to this `UsrPractice`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our delete `UsrRelationship` mutation."
type DeleteUsrRelationshipPayload {
  "Reads a single `AdmApp` that is related to this `UsrRelationship`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrRelationship`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrRelationshipId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `UsrRelationship`."
  refRelationByIdRelation: RefRelation
  "The `UsrRelationship` that was deleted by this mutation."
  usrRelationship: UsrRelationship
  "An edge for our `UsrRelationship`. May be used by Relay 1."
  usrRelationshipEdge(
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsEdge
  "Reads a single `UsrStr` that is related to this `UsrRelationship`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our delete `UsrStr` mutation."
type DeleteUsrStrPayload {
  "Reads a single `AdmApp` that is related to this `UsrStr`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `UsrStr`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads a single `AdmPeriod` that is related to this `UsrStr`."
  admPeriodByIdAdmPeriod: AdmPeriod
  "Reads a single `AdmRubric` that is related to this `UsrStr`."
  admRubricByIdAdmRubric: AdmRubric
  "Reads a single `AdmSkool` that is related to this `UsrStr`."
  admSkoolByIdSchoolNces: AdmSkool
  "Reads a single `AdmStrType` that is related to this `UsrStr`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmUser` that is related to this `UsrStr`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedUsrStrId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrRelationship` that is related to this `UsrStr`."
  usrRelationshipByCurrentIdUsrRelationship: UsrRelationship
  "The `UsrStr` that was deleted by this mutation."
  usrStr: UsrStr
  "An edge for our `UsrStr`. May be used by Relay 1."
  usrStrEdge(
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsEdge
}

"The output of our delete `VwDistrict` mutation."
type DeleteVwDistrictPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedVwDistrictId: ID
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `VwDistrict` that was deleted by this mutation."
  vwDistrict: VwDistrict
  "An edge for our `VwDistrict`. May be used by Relay 1."
  vwDistrictEdge(
    "The method to use when ordering `VwDistrict`."
    orderBy: [VwDistrictsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDistrictsEdge
}

"A connection to a list of `FlywaySchemaHistory` values."
type FlywaySchemaHistoriesConnection {
  "A list of edges which contains the `FlywaySchemaHistory` and cursor to aid in pagination."
  edges: [FlywaySchemaHistoriesEdge!]!
  "A list of `FlywaySchemaHistory` objects."
  nodes: [FlywaySchemaHistory]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `FlywaySchemaHistory` you could get from the connection."
  totalCount: Int!
}

"A `FlywaySchemaHistory` edge in the connection."
type FlywaySchemaHistoriesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `FlywaySchemaHistory` at the end of the edge."
  node: FlywaySchemaHistory
}

type FlywaySchemaHistory implements Node {
  checksum: Int
  description: String!
  executionTime: Int!
  installedBy: String!
  installedOn: Datetime!
  installedRank: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  script: String!
  success: Boolean!
  type: String!
  version: String
}

"The output of our `getmanager` mutation."
type GetmanagerPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `getnextreview` mutation."
type GetnextreviewPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `getpreviousreview` mutation."
type GetpreviousreviewPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `getuseremail` mutation."
type GetuseremailPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  string: String
}

"The output of our `getuseridbyemail` mutation."
type GetuseridbyemailPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"An interval of time that has passed where the smallest distinct unit is a second."
type Interval {
  "A quantity of days."
  days: Int
  "A quantity of hours."
  hours: Int
  "A quantity of minutes."
  minutes: Int
  "A quantity of months."
  months: Int
  """

  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals dont
  have a smaller unit than seconds.
  """
  seconds: Float
  "A quantity of years."
  years: Int
}

"The output of our `logEnd` mutation."
type LogEndPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  sLogDetails: [SLogDetail]
}

"The output of our `logStart` mutation."
type LogStartPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `makeUidSchool` mutation."
type MakeUidSchoolPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  string: String
}

"The root mutation type which contains root level fields which mutate data."
type Mutation {
  "Creates a single `AdmAccess`."
  createAdmAccess(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmAccessInput!
  ): CreateAdmAccessPayload
  "Creates a single `AdmApp`."
  createAdmApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmAppInput!
  ): CreateAdmAppPayload
  "Creates a single `AdmCapacity`."
  createAdmCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmCapacityInput!
  ): CreateAdmCapacityPayload
  "Creates a single `AdmDefaultTemplate`."
  createAdmDefaultTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmDefaultTemplateInput!
  ): CreateAdmDefaultTemplatePayload
  "Creates a single `AdmDistrikt`."
  createAdmDistrikt(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmDistriktInput!
  ): CreateAdmDistriktPayload
  "Creates a single `AdmDocCategory`."
  createAdmDocCategory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmDocCategoryInput!
  ): CreateAdmDocCategoryPayload
  "Creates a single `AdmDocSuggest`."
  createAdmDocSuggest(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmDocSuggestInput!
  ): CreateAdmDocSuggestPayload
  "Creates a single `AdmDomain`."
  createAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmDomainInput!
  ): CreateAdmDomainPayload
  "Creates a single `AdmEngagement`."
  createAdmEngagement(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmEngagementInput!
  ): CreateAdmEngagementPayload
  "Creates a single `AdmFramework`."
  createAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmFrameworkInput!
  ): CreateAdmFrameworkPayload
  "Creates a single `AdmNarrative`."
  createAdmNarrative(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmNarrativeInput!
  ): CreateAdmNarrativePayload
  "Creates a single `AdmPeriod`."
  createAdmPeriod(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmPeriodInput!
  ): CreateAdmPeriodPayload
  "Creates a single `AdmPractice`."
  createAdmPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmPracticeInput!
  ): CreateAdmPracticePayload
  "Creates a single `AdmRubric`."
  createAdmRubric(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmRubricInput!
  ): CreateAdmRubricPayload
  "Creates a single `AdmRubricMap`."
  createAdmRubricMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmRubricMapInput!
  ): CreateAdmRubricMapPayload
  "Creates a single `AdmScale`."
  createAdmScale(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmScaleInput!
  ): CreateAdmScalePayload
  "Creates a single `AdmScore`."
  createAdmScore(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmScoreInput!
  ): CreateAdmScorePayload
  "Creates a single `AdmSkool`."
  createAdmSkool(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmSkoolInput!
  ): CreateAdmSkoolPayload
  "Creates a single `AdmStrSequence`."
  createAdmStrSequence(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmStrSequenceInput!
  ): CreateAdmStrSequencePayload
  "Creates a single `AdmStrType`."
  createAdmStrType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmStrTypeInput!
  ): CreateAdmStrTypePayload
  "Creates a single `AdmStrTypeMap`."
  createAdmStrTypeMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmStrTypeMapInput!
  ): CreateAdmStrTypeMapPayload
  "Creates a single `AdmTemplate`."
  createAdmTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmTemplateInput!
  ): CreateAdmTemplatePayload
  "Creates a single `AdmUser`."
  createAdmUser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateAdmUserInput!
  ): CreateAdmUserPayload
  "Creates a single `FlywaySchemaHistory`."
  createFlywaySchemaHistory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateFlywaySchemaHistoryInput!
  ): CreateFlywaySchemaHistoryPayload
  "Creates a single `Post`."
  createPost(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreatePostInput!
  ): CreatePostPayload
  "Creates a single `RefObject`."
  createRefObject(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateRefObjectInput!
  ): CreateRefObjectPayload
  "Creates a single `RefRelation`."
  createRefRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateRefRelationInput!
  ): CreateRefRelationPayload
  "Creates a single `RefStatus`."
  createRefStatus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateRefStatusInput!
  ): CreateRefStatusPayload
  "Creates a single `RefUserType`."
  createRefUserType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateRefUserTypeInput!
  ): CreateRefUserTypePayload
  "Creates a single `SActivity`."
  createSActivity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSActivityInput!
  ): CreateSActivityPayload
  "Creates a single `SErr`."
  createSErr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSErrInput!
  ): CreateSErrPayload
  "Creates a single `SLog`."
  createSLog(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSLogInput!
  ): CreateSLogPayload
  "Creates a single `SLogCode`."
  createSLogCode(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSLogCodeInput!
  ): CreateSLogCodePayload
  "Creates a single `SLogDetail`."
  createSLogDetail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSLogDetailInput!
  ): CreateSLogDetailPayload
  "Creates a single `STable`."
  createSTable(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSTableInput!
  ): CreateSTablePayload
  "Creates a single `STableType`."
  createSTableType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateSTableTypeInput!
  ): CreateSTableTypePayload
  "Creates a single `UsrCapacity`."
  createUsrCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrCapacityInput!
  ): CreateUsrCapacityPayload
  "Creates a single `UsrDoc`."
  createUsrDoc(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrDocInput!
  ): CreateUsrDocPayload
  "Creates a single `UsrDomain`."
  createUsrDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrDomainInput!
  ): CreateUsrDomainPayload
  "Creates a single `UsrFocus`."
  createUsrFocus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrFocusInput!
  ): CreateUsrFocusPayload
  "Creates a single `UsrNotify`."
  createUsrNotify(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrNotifyInput!
  ): CreateUsrNotifyPayload
  "Creates a single `UsrPractice`."
  createUsrPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrPracticeInput!
  ): CreateUsrPracticePayload
  "Creates a single `UsrRelationship`."
  createUsrRelationship(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrRelationshipInput!
  ): CreateUsrRelationshipPayload
  "Creates a single `UsrStr`."
  createUsrStr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateUsrStrInput!
  ): CreateUsrStrPayload
  "Creates a single `VwDistrict`."
  createVwDistrict(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateVwDistrictInput!
  ): CreateVwDistrictPayload
  "Creates a single `VwTestApp`."
  createVwTestApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CreateVwTestAppInput!
  ): CreateVwTestAppPayload
  currentreviewer(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CurrentreviewerInput!
  ): CurrentreviewerPayload
  currentreviewuser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: CurrentreviewuserInput!
  ): CurrentreviewuserPayload
  "Deletes a single `AdmAccess` using its globally unique id."
  deleteAdmAccess(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmAccessInput!
  ): DeleteAdmAccessPayload
  "Deletes a single `AdmAccess` using a unique key."
  deleteAdmAccessByIdAdmAccess(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmAccessByIdAdmAccessInput!
  ): DeleteAdmAccessPayload
  "Deletes a single `AdmApp` using its globally unique id."
  deleteAdmApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmAppInput!
  ): DeleteAdmAppPayload
  "Deletes a single `AdmApp` using a unique key."
  deleteAdmAppByIdAdmApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmAppByIdAdmAppInput!
  ): DeleteAdmAppPayload
  "Deletes a single `AdmCapacity` using its globally unique id."
  deleteAdmCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmCapacityInput!
  ): DeleteAdmCapacityPayload
  "Deletes a single `AdmCapacity` using a unique key."
  deleteAdmCapacityByIdAdmCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmCapacityByIdAdmCapacityInput!
  ): DeleteAdmCapacityPayload
  "Deletes a single `AdmCapacity` using a unique key."
  deleteAdmCapacityByIdAdmCapacityAndIdAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmCapacityByIdAdmCapacityAndIdAdmDomainInput!
  ): DeleteAdmCapacityPayload
  "Deletes a single `AdmDefaultTemplate` using its globally unique id."
  deleteAdmDefaultTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDefaultTemplateInput!
  ): DeleteAdmDefaultTemplatePayload
  "Deletes a single `AdmDefaultTemplate` using a unique key."
  deleteAdmDefaultTemplateByIdAdmDefaultNt(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDefaultTemplateByIdAdmDefaultNtInput!
  ): DeleteAdmDefaultTemplatePayload
  "Deletes a single `AdmDistrikt` using its globally unique id."
  deleteAdmDistrikt(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDistriktInput!
  ): DeleteAdmDistriktPayload
  "Deletes a single `AdmDistrikt` using a unique key."
  deleteAdmDistriktByIdDistrictNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDistriktByIdDistrictNcesInput!
  ): DeleteAdmDistriktPayload
  "Deletes a single `AdmDocCategory` using its globally unique id."
  deleteAdmDocCategory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDocCategoryInput!
  ): DeleteAdmDocCategoryPayload
  "Deletes a single `AdmDocCategory` using a unique key."
  deleteAdmDocCategoryByIdAdmDocCategory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDocCategoryByIdAdmDocCategoryInput!
  ): DeleteAdmDocCategoryPayload
  "Deletes a single `AdmDocSuggest` using its globally unique id."
  deleteAdmDocSuggest(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDocSuggestInput!
  ): DeleteAdmDocSuggestPayload
  "Deletes a single `AdmDocSuggest` using a unique key."
  deleteAdmDocSuggestByIdAdmDocSuggest(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDocSuggestByIdAdmDocSuggestInput!
  ): DeleteAdmDocSuggestPayload
  "Deletes a single `AdmDomain` using its globally unique id."
  deleteAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDomainInput!
  ): DeleteAdmDomainPayload
  "Deletes a single `AdmDomain` using a unique key."
  deleteAdmDomainByIdAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDomainByIdAdmDomainInput!
  ): DeleteAdmDomainPayload
  "Deletes a single `AdmDomain` using a unique key."
  deleteAdmDomainByIdAdmDomainAndIdAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmDomainByIdAdmDomainAndIdAdmFrameworkInput!
  ): DeleteAdmDomainPayload
  "Deletes a single `AdmEngagement` using its globally unique id."
  deleteAdmEngagement(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmEngagementInput!
  ): DeleteAdmEngagementPayload
  "Deletes a single `AdmEngagement` using a unique key."
  deleteAdmEngagementByIdAdmEngagement(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmEngagementByIdAdmEngagementInput!
  ): DeleteAdmEngagementPayload
  "Deletes a single `AdmFramework` using its globally unique id."
  deleteAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmFrameworkInput!
  ): DeleteAdmFrameworkPayload
  "Deletes a single `AdmFramework` using a unique key."
  deleteAdmFrameworkByIdAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmFrameworkByIdAdmFrameworkInput!
  ): DeleteAdmFrameworkPayload
  "Deletes a single `AdmNarrative` using its globally unique id."
  deleteAdmNarrative(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmNarrativeInput!
  ): DeleteAdmNarrativePayload
  "Deletes a single `AdmNarrative` using a unique key."
  deleteAdmNarrativeByIdAdmNarrative(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmNarrativeByIdAdmNarrativeInput!
  ): DeleteAdmNarrativePayload
  "Deletes a single `AdmPeriod` using its globally unique id."
  deleteAdmPeriod(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmPeriodInput!
  ): DeleteAdmPeriodPayload
  "Deletes a single `AdmPeriod` using a unique key."
  deleteAdmPeriodByIdAdmPeriod(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmPeriodByIdAdmPeriodInput!
  ): DeleteAdmPeriodPayload
  "Deletes a single `AdmPractice` using its globally unique id."
  deleteAdmPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmPracticeInput!
  ): DeleteAdmPracticePayload
  "Deletes a single `AdmPractice` using a unique key."
  deleteAdmPracticeByIdAdmPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmPracticeByIdAdmPracticeInput!
  ): DeleteAdmPracticePayload
  "Deletes a single `AdmRubric` using its globally unique id."
  deleteAdmRubric(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmRubricInput!
  ): DeleteAdmRubricPayload
  "Deletes a single `AdmRubric` using a unique key."
  deleteAdmRubricByIdAdmRubric(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmRubricByIdAdmRubricInput!
  ): DeleteAdmRubricPayload
  "Deletes a single `AdmRubricMap` using its globally unique id."
  deleteAdmRubricMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmRubricMapInput!
  ): DeleteAdmRubricMapPayload
  "Deletes a single `AdmRubricMap` using a unique key."
  deleteAdmRubricMapByIdAdmRubricMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmRubricMapByIdAdmRubricMapInput!
  ): DeleteAdmRubricMapPayload
  "Deletes a single `AdmScale` using its globally unique id."
  deleteAdmScale(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmScaleInput!
  ): DeleteAdmScalePayload
  "Deletes a single `AdmScale` using a unique key."
  deleteAdmScaleByIdAdmScale(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmScaleByIdAdmScaleInput!
  ): DeleteAdmScalePayload
  "Deletes a single `AdmScore` using its globally unique id."
  deleteAdmScore(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmScoreInput!
  ): DeleteAdmScorePayload
  "Deletes a single `AdmScore` using a unique key."
  deleteAdmScoreByIdAdmScore(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmScoreByIdAdmScoreInput!
  ): DeleteAdmScorePayload
  "Deletes a single `AdmSkool` using its globally unique id."
  deleteAdmSkool(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmSkoolInput!
  ): DeleteAdmSkoolPayload
  "Deletes a single `AdmSkool` using a unique key."
  deleteAdmSkoolByIdSchoolNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmSkoolByIdSchoolNcesInput!
  ): DeleteAdmSkoolPayload
  "Deletes a single `AdmStrSequence` using its globally unique id."
  deleteAdmStrSequence(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrSequenceInput!
  ): DeleteAdmStrSequencePayload
  "Deletes a single `AdmStrSequence` using a unique key."
  deleteAdmStrSequenceByIdAdmStrSequence(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrSequenceByIdAdmStrSequenceInput!
  ): DeleteAdmStrSequencePayload
  "Deletes a single `AdmStrType` using its globally unique id."
  deleteAdmStrType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrTypeInput!
  ): DeleteAdmStrTypePayload
  "Deletes a single `AdmStrType` using a unique key."
  deleteAdmStrTypeByIdAdmStrType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrTypeByIdAdmStrTypeInput!
  ): DeleteAdmStrTypePayload
  "Deletes a single `AdmStrTypeMap` using its globally unique id."
  deleteAdmStrTypeMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrTypeMapInput!
  ): DeleteAdmStrTypeMapPayload
  "Deletes a single `AdmStrTypeMap` using a unique key."
  deleteAdmStrTypeMapByIdAdmStrTypeMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmStrTypeMapByIdAdmStrTypeMapInput!
  ): DeleteAdmStrTypeMapPayload
  "Deletes a single `AdmTemplate` using its globally unique id."
  deleteAdmTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmTemplateInput!
  ): DeleteAdmTemplatePayload
  "Deletes a single `AdmTemplate` using a unique key."
  deleteAdmTemplateByIdTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmTemplateByIdTemplateInput!
  ): DeleteAdmTemplatePayload
  "Deletes a single `AdmUser` using its globally unique id."
  deleteAdmUser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmUserInput!
  ): DeleteAdmUserPayload
  "Deletes a single `AdmUser` using a unique key."
  deleteAdmUserByIdAdmUser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteAdmUserByIdAdmUserInput!
  ): DeleteAdmUserPayload
  "Deletes a single `FlywaySchemaHistory` using its globally unique id."
  deleteFlywaySchemaHistory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteFlywaySchemaHistoryInput!
  ): DeleteFlywaySchemaHistoryPayload
  "Deletes a single `FlywaySchemaHistory` using a unique key."
  deleteFlywaySchemaHistoryByInstalledRank(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteFlywaySchemaHistoryByInstalledRankInput!
  ): DeleteFlywaySchemaHistoryPayload
  "Deletes a single `Post` using its globally unique id."
  deletePost(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeletePostInput!
  ): DeletePostPayload
  "Deletes a single `Post` using a unique key."
  deletePostById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeletePostByIdInput!
  ): DeletePostPayload
  "Deletes a single `RefObject` using its globally unique id."
  deleteRefObject(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefObjectInput!
  ): DeleteRefObjectPayload
  "Deletes a single `RefObject` using a unique key."
  deleteRefObjectByIdObject(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefObjectByIdObjectInput!
  ): DeleteRefObjectPayload
  "Deletes a single `RefRelation` using its globally unique id."
  deleteRefRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefRelationInput!
  ): DeleteRefRelationPayload
  "Deletes a single `RefRelation` using a unique key."
  deleteRefRelationByIdRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefRelationByIdRelationInput!
  ): DeleteRefRelationPayload
  "Deletes a single `RefStatus` using its globally unique id."
  deleteRefStatus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefStatusInput!
  ): DeleteRefStatusPayload
  "Deletes a single `RefStatus` using a unique key."
  deleteRefStatusByIdStatus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefStatusByIdStatusInput!
  ): DeleteRefStatusPayload
  "Deletes a single `RefUserType` using its globally unique id."
  deleteRefUserType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefUserTypeInput!
  ): DeleteRefUserTypePayload
  "Deletes a single `RefUserType` using a unique key."
  deleteRefUserTypeByIdUserType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteRefUserTypeByIdUserTypeInput!
  ): DeleteRefUserTypePayload
  "Deletes a single `SActivity` using its globally unique id."
  deleteSActivity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSActivityInput!
  ): DeleteSActivityPayload
  "Deletes a single `SActivity` using a unique key."
  deleteSActivityById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSActivityByIdInput!
  ): DeleteSActivityPayload
  "Deletes a single `SErr` using its globally unique id."
  deleteSErr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSErrInput!
  ): DeleteSErrPayload
  "Deletes a single `SErr` using a unique key."
  deleteSErrById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSErrByIdInput!
  ): DeleteSErrPayload
  "Deletes a single `SLog` using its globally unique id."
  deleteSLog(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogInput!
  ): DeleteSLogPayload
  "Deletes a single `SLog` using a unique key."
  deleteSLogByIdLog(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogByIdLogInput!
  ): DeleteSLogPayload
  "Deletes a single `SLogCode` using its globally unique id."
  deleteSLogCode(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogCodeInput!
  ): DeleteSLogCodePayload
  "Deletes a single `SLogCode` using a unique key."
  deleteSLogCodeByIdCode(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogCodeByIdCodeInput!
  ): DeleteSLogCodePayload
  "Deletes a single `SLogDetail` using its globally unique id."
  deleteSLogDetail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogDetailInput!
  ): DeleteSLogDetailPayload
  "Deletes a single `SLogDetail` using a unique key."
  deleteSLogDetailByIdLogDetail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSLogDetailByIdLogDetailInput!
  ): DeleteSLogDetailPayload
  "Deletes a single `STable` using its globally unique id."
  deleteSTable(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSTableInput!
  ): DeleteSTablePayload
  "Deletes a single `STable` using a unique key."
  deleteSTableById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSTableByIdInput!
  ): DeleteSTablePayload
  "Deletes a single `STableType` using its globally unique id."
  deleteSTableType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSTableTypeInput!
  ): DeleteSTableTypePayload
  "Deletes a single `STableType` using a unique key."
  deleteSTableTypeByIdTabletype(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteSTableTypeByIdTabletypeInput!
  ): DeleteSTableTypePayload
  "Deletes a single `UsrCapacity` using its globally unique id."
  deleteUsrCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrCapacityInput!
  ): DeleteUsrCapacityPayload
  "Deletes a single `UsrCapacity` using a unique key."
  deleteUsrCapacityByIdUsrCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrCapacityByIdUsrCapacityInput!
  ): DeleteUsrCapacityPayload
  "Deletes a single `UsrDoc` using its globally unique id."
  deleteUsrDoc(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrDocInput!
  ): DeleteUsrDocPayload
  "Deletes a single `UsrDoc` using a unique key."
  deleteUsrDocByIdUsrDoc(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrDocByIdUsrDocInput!
  ): DeleteUsrDocPayload
  "Deletes a single `UsrDomain` using its globally unique id."
  deleteUsrDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrDomainInput!
  ): DeleteUsrDomainPayload
  "Deletes a single `UsrDomain` using a unique key."
  deleteUsrDomainByIdUsrDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrDomainByIdUsrDomainInput!
  ): DeleteUsrDomainPayload
  "Deletes a single `UsrFocus` using its globally unique id."
  deleteUsrFocus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrFocusInput!
  ): DeleteUsrFocusPayload
  "Deletes a single `UsrFocus` using a unique key."
  deleteUsrFocusByIdUsrFocus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrFocusByIdUsrFocusInput!
  ): DeleteUsrFocusPayload
  "Deletes a single `UsrNotify` using its globally unique id."
  deleteUsrNotify(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrNotifyInput!
  ): DeleteUsrNotifyPayload
  "Deletes a single `UsrNotify` using a unique key."
  deleteUsrNotifyByIdNotify(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrNotifyByIdNotifyInput!
  ): DeleteUsrNotifyPayload
  "Deletes a single `UsrPractice` using its globally unique id."
  deleteUsrPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrPracticeInput!
  ): DeleteUsrPracticePayload
  "Deletes a single `UsrPractice` using a unique key."
  deleteUsrPracticeByIdUsrPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrPracticeByIdUsrPracticeInput!
  ): DeleteUsrPracticePayload
  "Deletes a single `UsrRelationship` using its globally unique id."
  deleteUsrRelationship(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrRelationshipInput!
  ): DeleteUsrRelationshipPayload
  "Deletes a single `UsrRelationship` using a unique key."
  deleteUsrRelationshipByIdUsrRelationship(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrRelationshipByIdUsrRelationshipInput!
  ): DeleteUsrRelationshipPayload
  "Deletes a single `UsrStr` using its globally unique id."
  deleteUsrStr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrStrInput!
  ): DeleteUsrStrPayload
  "Deletes a single `UsrStr` using a unique key."
  deleteUsrStrByIdUsrStr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteUsrStrByIdUsrStrInput!
  ): DeleteUsrStrPayload
  "Deletes a single `VwDistrict` using its globally unique id."
  deleteVwDistrict(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteVwDistrictInput!
  ): DeleteVwDistrictPayload
  "Deletes a single `VwDistrict` using a unique key."
  deleteVwDistrictByIdDistrictNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: DeleteVwDistrictByIdDistrictNcesInput!
  ): DeleteVwDistrictPayload
  getmanager(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: GetmanagerInput!
  ): GetmanagerPayload
  getnextreview(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: GetnextreviewInput!
  ): GetnextreviewPayload
  getpreviousreview(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: GetpreviousreviewInput!
  ): GetpreviousreviewPayload
  getuseremail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: GetuseremailInput!
  ): GetuseremailPayload
  getuseridbyemail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: GetuseridbyemailInput!
  ): GetuseridbyemailPayload
  logEnd(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: LogEndInput!
  ): LogEndPayload
  logStart(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: LogStartInput!
  ): LogStartPayload
  makeUidSchool(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: MakeUidSchoolInput!
  ): MakeUidSchoolPayload
  nextreviewer(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: NextreviewerInput!
  ): NextreviewerPayload
  nextreviewuser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: NextreviewuserInput!
  ): NextreviewuserPayload
  readAllNotifies(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReadAllNotifiesInput!
  ): ReadAllNotifiesPayload
  reviewApprove(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReviewApproveInput!
  ): ReviewApprovePayload
  reviewBackfill(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReviewBackfillInput!
  ): ReviewBackfillPayload
  reviewCalculateScores(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReviewCalculateScoresInput!
  ): ReviewCalculateScoresPayload
  reviewCreateDependent(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReviewCreateDependentInput!
  ): ReviewCreateDependentPayload
  reviewSetInitialRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: ReviewSetInitialRelationInput!
  ): ReviewSetInitialRelationPayload
  schoolAddFromReference(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: SchoolAddFromReferenceInput!
  ): SchoolAddFromReferencePayload
  "Updates a single `AdmAccess` using its globally unique id and a patch."
  updateAdmAccess(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmAccessInput!
  ): UpdateAdmAccessPayload
  "Updates a single `AdmAccess` using a unique key and a patch."
  updateAdmAccessByIdAdmAccess(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmAccessByIdAdmAccessInput!
  ): UpdateAdmAccessPayload
  "Updates a single `AdmApp` using its globally unique id and a patch."
  updateAdmApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmAppInput!
  ): UpdateAdmAppPayload
  "Updates a single `AdmApp` using a unique key and a patch."
  updateAdmAppByIdAdmApp(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmAppByIdAdmAppInput!
  ): UpdateAdmAppPayload
  "Updates a single `AdmCapacity` using its globally unique id and a patch."
  updateAdmCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmCapacityInput!
  ): UpdateAdmCapacityPayload
  "Updates a single `AdmCapacity` using a unique key and a patch."
  updateAdmCapacityByIdAdmCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmCapacityByIdAdmCapacityInput!
  ): UpdateAdmCapacityPayload
  "Updates a single `AdmCapacity` using a unique key and a patch."
  updateAdmCapacityByIdAdmCapacityAndIdAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmCapacityByIdAdmCapacityAndIdAdmDomainInput!
  ): UpdateAdmCapacityPayload
  "Updates a single `AdmDefaultTemplate` using its globally unique id and a patch."
  updateAdmDefaultTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDefaultTemplateInput!
  ): UpdateAdmDefaultTemplatePayload
  "Updates a single `AdmDefaultTemplate` using a unique key and a patch."
  updateAdmDefaultTemplateByIdAdmDefaultNt(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDefaultTemplateByIdAdmDefaultNtInput!
  ): UpdateAdmDefaultTemplatePayload
  "Updates a single `AdmDistrikt` using its globally unique id and a patch."
  updateAdmDistrikt(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDistriktInput!
  ): UpdateAdmDistriktPayload
  "Updates a single `AdmDistrikt` using a unique key and a patch."
  updateAdmDistriktByIdDistrictNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDistriktByIdDistrictNcesInput!
  ): UpdateAdmDistriktPayload
  "Updates a single `AdmDocCategory` using its globally unique id and a patch."
  updateAdmDocCategory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDocCategoryInput!
  ): UpdateAdmDocCategoryPayload
  "Updates a single `AdmDocCategory` using a unique key and a patch."
  updateAdmDocCategoryByIdAdmDocCategory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDocCategoryByIdAdmDocCategoryInput!
  ): UpdateAdmDocCategoryPayload
  "Updates a single `AdmDocSuggest` using its globally unique id and a patch."
  updateAdmDocSuggest(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDocSuggestInput!
  ): UpdateAdmDocSuggestPayload
  "Updates a single `AdmDocSuggest` using a unique key and a patch."
  updateAdmDocSuggestByIdAdmDocSuggest(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDocSuggestByIdAdmDocSuggestInput!
  ): UpdateAdmDocSuggestPayload
  "Updates a single `AdmDomain` using its globally unique id and a patch."
  updateAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDomainInput!
  ): UpdateAdmDomainPayload
  "Updates a single `AdmDomain` using a unique key and a patch."
  updateAdmDomainByIdAdmDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDomainByIdAdmDomainInput!
  ): UpdateAdmDomainPayload
  "Updates a single `AdmDomain` using a unique key and a patch."
  updateAdmDomainByIdAdmDomainAndIdAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmDomainByIdAdmDomainAndIdAdmFrameworkInput!
  ): UpdateAdmDomainPayload
  "Updates a single `AdmEngagement` using its globally unique id and a patch."
  updateAdmEngagement(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmEngagementInput!
  ): UpdateAdmEngagementPayload
  "Updates a single `AdmEngagement` using a unique key and a patch."
  updateAdmEngagementByIdAdmEngagement(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmEngagementByIdAdmEngagementInput!
  ): UpdateAdmEngagementPayload
  "Updates a single `AdmFramework` using its globally unique id and a patch."
  updateAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmFrameworkInput!
  ): UpdateAdmFrameworkPayload
  "Updates a single `AdmFramework` using a unique key and a patch."
  updateAdmFrameworkByIdAdmFramework(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmFrameworkByIdAdmFrameworkInput!
  ): UpdateAdmFrameworkPayload
  "Updates a single `AdmNarrative` using its globally unique id and a patch."
  updateAdmNarrative(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmNarrativeInput!
  ): UpdateAdmNarrativePayload
  "Updates a single `AdmNarrative` using a unique key and a patch."
  updateAdmNarrativeByIdAdmNarrative(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmNarrativeByIdAdmNarrativeInput!
  ): UpdateAdmNarrativePayload
  "Updates a single `AdmPeriod` using its globally unique id and a patch."
  updateAdmPeriod(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmPeriodInput!
  ): UpdateAdmPeriodPayload
  "Updates a single `AdmPeriod` using a unique key and a patch."
  updateAdmPeriodByIdAdmPeriod(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmPeriodByIdAdmPeriodInput!
  ): UpdateAdmPeriodPayload
  "Updates a single `AdmPractice` using its globally unique id and a patch."
  updateAdmPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmPracticeInput!
  ): UpdateAdmPracticePayload
  "Updates a single `AdmPractice` using a unique key and a patch."
  updateAdmPracticeByIdAdmPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmPracticeByIdAdmPracticeInput!
  ): UpdateAdmPracticePayload
  "Updates a single `AdmRubric` using its globally unique id and a patch."
  updateAdmRubric(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmRubricInput!
  ): UpdateAdmRubricPayload
  "Updates a single `AdmRubric` using a unique key and a patch."
  updateAdmRubricByIdAdmRubric(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmRubricByIdAdmRubricInput!
  ): UpdateAdmRubricPayload
  "Updates a single `AdmRubricMap` using its globally unique id and a patch."
  updateAdmRubricMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmRubricMapInput!
  ): UpdateAdmRubricMapPayload
  "Updates a single `AdmRubricMap` using a unique key and a patch."
  updateAdmRubricMapByIdAdmRubricMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmRubricMapByIdAdmRubricMapInput!
  ): UpdateAdmRubricMapPayload
  "Updates a single `AdmScale` using its globally unique id and a patch."
  updateAdmScale(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmScaleInput!
  ): UpdateAdmScalePayload
  "Updates a single `AdmScale` using a unique key and a patch."
  updateAdmScaleByIdAdmScale(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmScaleByIdAdmScaleInput!
  ): UpdateAdmScalePayload
  "Updates a single `AdmScore` using its globally unique id and a patch."
  updateAdmScore(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmScoreInput!
  ): UpdateAdmScorePayload
  "Updates a single `AdmScore` using a unique key and a patch."
  updateAdmScoreByIdAdmScore(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmScoreByIdAdmScoreInput!
  ): UpdateAdmScorePayload
  "Updates a single `AdmSkool` using its globally unique id and a patch."
  updateAdmSkool(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmSkoolInput!
  ): UpdateAdmSkoolPayload
  "Updates a single `AdmSkool` using a unique key and a patch."
  updateAdmSkoolByIdSchoolNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmSkoolByIdSchoolNcesInput!
  ): UpdateAdmSkoolPayload
  "Updates a single `AdmStrSequence` using its globally unique id and a patch."
  updateAdmStrSequence(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrSequenceInput!
  ): UpdateAdmStrSequencePayload
  "Updates a single `AdmStrSequence` using a unique key and a patch."
  updateAdmStrSequenceByIdAdmStrSequence(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrSequenceByIdAdmStrSequenceInput!
  ): UpdateAdmStrSequencePayload
  "Updates a single `AdmStrType` using its globally unique id and a patch."
  updateAdmStrType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrTypeInput!
  ): UpdateAdmStrTypePayload
  "Updates a single `AdmStrType` using a unique key and a patch."
  updateAdmStrTypeByIdAdmStrType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrTypeByIdAdmStrTypeInput!
  ): UpdateAdmStrTypePayload
  "Updates a single `AdmStrTypeMap` using its globally unique id and a patch."
  updateAdmStrTypeMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrTypeMapInput!
  ): UpdateAdmStrTypeMapPayload
  "Updates a single `AdmStrTypeMap` using a unique key and a patch."
  updateAdmStrTypeMapByIdAdmStrTypeMap(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmStrTypeMapByIdAdmStrTypeMapInput!
  ): UpdateAdmStrTypeMapPayload
  "Updates a single `AdmTemplate` using its globally unique id and a patch."
  updateAdmTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmTemplateInput!
  ): UpdateAdmTemplatePayload
  "Updates a single `AdmTemplate` using a unique key and a patch."
  updateAdmTemplateByIdTemplate(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmTemplateByIdTemplateInput!
  ): UpdateAdmTemplatePayload
  "Updates a single `AdmUser` using its globally unique id and a patch."
  updateAdmUser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmUserInput!
  ): UpdateAdmUserPayload
  "Updates a single `AdmUser` using a unique key and a patch."
  updateAdmUserByIdAdmUser(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateAdmUserByIdAdmUserInput!
  ): UpdateAdmUserPayload
  "Updates a single `FlywaySchemaHistory` using its globally unique id and a patch."
  updateFlywaySchemaHistory(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateFlywaySchemaHistoryInput!
  ): UpdateFlywaySchemaHistoryPayload
  "Updates a single `FlywaySchemaHistory` using a unique key and a patch."
  updateFlywaySchemaHistoryByInstalledRank(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateFlywaySchemaHistoryByInstalledRankInput!
  ): UpdateFlywaySchemaHistoryPayload
  "Updates a single `Post` using its globally unique id and a patch."
  updatePost(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdatePostInput!
  ): UpdatePostPayload
  "Updates a single `Post` using a unique key and a patch."
  updatePostById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdatePostByIdInput!
  ): UpdatePostPayload
  "Updates a single `RefObject` using its globally unique id and a patch."
  updateRefObject(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefObjectInput!
  ): UpdateRefObjectPayload
  "Updates a single `RefObject` using a unique key and a patch."
  updateRefObjectByIdObject(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefObjectByIdObjectInput!
  ): UpdateRefObjectPayload
  "Updates a single `RefRelation` using its globally unique id and a patch."
  updateRefRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefRelationInput!
  ): UpdateRefRelationPayload
  "Updates a single `RefRelation` using a unique key and a patch."
  updateRefRelationByIdRelation(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefRelationByIdRelationInput!
  ): UpdateRefRelationPayload
  "Updates a single `RefStatus` using its globally unique id and a patch."
  updateRefStatus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefStatusInput!
  ): UpdateRefStatusPayload
  "Updates a single `RefStatus` using a unique key and a patch."
  updateRefStatusByIdStatus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefStatusByIdStatusInput!
  ): UpdateRefStatusPayload
  "Updates a single `RefUserType` using its globally unique id and a patch."
  updateRefUserType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefUserTypeInput!
  ): UpdateRefUserTypePayload
  "Updates a single `RefUserType` using a unique key and a patch."
  updateRefUserTypeByIdUserType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateRefUserTypeByIdUserTypeInput!
  ): UpdateRefUserTypePayload
  "Updates a single `SActivity` using its globally unique id and a patch."
  updateSActivity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSActivityInput!
  ): UpdateSActivityPayload
  "Updates a single `SActivity` using a unique key and a patch."
  updateSActivityById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSActivityByIdInput!
  ): UpdateSActivityPayload
  "Updates a single `SErr` using its globally unique id and a patch."
  updateSErr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSErrInput!
  ): UpdateSErrPayload
  "Updates a single `SErr` using a unique key and a patch."
  updateSErrById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSErrByIdInput!
  ): UpdateSErrPayload
  "Updates a single `SLog` using its globally unique id and a patch."
  updateSLog(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogInput!
  ): UpdateSLogPayload
  "Updates a single `SLog` using a unique key and a patch."
  updateSLogByIdLog(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogByIdLogInput!
  ): UpdateSLogPayload
  "Updates a single `SLogCode` using its globally unique id and a patch."
  updateSLogCode(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogCodeInput!
  ): UpdateSLogCodePayload
  "Updates a single `SLogCode` using a unique key and a patch."
  updateSLogCodeByIdCode(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogCodeByIdCodeInput!
  ): UpdateSLogCodePayload
  "Updates a single `SLogDetail` using its globally unique id and a patch."
  updateSLogDetail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogDetailInput!
  ): UpdateSLogDetailPayload
  "Updates a single `SLogDetail` using a unique key and a patch."
  updateSLogDetailByIdLogDetail(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSLogDetailByIdLogDetailInput!
  ): UpdateSLogDetailPayload
  "Updates a single `STable` using its globally unique id and a patch."
  updateSTable(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSTableInput!
  ): UpdateSTablePayload
  "Updates a single `STable` using a unique key and a patch."
  updateSTableById(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSTableByIdInput!
  ): UpdateSTablePayload
  "Updates a single `STableType` using its globally unique id and a patch."
  updateSTableType(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSTableTypeInput!
  ): UpdateSTableTypePayload
  "Updates a single `STableType` using a unique key and a patch."
  updateSTableTypeByIdTabletype(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateSTableTypeByIdTabletypeInput!
  ): UpdateSTableTypePayload
  "Updates a single `UsrCapacity` using its globally unique id and a patch."
  updateUsrCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrCapacityInput!
  ): UpdateUsrCapacityPayload
  "Updates a single `UsrCapacity` using a unique key and a patch."
  updateUsrCapacityByIdUsrCapacity(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrCapacityByIdUsrCapacityInput!
  ): UpdateUsrCapacityPayload
  "Updates a single `UsrDoc` using its globally unique id and a patch."
  updateUsrDoc(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrDocInput!
  ): UpdateUsrDocPayload
  "Updates a single `UsrDoc` using a unique key and a patch."
  updateUsrDocByIdUsrDoc(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrDocByIdUsrDocInput!
  ): UpdateUsrDocPayload
  "Updates a single `UsrDomain` using its globally unique id and a patch."
  updateUsrDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrDomainInput!
  ): UpdateUsrDomainPayload
  "Updates a single `UsrDomain` using a unique key and a patch."
  updateUsrDomainByIdUsrDomain(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrDomainByIdUsrDomainInput!
  ): UpdateUsrDomainPayload
  "Updates a single `UsrFocus` using its globally unique id and a patch."
  updateUsrFocus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrFocusInput!
  ): UpdateUsrFocusPayload
  "Updates a single `UsrFocus` using a unique key and a patch."
  updateUsrFocusByIdUsrFocus(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrFocusByIdUsrFocusInput!
  ): UpdateUsrFocusPayload
  "Updates a single `UsrNotify` using its globally unique id and a patch."
  updateUsrNotify(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrNotifyInput!
  ): UpdateUsrNotifyPayload
  "Updates a single `UsrNotify` using a unique key and a patch."
  updateUsrNotifyByIdNotify(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrNotifyByIdNotifyInput!
  ): UpdateUsrNotifyPayload
  "Updates a single `UsrPractice` using its globally unique id and a patch."
  updateUsrPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrPracticeInput!
  ): UpdateUsrPracticePayload
  "Updates a single `UsrPractice` using a unique key and a patch."
  updateUsrPracticeByIdUsrPractice(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrPracticeByIdUsrPracticeInput!
  ): UpdateUsrPracticePayload
  "Updates a single `UsrRelationship` using its globally unique id and a patch."
  updateUsrRelationship(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrRelationshipInput!
  ): UpdateUsrRelationshipPayload
  "Updates a single `UsrRelationship` using a unique key and a patch."
  updateUsrRelationshipByIdUsrRelationship(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrRelationshipByIdUsrRelationshipInput!
  ): UpdateUsrRelationshipPayload
  "Updates a single `UsrStr` using its globally unique id and a patch."
  updateUsrStr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrStrInput!
  ): UpdateUsrStrPayload
  "Updates a single `UsrStr` using a unique key and a patch."
  updateUsrStrByIdUsrStr(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateUsrStrByIdUsrStrInput!
  ): UpdateUsrStrPayload
  "Updates a single `VwDistrict` using its globally unique id and a patch."
  updateVwDistrict(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateVwDistrictInput!
  ): UpdateVwDistrictPayload
  "Updates a single `VwDistrict` using a unique key and a patch."
  updateVwDistrictByIdDistrictNces(
    "The exclusive input argument for this mutation. An object type, make sure to see documentation for this objects fields."
    input: UpdateVwDistrictByIdDistrictNcesInput!
  ): UpdateVwDistrictPayload
}

"The output of our `nextreviewer` mutation."
type NextreviewerPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `nextreviewuser` mutation."
type NextreviewuserPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: Cursor
  "When paginating forwards, are there more items?"
  hasNextPage: Boolean!
  "When paginating backwards, are there more items?"
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: Cursor
}

type Post implements Node {
  id: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  title: String
  userId: Int!
}

"A connection to a list of `Post` values."
type PostsConnection {
  "A list of edges which contains the `Post` and cursor to aid in pagination."
  edges: [PostsEdge!]!
  "A list of `Post` objects."
  nodes: [Post]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `Post` you could get from the connection."
  totalCount: Int!
}

"A `Post` edge in the connection."
type PostsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `Post` at the end of the edge."
  node: Post
}

"The root query type which gives access points into the data universe."
type Query implements Node {
  "Reads a single `AdmAccess` using its globally unique `ID`."
  admAccess(
    "The globally unique `ID` to be used in selecting a single `AdmAccess`."
    nodeId: ID!
  ): AdmAccess
  admAccessByIdAdmAccess(idAdmAccess: Int!): AdmAccess
  "Reads a single `AdmApp` using its globally unique `ID`."
  admApp(
    "The globally unique `ID` to be used in selecting a single `AdmApp`."
    nodeId: ID!
  ): AdmApp
  admAppByIdAdmApp(idAdmApp: Int!): AdmApp
  "Reads a single `AdmCapacity` using its globally unique `ID`."
  admCapacity(
    "The globally unique `ID` to be used in selecting a single `AdmCapacity`."
    nodeId: ID!
  ): AdmCapacity
  admCapacityByIdAdmCapacity(idAdmCapacity: Int!): AdmCapacity
  admCapacityByIdAdmCapacityAndIdAdmDomain(idAdmCapacity: Int!, idAdmDomain: Int!): AdmCapacity
  "Reads a single `AdmDefaultTemplate` using its globally unique `ID`."
  admDefaultTemplate(
    "The globally unique `ID` to be used in selecting a single `AdmDefaultTemplate`."
    nodeId: ID!
  ): AdmDefaultTemplate
  admDefaultTemplateByIdAdmDefaultNt(idAdmDefaultNt: Int!): AdmDefaultTemplate
  "Reads a single `AdmDistrikt` using its globally unique `ID`."
  admDistrikt(
    "The globally unique `ID` to be used in selecting a single `AdmDistrikt`."
    nodeId: ID!
  ): AdmDistrikt
  admDistriktByIdDistrictNces(idDistrictNces: Int!): AdmDistrikt
  "Reads a single `AdmDocCategory` using its globally unique `ID`."
  admDocCategory(
    "The globally unique `ID` to be used in selecting a single `AdmDocCategory`."
    nodeId: ID!
  ): AdmDocCategory
  admDocCategoryByIdAdmDocCategory(idAdmDocCategory: Int!): AdmDocCategory
  "Reads a single `AdmDocSuggest` using its globally unique `ID`."
  admDocSuggest(
    "The globally unique `ID` to be used in selecting a single `AdmDocSuggest`."
    nodeId: ID!
  ): AdmDocSuggest
  admDocSuggestByIdAdmDocSuggest(idAdmDocSuggest: Int!): AdmDocSuggest
  "Reads a single `AdmDomain` using its globally unique `ID`."
  admDomain(
    "The globally unique `ID` to be used in selecting a single `AdmDomain`."
    nodeId: ID!
  ): AdmDomain
  admDomainByIdAdmDomain(idAdmDomain: Int!): AdmDomain
  admDomainByIdAdmDomainAndIdAdmFramework(idAdmDomain: Int!, idAdmFramework: Int!): AdmDomain
  "Reads a single `AdmEngagement` using its globally unique `ID`."
  admEngagement(
    "The globally unique `ID` to be used in selecting a single `AdmEngagement`."
    nodeId: ID!
  ): AdmEngagement
  admEngagementByIdAdmEngagement(idAdmEngagement: Int!): AdmEngagement
  "Reads a single `AdmFramework` using its globally unique `ID`."
  admFramework(
    "The globally unique `ID` to be used in selecting a single `AdmFramework`."
    nodeId: ID!
  ): AdmFramework
  admFrameworkByIdAdmFramework(idAdmFramework: Int!): AdmFramework
  "Reads a single `AdmNarrative` using its globally unique `ID`."
  admNarrative(
    "The globally unique `ID` to be used in selecting a single `AdmNarrative`."
    nodeId: ID!
  ): AdmNarrative
  admNarrativeByIdAdmNarrative(idAdmNarrative: Int!): AdmNarrative
  "Reads a single `AdmPeriod` using its globally unique `ID`."
  admPeriod(
    "The globally unique `ID` to be used in selecting a single `AdmPeriod`."
    nodeId: ID!
  ): AdmPeriod
  admPeriodByIdAdmPeriod(idAdmPeriod: Int!): AdmPeriod
  "Reads a single `AdmPractice` using its globally unique `ID`."
  admPractice(
    "The globally unique `ID` to be used in selecting a single `AdmPractice`."
    nodeId: ID!
  ): AdmPractice
  admPracticeByIdAdmPractice(idAdmPractice: Int!): AdmPractice
  "Reads a single `AdmRubric` using its globally unique `ID`."
  admRubric(
    "The globally unique `ID` to be used in selecting a single `AdmRubric`."
    nodeId: ID!
  ): AdmRubric
  admRubricByIdAdmRubric(idAdmRubric: Int!): AdmRubric
  "Reads a single `AdmRubricMap` using its globally unique `ID`."
  admRubricMap(
    "The globally unique `ID` to be used in selecting a single `AdmRubricMap`."
    nodeId: ID!
  ): AdmRubricMap
  admRubricMapByIdAdmRubricMap(idAdmRubricMap: Int!): AdmRubricMap
  "Reads a single `AdmScale` using its globally unique `ID`."
  admScale(
    "The globally unique `ID` to be used in selecting a single `AdmScale`."
    nodeId: ID!
  ): AdmScale
  admScaleByIdAdmScale(idAdmScale: Int!): AdmScale
  "Reads a single `AdmScore` using its globally unique `ID`."
  admScore(
    "The globally unique `ID` to be used in selecting a single `AdmScore`."
    nodeId: ID!
  ): AdmScore
  admScoreByIdAdmScore(idAdmScore: Int!): AdmScore
  "Reads a single `AdmSkool` using its globally unique `ID`."
  admSkool(
    "The globally unique `ID` to be used in selecting a single `AdmSkool`."
    nodeId: ID!
  ): AdmSkool
  admSkoolByIdSchoolNces(idSchoolNces: BigInt!): AdmSkool
  "Reads a single `AdmStrSequence` using its globally unique `ID`."
  admStrSequence(
    "The globally unique `ID` to be used in selecting a single `AdmStrSequence`."
    nodeId: ID!
  ): AdmStrSequence
  admStrSequenceByIdAdmStrSequence(idAdmStrSequence: Int!): AdmStrSequence
  "Reads a single `AdmStrType` using its globally unique `ID`."
  admStrType(
    "The globally unique `ID` to be used in selecting a single `AdmStrType`."
    nodeId: ID!
  ): AdmStrType
  admStrTypeByIdAdmStrType(idAdmStrType: Int!): AdmStrType
  "Reads a single `AdmStrTypeMap` using its globally unique `ID`."
  admStrTypeMap(
    "The globally unique `ID` to be used in selecting a single `AdmStrTypeMap`."
    nodeId: ID!
  ): AdmStrTypeMap
  admStrTypeMapByIdAdmStrTypeMap(idAdmStrTypeMap: Int!): AdmStrTypeMap
  "Reads a single `AdmTemplate` using its globally unique `ID`."
  admTemplate(
    "The globally unique `ID` to be used in selecting a single `AdmTemplate`."
    nodeId: ID!
  ): AdmTemplate
  admTemplateByIdTemplate(idTemplate: Int!): AdmTemplate
  "Reads a single `AdmUser` using its globally unique `ID`."
  admUser(
    "The globally unique `ID` to be used in selecting a single `AdmUser`."
    nodeId: ID!
  ): AdmUser
  admUserByIdAdmUser(idAdmUser: Int!): AdmUser
  "Reads and enables pagination through a set of `AdmAccess`."
  allAdmAccesses(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesConnection
  "Reads a set of `AdmAccess`."
  allAdmAccessesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!]
  ): [AdmAccess!]
  "Reads and enables pagination through a set of `AdmApp`."
  allAdmApps(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAppCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmApp`."
    orderBy: [AdmAppsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAppsConnection
  "Reads a set of `AdmApp`."
  allAdmAppsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAppCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmApp`."
    orderBy: [AdmAppsOrderBy!]
  ): [AdmApp!]
  "Reads and enables pagination through a set of `AdmCapacity`."
  allAdmCapacities(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmCapacitiesConnection
  "Reads a set of `AdmCapacity`."
  allAdmCapacitiesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!]
  ): [AdmCapacity!]
  "Reads and enables pagination through a set of `AdmDefaultTemplate`."
  allAdmDefaultTemplates(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesConnection
  "Reads a set of `AdmDefaultTemplate`."
  allAdmDefaultTemplatesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!]
  ): [AdmDefaultTemplate!]
  "Reads and enables pagination through a set of `AdmDistrikt`."
  allAdmDistrikts(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDistriktCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDistriktsConnection
  "Reads a set of `AdmDistrikt`."
  allAdmDistriktsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDistriktCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!]
  ): [AdmDistrikt!]
  "Reads and enables pagination through a set of `AdmDocCategory`."
  allAdmDocCategories(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesConnection
  "Reads a set of `AdmDocCategory`."
  allAdmDocCategoriesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocCategoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!]
  ): [AdmDocCategory!]
  "Reads and enables pagination through a set of `AdmDocSuggest`."
  allAdmDocSuggests(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsConnection
  "Reads a set of `AdmDocSuggest`."
  allAdmDocSuggestsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDocSuggestCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!]
  ): [AdmDocSuggest!]
  "Reads and enables pagination through a set of `AdmDomain`."
  allAdmDomains(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDomainsConnection
  "Reads a set of `AdmDomain`."
  allAdmDomainsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!]
  ): [AdmDomain!]
  "Reads and enables pagination through a set of `AdmEngagement`."
  allAdmEngagements(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmEngagementCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmEngagementsConnection
  "Reads a set of `AdmEngagement`."
  allAdmEngagementsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmEngagementCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!]
  ): [AdmEngagement!]
  "Reads and enables pagination through a set of `AdmFramework`."
  allAdmFrameworks(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksConnection
  "Reads a set of `AdmFramework`."
  allAdmFrameworksList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!]
  ): [AdmFramework!]
  "Reads and enables pagination through a set of `AdmNarrative`."
  allAdmNarratives(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesConnection
  "Reads a set of `AdmNarrative`."
  allAdmNarrativesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmNarrativeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!]
  ): [AdmNarrative!]
  "Reads and enables pagination through a set of `AdmPeriod`."
  allAdmPeriods(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsConnection
  "Reads a set of `AdmPeriod`."
  allAdmPeriodsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!]
  ): [AdmPeriod!]
  "Reads and enables pagination through a set of `AdmPractice`."
  allAdmPractices(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesConnection
  "Reads a set of `AdmPractice`."
  allAdmPracticesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!]
  ): [AdmPractice!]
  "Reads and enables pagination through a set of `AdmRubricMap`."
  allAdmRubricMaps(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsConnection
  "Reads a set of `AdmRubricMap`."
  allAdmRubricMapsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!]
  ): [AdmRubricMap!]
  "Reads and enables pagination through a set of `AdmRubric`."
  allAdmRubrics(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricsConnection
  "Reads a set of `AdmRubric`."
  allAdmRubricsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!]
  ): [AdmRubric!]
  "Reads and enables pagination through a set of `AdmScale`."
  allAdmScales(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScaleCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmScale`."
    orderBy: [AdmScalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScalesConnection
  "Reads a set of `AdmScale`."
  allAdmScalesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScaleCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmScale`."
    orderBy: [AdmScalesOrderBy!]
  ): [AdmScale!]
  "Reads and enables pagination through a set of `AdmScore`."
  allAdmScores(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScoresConnection
  "Reads a set of `AdmScore`."
  allAdmScoresList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!]
  ): [AdmScore!]
  "Reads and enables pagination through a set of `AdmSkool`."
  allAdmSkools(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsConnection
  "Reads a set of `AdmSkool`."
  allAdmSkoolsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmSkoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!]
  ): [AdmSkool!]
  "Reads and enables pagination through a set of `AdmStrSequence`."
  allAdmStrSequences(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrSequenceCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrSequence`."
    orderBy: [AdmStrSequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrSequencesConnection
  "Reads a set of `AdmStrSequence`."
  allAdmStrSequencesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrSequenceCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrSequence`."
    orderBy: [AdmStrSequencesOrderBy!]
  ): [AdmStrSequence!]
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  allAdmStrTypeMaps(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsConnection
  "Reads a set of `AdmStrTypeMap`."
  allAdmStrTypeMapsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!]
  ): [AdmStrTypeMap!]
  "Reads and enables pagination through a set of `AdmStrType`."
  allAdmStrTypes(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesConnection
  "Reads a set of `AdmStrType`."
  allAdmStrTypesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!]
  ): [AdmStrType!]
  "Reads and enables pagination through a set of `AdmTemplate`."
  allAdmTemplates(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmTemplatesConnection
  "Reads a set of `AdmTemplate`."
  allAdmTemplatesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!]
  ): [AdmTemplate!]
  "Reads and enables pagination through a set of `AdmUser`."
  allAdmUsers(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmUsersConnection
  "Reads a set of `AdmUser`."
  allAdmUsersList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!]
  ): [AdmUser!]
  "Reads and enables pagination through a set of `FlywaySchemaHistory`."
  allFlywaySchemaHistories(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: FlywaySchemaHistoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `FlywaySchemaHistory`."
    orderBy: [FlywaySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlywaySchemaHistoriesConnection
  "Reads a set of `FlywaySchemaHistory`."
  allFlywaySchemaHistoriesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: FlywaySchemaHistoryCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `FlywaySchemaHistory`."
    orderBy: [FlywaySchemaHistoriesOrderBy!]
  ): [FlywaySchemaHistory!]
  "Reads and enables pagination through a set of `Post`."
  allPosts(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: PostCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `Post`."
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostsConnection
  "Reads a set of `Post`."
  allPostsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: PostCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `Post`."
    orderBy: [PostsOrderBy!]
  ): [Post!]
  "Reads and enables pagination through a set of `RefObject`."
  allRefObjects(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefObjectCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `RefObject`."
    orderBy: [RefObjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefObjectsConnection
  "Reads a set of `RefObject`."
  allRefObjectsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefObjectCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `RefObject`."
    orderBy: [RefObjectsOrderBy!]
  ): [RefObject!]
  "Reads and enables pagination through a set of `RefRelation`."
  allRefRelations(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefRelationCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRelationsConnection
  "Reads a set of `RefRelation`."
  allRefRelationsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefRelationCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!]
  ): [RefRelation!]
  "Reads and enables pagination through a set of `RefStatus`."
  allRefStatuses(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefStatusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `RefStatus`."
    orderBy: [RefStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefStatusesConnection
  "Reads a set of `RefStatus`."
  allRefStatusesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefStatusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `RefStatus`."
    orderBy: [RefStatusesOrderBy!]
  ): [RefStatus!]
  "Reads and enables pagination through a set of `RefUserType`."
  allRefUserTypes(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefUserTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `RefUserType`."
    orderBy: [RefUserTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefUserTypesConnection
  "Reads a set of `RefUserType`."
  allRefUserTypesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: RefUserTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `RefUserType`."
    orderBy: [RefUserTypesOrderBy!]
  ): [RefUserType!]
  "Reads and enables pagination through a set of `SActivity`."
  allSActivities(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: SActivityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `SActivity`."
    orderBy: [SActivitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SActivitiesConnection
  "Reads a set of `SActivity`."
  allSActivitiesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: SActivityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `SActivity`."
    orderBy: [SActivitiesOrderBy!]
  ): [SActivity!]
  "Reads and enables pagination through a set of `SErr`."
  allSErrs(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: SErrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `SErr`."
    orderBy: [SErrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SErrsConnection
  "Reads a set of `SErr`."
  allSErrsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: SErrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `SErr`."
    orderBy: [SErrsOrderBy!]
  ): [SErr!]
  "Reads and enables pagination through a set of `SLogCode`."
  allSLogCodes(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogCodeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `SLogCode`."
    orderBy: [SLogCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogCodesConnection
  "Reads a set of `SLogCode`."
  allSLogCodesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogCodeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `SLogCode`."
    orderBy: [SLogCodesOrderBy!]
  ): [SLogCode!]
  "Reads and enables pagination through a set of `SLogDetail`."
  allSLogDetails(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogDetailCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `SLogDetail`."
    orderBy: [SLogDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogDetailsConnection
  "Reads a set of `SLogDetail`."
  allSLogDetailsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogDetailCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `SLogDetail`."
    orderBy: [SLogDetailsOrderBy!]
  ): [SLogDetail!]
  "Reads and enables pagination through a set of `SLog`."
  allSLogs(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `SLog`."
    orderBy: [SLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogsConnection
  "Reads a set of `SLog`."
  allSLogsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: SLogCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `SLog`."
    orderBy: [SLogsOrderBy!]
  ): [SLog!]
  "Reads and enables pagination through a set of `STableType`."
  allSTableTypes(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: STableTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `STableType`."
    orderBy: [STableTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STableTypesConnection
  "Reads a set of `STableType`."
  allSTableTypesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: STableTypeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `STableType`."
    orderBy: [STableTypesOrderBy!]
  ): [STableType!]
  "Reads and enables pagination through a set of `STable`."
  allSTables(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: STableCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `STable`."
    orderBy: [STablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STablesConnection
  "Reads a set of `STable`."
  allSTablesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: STableCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `STable`."
    orderBy: [STablesOrderBy!]
  ): [STable!]
  "Reads and enables pagination through a set of `UsrCapacity`."
  allUsrCapacities(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesConnection
  "Reads a set of `UsrCapacity`."
  allUsrCapacitiesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!]
  ): [UsrCapacity!]
  "Reads and enables pagination through a set of `UsrDoc`."
  allUsrDocs(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsConnection
  "Reads a set of `UsrDoc`."
  allUsrDocsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!]
  ): [UsrDoc!]
  "Reads and enables pagination through a set of `UsrDomain`."
  allUsrDomains(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsConnection
  "Reads a set of `UsrDomain`."
  allUsrDomainsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!]
  ): [UsrDomain!]
  "Reads and enables pagination through a set of `UsrFocus`."
  allUsrFoci(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociConnection
  "Reads a set of `UsrFocus`."
  allUsrFociList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrFocusCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!]
  ): [UsrFocus!]
  "Reads and enables pagination through a set of `UsrNotify`."
  allUsrNotifies(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesConnection
  "Reads a set of `UsrNotify`."
  allUsrNotifiesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrNotifyCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!]
  ): [UsrNotify!]
  "Reads and enables pagination through a set of `UsrPractice`."
  allUsrPractices(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesConnection
  "Reads a set of `UsrPractice`."
  allUsrPracticesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!]
  ): [UsrPractice!]
  "Reads and enables pagination through a set of `UsrRelationship`."
  allUsrRelationships(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsConnection
  "Reads a set of `UsrRelationship`."
  allUsrRelationshipsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!]
  ): [UsrRelationship!]
  "Reads and enables pagination through a set of `UsrStr`."
  allUsrStrs(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection
  "Reads a set of `UsrStr`."
  allUsrStrsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]
  "Reads and enables pagination through a set of `_VwAdmCapacityFramework`."
  allVwAdmCapacityFrameworks(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmCapacityFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwAdmCapacityFramework`."
    orderBy: [_VwAdmCapacityFrameworksOrderBy!] = [NATURAL]
  ): _VwAdmCapacityFrameworksConnection
  "Reads a set of `_VwAdmCapacityFramework`."
  allVwAdmCapacityFrameworksList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmCapacityFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwAdmCapacityFramework`."
    orderBy: [_VwAdmCapacityFrameworksOrderBy!]
  ): [_VwAdmCapacityFramework!]
  "Reads and enables pagination through a set of `_VwAdmCapacityRubric`."
  allVwAdmCapacityRubrics(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmCapacityRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwAdmCapacityRubric`."
    orderBy: [_VwAdmCapacityRubricsOrderBy!] = [NATURAL]
  ): _VwAdmCapacityRubricsConnection
  "Reads a set of `_VwAdmCapacityRubric`."
  allVwAdmCapacityRubricsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmCapacityRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwAdmCapacityRubric`."
    orderBy: [_VwAdmCapacityRubricsOrderBy!]
  ): [_VwAdmCapacityRubric!]
  "Reads and enables pagination through a set of `_VwAdmPracticeFramework`."
  allVwAdmPracticeFrameworks(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeFramework`."
    orderBy: [_VwAdmPracticeFrameworksOrderBy!] = [NATURAL]
  ): _VwAdmPracticeFrameworksConnection
  "Reads a set of `_VwAdmPracticeFramework`."
  allVwAdmPracticeFrameworksList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeFrameworkCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeFramework`."
    orderBy: [_VwAdmPracticeFrameworksOrderBy!]
  ): [_VwAdmPracticeFramework!]
  "Reads and enables pagination through a set of `_VwAdmPracticeFull`."
  allVwAdmPracticeFulls(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeFullCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeFull`."
    orderBy: [_VwAdmPracticeFullsOrderBy!] = [NATURAL]
  ): _VwAdmPracticeFullsConnection
  "Reads a set of `_VwAdmPracticeFull`."
  allVwAdmPracticeFullsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeFullCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeFull`."
    orderBy: [_VwAdmPracticeFullsOrderBy!]
  ): [_VwAdmPracticeFull!]
  "Reads and enables pagination through a set of `_VwAdmPracticeRubric`."
  allVwAdmPracticeRubrics(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeRubric`."
    orderBy: [_VwAdmPracticeRubricsOrderBy!] = [NATURAL]
  ): _VwAdmPracticeRubricsConnection
  "Reads a set of `_VwAdmPracticeRubric`."
  allVwAdmPracticeRubricsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwAdmPracticeRubricCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwAdmPracticeRubric`."
    orderBy: [_VwAdmPracticeRubricsOrderBy!]
  ): [_VwAdmPracticeRubric!]
  "Reads and enables pagination through a set of `VwCapacity`."
  allVwCapacities(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwCapacity`."
    orderBy: [VwCapacitiesOrderBy!] = [NATURAL]
  ): VwCapacitiesConnection
  "Reads a set of `VwCapacity`."
  allVwCapacitiesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwCapacity`."
    orderBy: [VwCapacitiesOrderBy!]
  ): [VwCapacity!]
  "Reads and enables pagination through a set of `_VwCapacityScore`."
  allVwCapacityScores(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwCapacityScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwCapacityScore`."
    orderBy: [_VwCapacityScoresOrderBy!] = [NATURAL]
  ): _VwCapacityScoresConnection
  "Reads a set of `_VwCapacityScore`."
  allVwCapacityScoresList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwCapacityScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwCapacityScore`."
    orderBy: [_VwCapacityScoresOrderBy!]
  ): [_VwCapacityScore!]
  "Reads and enables pagination through a set of `VwDefaultTemplate`."
  allVwDefaultTemplates(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDefaultTemplate`."
    orderBy: [VwDefaultTemplatesOrderBy!] = [NATURAL]
  ): VwDefaultTemplatesConnection
  "Reads a set of `VwDefaultTemplate`."
  allVwDefaultTemplatesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDefaultTemplateCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDefaultTemplate`."
    orderBy: [VwDefaultTemplatesOrderBy!]
  ): [VwDefaultTemplate!]
  "Reads and enables pagination through a set of `VwDistrict`."
  allVwDistricts(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDistrictCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDistrict`."
    orderBy: [VwDistrictsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDistrictsConnection
  "Reads a set of `VwDistrict`."
  allVwDistrictsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDistrictCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDistrict`."
    orderBy: [VwDistrictsOrderBy!]
  ): [VwDistrict!]
  "Reads and enables pagination through a set of `VwDoc`."
  allVwDocs(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDocsConnection
  "Reads a set of `VwDoc`."
  allVwDocsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!]
  ): [VwDoc!]
  "Reads and enables pagination through a set of `_VwDomainScore`."
  allVwDomainScores(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwDomainScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwDomainScore`."
    orderBy: [_VwDomainScoresOrderBy!] = [NATURAL]
  ): _VwDomainScoresConnection
  "Reads a set of `_VwDomainScore`."
  allVwDomainScoresList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwDomainScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwDomainScore`."
    orderBy: [_VwDomainScoresOrderBy!]
  ): [_VwDomainScore!]
  "Reads and enables pagination through a set of `VwDomain`."
  allVwDomains(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDomain`."
    orderBy: [VwDomainsOrderBy!] = [NATURAL]
  ): VwDomainsConnection
  "Reads a set of `VwDomain`."
  allVwDomainsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDomain`."
    orderBy: [VwDomainsOrderBy!]
  ): [VwDomain!]
  "Reads and enables pagination through a set of `VwEngagementPeriod`."
  allVwEngagementPeriods(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwEngagementPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwEngagementPeriod`."
    orderBy: [VwEngagementPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwEngagementPeriodsConnection
  "Reads a set of `VwEngagementPeriod`."
  allVwEngagementPeriodsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwEngagementPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwEngagementPeriod`."
    orderBy: [VwEngagementPeriodsOrderBy!]
  ): [VwEngagementPeriod!]
  "Reads and enables pagination through a set of `VwPractice`."
  allVwPractices(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwPractice`."
    orderBy: [VwPracticesOrderBy!] = [NATURAL]
  ): VwPracticesConnection
  "Reads a set of `VwPractice`."
  allVwPracticesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwPractice`."
    orderBy: [VwPracticesOrderBy!]
  ): [VwPractice!]
  "Reads and enables pagination through a set of `VwRelationship`."
  allVwRelationships(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwRelationship`."
    orderBy: [VwRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwRelationshipsConnection
  "Reads a set of `VwRelationship`."
  allVwRelationshipsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwRelationship`."
    orderBy: [VwRelationshipsOrderBy!]
  ): [VwRelationship!]
  "Reads and enables pagination through a set of `VwReview`."
  allVwReviews(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwReviewCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwReview`."
    orderBy: [VwReviewsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwReviewsConnection
  "Reads a set of `VwReview`."
  allVwReviewsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwReviewCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwReview`."
    orderBy: [VwReviewsOrderBy!]
  ): [VwReview!]
  "Reads and enables pagination through a set of `VwSchema`."
  allVwSchemas(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchemaCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwSchema`."
    orderBy: [VwSchemasOrderBy!] = [NATURAL]
  ): VwSchemasConnection
  "Reads a set of `VwSchema`."
  allVwSchemasList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchemaCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwSchema`."
    orderBy: [VwSchemasOrderBy!]
  ): [VwSchema!]
  "Reads and enables pagination through a set of `VwSchool`."
  allVwSchools(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwSchool`."
    orderBy: [VwSchoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwSchoolsConnection
  "Reads a set of `VwSchool`."
  allVwSchoolsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwSchool`."
    orderBy: [VwSchoolsOrderBy!]
  ): [VwSchool!]
  "Reads and enables pagination through a set of `VwSeason`."
  allVwSeasons(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSeasonCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwSeason`."
    orderBy: [VwSeasonsOrderBy!] = [NATURAL]
  ): VwSeasonsConnection
  "Reads a set of `VwSeason`."
  allVwSeasonsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSeasonCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwSeason`."
    orderBy: [VwSeasonsOrderBy!]
  ): [VwSeason!]
  "Reads and enables pagination through a set of `_VwStrScore`."
  allVwStrScores(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwStrScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `_VwStrScore`."
    orderBy: [_VwStrScoresOrderBy!] = [NATURAL]
  ): _VwStrScoresConnection
  "Reads a set of `_VwStrScore`."
  allVwStrScoresList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: _VwStrScoreCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `_VwStrScore`."
    orderBy: [_VwStrScoresOrderBy!]
  ): [_VwStrScore!]
  "Reads and enables pagination through a set of `VwTestApp`."
  allVwTestApps(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwTestAppCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwTestApp`."
    orderBy: [VwTestAppsOrderBy!] = [NATURAL]
  ): VwTestAppsConnection
  "Reads a set of `VwTestApp`."
  allVwTestAppsList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwTestAppCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwTestApp`."
    orderBy: [VwTestAppsOrderBy!]
  ): [VwTestApp!]
  "Reads and enables pagination through a set of `VwUser`."
  allVwUsers(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwUser`."
    orderBy: [VwUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwUsersConnection
  "Reads a set of `VwUser`."
  allVwUsersList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwUserCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwUser`."
    orderBy: [VwUsersOrderBy!]
  ): [VwUser!]
  "Reads and enables pagination through a set of `VwReview`."
  calibrationGetSequence(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "Only read the first `n` values of the set."
    first: Int,
    idcalibration: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): VwReviewsConnection
  "Reads and enables pagination through a set of `VwReview`."
  calibrationGetSequenceList(
    "Only read the first `n` values of the set."
    first: Int,
    idcalibration: Int,
    "Skip the first `n` values."
    offset: Int
  ): [VwReview]
  currentUserId: Int
  currentWhatever: String
  "Reads a single `FlywaySchemaHistory` using its globally unique `ID`."
  flywaySchemaHistory(
    "The globally unique `ID` to be used in selecting a single `FlywaySchemaHistory`."
    nodeId: ID!
  ): FlywaySchemaHistory
  flywaySchemaHistoryByInstalledRank(installedRank: Int!): FlywaySchemaHistory
  getaschoolyear(adate: Date): Int
  getschoolyear(adate: Date): String
  getschoolyearending(adate: Date): Int
  getuidstr(idschoolnces: BigInt, season: String): String
  "Fetches an object given its globally unique `ID`."
  node(
    "The globally unique `ID`."
    nodeId: ID!
  ): Node
  "The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`."
  nodeId: ID!
  "Reads a single `Post` using its globally unique `ID`."
  post(
    "The globally unique `ID` to be used in selecting a single `Post`."
    nodeId: ID!
  ): Post
  postById(id: Int!): Post
  """

  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!
  "Reads a single `RefObject` using its globally unique `ID`."
  refObject(
    "The globally unique `ID` to be used in selecting a single `RefObject`."
    nodeId: ID!
  ): RefObject
  refObjectByIdObject(idObject: Int!): RefObject
  "Reads a single `RefRelation` using its globally unique `ID`."
  refRelation(
    "The globally unique `ID` to be used in selecting a single `RefRelation`."
    nodeId: ID!
  ): RefRelation
  refRelationByIdRelation(idRelation: Int!): RefRelation
  "Reads a single `RefStatus` using its globally unique `ID`."
  refStatus(
    "The globally unique `ID` to be used in selecting a single `RefStatus`."
    nodeId: ID!
  ): RefStatus
  refStatusByIdStatus(idStatus: Int!): RefStatus
  "Reads a single `RefUserType` using its globally unique `ID`."
  refUserType(
    "The globally unique `ID` to be used in selecting a single `RefUserType`."
    nodeId: ID!
  ): RefUserType
  refUserTypeByIdUserType(idUserType: Int!): RefUserType
  "Reads and enables pagination through a set of `VwReview`."
  reviewGetSequence(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "Only read the first `n` values of the set."
    first: Int,
    id: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): VwReviewsConnection
  "Reads and enables pagination through a set of `VwReview`."
  reviewGetSequenceList(
    "Only read the first `n` values of the set."
    first: Int,
    id: Int,
    "Skip the first `n` values."
    offset: Int
  ): [VwReview]
  "Reads and enables pagination through a set of `VwReview`."
  reviewsSince(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    earliest: Date,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): VwReviewsConnection
  "Reads and enables pagination through a set of `VwReview`."
  reviewsSinceList(
    earliest: Date,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int
  ): [VwReview]
  "Reads a single `SActivity` using its globally unique `ID`."
  sActivity(
    "The globally unique `ID` to be used in selecting a single `SActivity`."
    nodeId: ID!
  ): SActivity
  sActivityById(id: Int!): SActivity
  "Reads a single `SErr` using its globally unique `ID`."
  sErr(
    "The globally unique `ID` to be used in selecting a single `SErr`."
    nodeId: ID!
  ): SErr
  sErrById(id: Int!): SErr
  "Reads a single `SLog` using its globally unique `ID`."
  sLog(
    "The globally unique `ID` to be used in selecting a single `SLog`."
    nodeId: ID!
  ): SLog
  sLogByIdLog(idLog: Int!): SLog
  "Reads a single `SLogCode` using its globally unique `ID`."
  sLogCode(
    "The globally unique `ID` to be used in selecting a single `SLogCode`."
    nodeId: ID!
  ): SLogCode
  sLogCodeByIdCode(idCode: Int!): SLogCode
  "Reads a single `SLogDetail` using its globally unique `ID`."
  sLogDetail(
    "The globally unique `ID` to be used in selecting a single `SLogDetail`."
    nodeId: ID!
  ): SLogDetail
  sLogDetailByIdLogDetail(idLogDetail: Int!): SLogDetail
  "Reads a single `STable` using its globally unique `ID`."
  sTable(
    "The globally unique `ID` to be used in selecting a single `STable`."
    nodeId: ID!
  ): STable
  sTableById(id: Int!): STable
  "Reads a single `STableType` using its globally unique `ID`."
  sTableType(
    "The globally unique `ID` to be used in selecting a single `STableType`."
    nodeId: ID!
  ): STableType
  sTableTypeByIdTabletype(idTabletype: Int!): STableType
  "Reads a single `UsrCapacity` using its globally unique `ID`."
  usrCapacity(
    "The globally unique `ID` to be used in selecting a single `UsrCapacity`."
    nodeId: ID!
  ): UsrCapacity
  usrCapacityByIdUsrCapacity(idUsrCapacity: Int!): UsrCapacity
  "Reads a single `UsrDoc` using its globally unique `ID`."
  usrDoc(
    "The globally unique `ID` to be used in selecting a single `UsrDoc`."
    nodeId: ID!
  ): UsrDoc
  usrDocByIdUsrDoc(idUsrDoc: Int!): UsrDoc
  "Reads a single `UsrDomain` using its globally unique `ID`."
  usrDomain(
    "The globally unique `ID` to be used in selecting a single `UsrDomain`."
    nodeId: ID!
  ): UsrDomain
  usrDomainByIdUsrDomain(idUsrDomain: Int!): UsrDomain
  "Reads a single `UsrFocus` using its globally unique `ID`."
  usrFocus(
    "The globally unique `ID` to be used in selecting a single `UsrFocus`."
    nodeId: ID!
  ): UsrFocus
  usrFocusByIdUsrFocus(idUsrFocus: Int!): UsrFocus
  "Reads a single `UsrNotify` using its globally unique `ID`."
  usrNotify(
    "The globally unique `ID` to be used in selecting a single `UsrNotify`."
    nodeId: ID!
  ): UsrNotify
  usrNotifyByIdNotify(idNotify: Int!): UsrNotify
  "Reads a single `UsrPractice` using its globally unique `ID`."
  usrPractice(
    "The globally unique `ID` to be used in selecting a single `UsrPractice`."
    nodeId: ID!
  ): UsrPractice
  usrPracticeByIdUsrPractice(idUsrPractice: Int!): UsrPractice
  "Reads a single `UsrRelationship` using its globally unique `ID`."
  usrRelationship(
    "The globally unique `ID` to be used in selecting a single `UsrRelationship`."
    nodeId: ID!
  ): UsrRelationship
  usrRelationshipByIdUsrRelationship(idUsrRelationship: Int!): UsrRelationship
  "Reads a single `UsrStr` using its globally unique `ID`."
  usrStr(
    "The globally unique `ID` to be used in selecting a single `UsrStr`."
    nodeId: ID!
  ): UsrStr
  usrStrByIdUsrStr(idUsrStr: Int!): UsrStr
  "Reads a single `VwDistrict` using its globally unique `ID`."
  vwDistrict(
    "The globally unique `ID` to be used in selecting a single `VwDistrict`."
    nodeId: ID!
  ): VwDistrict
  vwDistrictByIdDistrictNces(idDistrictNces: Int!): VwDistrict
  "Reads a single `VwDoc` using its globally unique `ID`."
  vwDoc(
    "The globally unique `ID` to be used in selecting a single `VwDoc`."
    nodeId: ID!
  ): VwDoc
  vwDocByIdUsrDoc(idUsrDoc: Int!): VwDoc
  "Reads a single `VwEngagementPeriod` using its globally unique `ID`."
  vwEngagementPeriod(
    "The globally unique `ID` to be used in selecting a single `VwEngagementPeriod`."
    nodeId: ID!
  ): VwEngagementPeriod
  vwEngagementPeriodBySchoolYearEndingAndIdSchoolNces(idSchoolNces: BigInt!, schoolYearEnding: Int!): VwEngagementPeriod
  "Reads a single `VwRelationship` using its globally unique `ID`."
  vwRelationship(
    "The globally unique `ID` to be used in selecting a single `VwRelationship`."
    nodeId: ID!
  ): VwRelationship
  vwRelationshipByIdUsrRelationship(idUsrRelationship: Int!): VwRelationship
  "Reads a single `VwReview` using its globally unique `ID`."
  vwReview(
    "The globally unique `ID` to be used in selecting a single `VwReview`."
    nodeId: ID!
  ): VwReview
  vwReviewByIdUsrStr(idUsrStr: Int!): VwReview
  "Reads a single `VwSchool` using its globally unique `ID`."
  vwSchool(
    "The globally unique `ID` to be used in selecting a single `VwSchool`."
    nodeId: ID!
  ): VwSchool
  vwSchoolByIdSchoolNces(idSchoolNces: BigInt!): VwSchool
  "Reads a single `VwUser` using its globally unique `ID`."
  vwUser(
    "The globally unique `ID` to be used in selecting a single `VwUser`."
    nodeId: ID!
  ): VwUser
  vwUserByIdAdmUserAndIdAdmApp(idAdmApp: Int!, idAdmUser: Int!): VwUser
}

"The output of our `readAllNotifies` mutation."
type ReadAllNotifiesPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

type RefObject implements Node {
  dependsOn: Int
  idObject: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  objectDescription: String
  objectName: String!
  sCreate: Datetime
  sUpdate: Datetime
}

"A connection to a list of `RefObject` values."
type RefObjectsConnection {
  "A list of edges which contains the `RefObject` and cursor to aid in pagination."
  edges: [RefObjectsEdge!]!
  "A list of `RefObject` objects."
  nodes: [RefObject]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RefObject` you could get from the connection."
  totalCount: Int!
}

"A `RefObject` edge in the connection."
type RefObjectsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RefObject` at the end of the edge."
  node: RefObject
}

type RefRelation implements Node {
  "Reads a single `AdmApp` that is related to this `RefRelation`."
  admAppByIdAdmApp: AdmApp
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdRelation(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsConnection!
  "Reads and enables pagination through a set of `AdmStrTypeMap`."
  admStrTypeMapsByIdRelationList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmStrTypeMapCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!]
  ): [AdmStrTypeMap!]!
  idAdmApp: Int
  idRelation: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  relationshipDescription: String
  relationshipName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdRelation(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsConnection!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdRelationList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!]
  ): [UsrRelationship!]!
}

"A connection to a list of `RefRelation` values."
type RefRelationsConnection {
  "A list of edges which contains the `RefRelation` and cursor to aid in pagination."
  edges: [RefRelationsEdge!]!
  "A list of `RefRelation` objects."
  nodes: [RefRelation]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RefRelation` you could get from the connection."
  totalCount: Int!
}

"A `RefRelation` edge in the connection."
type RefRelationsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RefRelation` at the end of the edge."
  node: RefRelation
}

type RefStatus implements Node {
  displayOrder: Int
  icon: String
  idStatus: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sUpdate: Datetime
  state: String
  verb: String
}

"A connection to a list of `RefStatus` values."
type RefStatusesConnection {
  "A list of edges which contains the `RefStatus` and cursor to aid in pagination."
  edges: [RefStatusesEdge!]!
  "A list of `RefStatus` objects."
  nodes: [RefStatus]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RefStatus` you could get from the connection."
  totalCount: Int!
}

"A `RefStatus` edge in the connection."
type RefStatusesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RefStatus` at the end of the edge."
  node: RefStatus
}

type RefUserType implements Node {
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdUserType(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesConnection!
  "Reads and enables pagination through a set of `AdmAccess`."
  admAccessesByIdUserTypeList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: AdmAccessCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!]
  ): [AdmAccess!]!
  idUserType: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  notes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"A connection to a list of `RefUserType` values."
type RefUserTypesConnection {
  "A list of edges which contains the `RefUserType` and cursor to aid in pagination."
  edges: [RefUserTypesEdge!]!
  "A list of `RefUserType` objects."
  nodes: [RefUserType]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `RefUserType` you could get from the connection."
  totalCount: Int!
}

"A `RefUserType` edge in the connection."
type RefUserTypesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `RefUserType` at the end of the edge."
  node: RefUserType
}

"The output of our `reviewApprove` mutation."
type ReviewApprovePayload {
  boolean: Boolean
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `reviewBackfill` mutation."
type ReviewBackfillPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `reviewCalculateScores` mutation."
type ReviewCalculateScoresPayload {
  bigFloat: BigFloat
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `reviewCreateDependent` mutation."
type ReviewCreateDependentPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our `reviewSetInitialRelation` mutation."
type ReviewSetInitialRelationPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"A connection to a list of `SActivity` values."
type SActivitiesConnection {
  "A list of edges which contains the `SActivity` and cursor to aid in pagination."
  edges: [SActivitiesEdge!]!
  "A list of `SActivity` objects."
  nodes: [SActivity]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `SActivity` you could get from the connection."
  totalCount: Int!
}

"A `SActivity` edge in the connection."
type SActivitiesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `SActivity` at the end of the edge."
  node: SActivity
}

type SActivity implements Node {
  id: Int!
  isComplete: Boolean
  linkedId: Int
  linkedObject: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  note: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  status: String
}

"System Error Log"
type SErr implements Node {
  area: String
  errorText: String
  id: Int!
  idApp: Int
  idRelated: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

"A connection to a list of `SErr` values."
type SErrsConnection {
  "A list of edges which contains the `SErr` and cursor to aid in pagination."
  edges: [SErrsEdge!]!
  "A list of `SErr` objects."
  nodes: [SErr]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `SErr` you could get from the connection."
  totalCount: Int!
}

"A `SErr` edge in the connection."
type SErrsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `SErr` at the end of the edge."
  node: SErr
}

"System  Log Table"
type SLog implements Node {
  actionRows: Int
  app: String
  appVersion: String
  area: String
  dbUser: String
  idLog: Int!
  isComplete: Boolean!
  logText: String
  mainRowsStart: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

type SLogCode implements Node {
  codeComment: String
  codeExecuted: String
  codeReplaced: String
  idCode: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sUpdate: Datetime
  sWhom: String
  version: Int
}

"A connection to a list of `SLogCode` values."
type SLogCodesConnection {
  "A list of edges which contains the `SLogCode` and cursor to aid in pagination."
  edges: [SLogCodesEdge!]!
  "A list of `SLogCode` objects."
  nodes: [SLogCode]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `SLogCode` you could get from the connection."
  totalCount: Int!
}

"A `SLogCode` edge in the connection."
type SLogCodesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `SLogCode` at the end of the edge."
  node: SLogCode
}

type SLogDetail implements Node {
  actionName: String
  idLog: Int
  idLogDetail: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime!
  sUpdate: Datetime!
  stepInterval: Interval
  stepLength: Int
  stepName: String
  stepNote: String
  stepRows: Int
}

"A connection to a list of `SLogDetail` values."
type SLogDetailsConnection {
  "A list of edges which contains the `SLogDetail` and cursor to aid in pagination."
  edges: [SLogDetailsEdge!]!
  "A list of `SLogDetail` objects."
  nodes: [SLogDetail]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `SLogDetail` you could get from the connection."
  totalCount: Int!
}

"A `SLogDetail` edge in the connection."
type SLogDetailsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `SLogDetail` at the end of the edge."
  node: SLogDetail
}

"A connection to a list of `SLog` values."
type SLogsConnection {
  "A list of edges which contains the `SLog` and cursor to aid in pagination."
  edges: [SLogsEdge!]!
  "A list of `SLog` objects."
  nodes: [SLog]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `SLog` you could get from the connection."
  totalCount: Int!
}

"A `SLog` edge in the connection."
type SLogsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `SLog` at the end of the edge."
  node: SLog
}

type STable implements Node {
  id: Int!
  idTabletype: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sUpdate: Datetime
  tableDescription: String
  tableName: String!
  typeName: String
}

type STableType implements Node {
  hasCreate: Boolean
  hasUpdate: Boolean
  hasUser: Boolean
  idTabletype: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  prefix: String
  sCreate: Datetime
  sUpdate: Datetime
  typeDescription: String
  typeName: String!
}

"A connection to a list of `STableType` values."
type STableTypesConnection {
  "A list of edges which contains the `STableType` and cursor to aid in pagination."
  edges: [STableTypesEdge!]!
  "A list of `STableType` objects."
  nodes: [STableType]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `STableType` you could get from the connection."
  totalCount: Int!
}

"A `STableType` edge in the connection."
type STableTypesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `STableType` at the end of the edge."
  node: STableType
}

"A connection to a list of `STable` values."
type STablesConnection {
  "A list of edges which contains the `STable` and cursor to aid in pagination."
  edges: [STablesEdge!]!
  "A list of `STable` objects."
  nodes: [STable]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `STable` you could get from the connection."
  totalCount: Int!
}

"A `STable` edge in the connection."
type STablesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `STable` at the end of the edge."
  node: STable
}

"The output of our `schoolAddFromReference` mutation."
type SchoolAddFromReferencePayload {
  bigFloat: BigFloat
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmAccess` mutation."
type UpdateAdmAccessPayload {
  "The `AdmAccess` that was updated by this mutation."
  admAccess: AdmAccess
  "An edge for our `AdmAccess`. May be used by Relay 1."
  admAccessEdge(
    "The method to use when ordering `AdmAccess`."
    orderBy: [AdmAccessesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAccessesEdge
  "Reads a single `AdmApp` that is related to this `AdmAccess`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `AdmAccess`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefUserType` that is related to this `AdmAccess`."
  refUserTypeByIdUserType: RefUserType
}

"The output of our update `AdmApp` mutation."
type UpdateAdmAppPayload {
  "The `AdmApp` that was updated by this mutation."
  admApp: AdmApp
  "An edge for our `AdmApp`. May be used by Relay 1."
  admAppEdge(
    "The method to use when ordering `AdmApp`."
    orderBy: [AdmAppsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmAppsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmCapacity` mutation."
type UpdateAdmCapacityPayload {
  "The `AdmCapacity` that was updated by this mutation."
  admCapacity: AdmCapacity
  "An edge for our `AdmCapacity`. May be used by Relay 1."
  admCapacityEdge(
    "The method to use when ordering `AdmCapacity`."
    orderBy: [AdmCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmCapacitiesEdge
  "Reads a single `AdmDomain` that is related to this `AdmCapacity`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmDefaultTemplate` mutation."
type UpdateAdmDefaultTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmDefaultTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDefaultTemplate` that was updated by this mutation."
  admDefaultTemplate: AdmDefaultTemplate
  "An edge for our `AdmDefaultTemplate`. May be used by Relay 1."
  admDefaultTemplateEdge(
    "The method to use when ordering `AdmDefaultTemplate`."
    orderBy: [AdmDefaultTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDefaultTemplatesEdge
  "Reads a single `AdmNarrative` that is related to this `AdmDefaultTemplate`."
  admNarrativeByIdAdmNarrative: AdmNarrative
  "Reads a single `AdmStrType` that is related to this `AdmDefaultTemplate`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmTemplate` that is related to this `AdmDefaultTemplate`."
  admTemplateByIdTemplate: AdmTemplate
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmDistrikt` mutation."
type UpdateAdmDistriktPayload {
  "Reads a single `AdmApp` that is related to this `AdmDistrikt`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDistrikt` that was updated by this mutation."
  admDistrikt: AdmDistrikt
  "An edge for our `AdmDistrikt`. May be used by Relay 1."
  admDistriktEdge(
    "The method to use when ordering `AdmDistrikt`."
    orderBy: [AdmDistriktsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDistriktsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmDocCategory` mutation."
type UpdateAdmDocCategoryPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocCategory`."
  admAppByIdAdmApp: AdmApp
  "The `AdmDocCategory` that was updated by this mutation."
  admDocCategory: AdmDocCategory
  "An edge for our `AdmDocCategory`. May be used by Relay 1."
  admDocCategoryEdge(
    "The method to use when ordering `AdmDocCategory`."
    orderBy: [AdmDocCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocCategoriesEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocCategory`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmDocSuggest` mutation."
type UpdateAdmDocSuggestPayload {
  "Reads a single `AdmApp` that is related to this `AdmDocSuggest`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDocCategory` that is related to this `AdmDocSuggest`."
  admDocCategoryByIdAdmDocCategory: AdmDocCategory
  "The `AdmDocSuggest` that was updated by this mutation."
  admDocSuggest: AdmDocSuggest
  "An edge for our `AdmDocSuggest`. May be used by Relay 1."
  admDocSuggestEdge(
    "The method to use when ordering `AdmDocSuggest`."
    orderBy: [AdmDocSuggestsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDocSuggestsEdge
  "Reads a single `AdmStrType` that is related to this `AdmDocSuggest`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmDomain` mutation."
type UpdateAdmDomainPayload {
  "The `AdmDomain` that was updated by this mutation."
  admDomain: AdmDomain
  "An edge for our `AdmDomain`. May be used by Relay 1."
  admDomainEdge(
    "The method to use when ordering `AdmDomain`."
    orderBy: [AdmDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmDomainsEdge
  "Reads a single `AdmFramework` that is related to this `AdmDomain`."
  admFrameworkByIdAdmFramework: AdmFramework
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmEngagement` mutation."
type UpdateAdmEngagementPayload {
  "The `AdmEngagement` that was updated by this mutation."
  admEngagement: AdmEngagement
  "An edge for our `AdmEngagement`. May be used by Relay 1."
  admEngagementEdge(
    "The method to use when ordering `AdmEngagement`."
    orderBy: [AdmEngagementsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmEngagementsEdge
  "Reads a single `AdmSkool` that is related to this `AdmEngagement`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmFramework` mutation."
type UpdateAdmFrameworkPayload {
  "Reads a single `AdmApp` that is related to this `AdmFramework`."
  admAppByIdAdmApp: AdmApp
  "The `AdmFramework` that was updated by this mutation."
  admFramework: AdmFramework
  "An edge for our `AdmFramework`. May be used by Relay 1."
  admFrameworkEdge(
    "The method to use when ordering `AdmFramework`."
    orderBy: [AdmFrameworksOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmFrameworksEdge
  "Reads a single `AdmScale` that is related to this `AdmFramework`."
  admScaleByIdAdmScale: AdmScale
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmNarrative` mutation."
type UpdateAdmNarrativePayload {
  "Reads a single `AdmApp` that is related to this `AdmNarrative`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDomain` that is related to this `AdmNarrative`."
  admDomainByIdAdmDomain: AdmDomain
  "The `AdmNarrative` that was updated by this mutation."
  admNarrative: AdmNarrative
  "An edge for our `AdmNarrative`. May be used by Relay 1."
  admNarrativeEdge(
    "The method to use when ordering `AdmNarrative`."
    orderBy: [AdmNarrativesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmNarrativesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmPeriod` mutation."
type UpdateAdmPeriodPayload {
  "Reads a single `AdmApp` that is related to this `AdmPeriod`."
  admAppByIdAdmApp: AdmApp
  "The `AdmPeriod` that was updated by this mutation."
  admPeriod: AdmPeriod
  "An edge for our `AdmPeriod`. May be used by Relay 1."
  admPeriodEdge(
    "The method to use when ordering `AdmPeriod`."
    orderBy: [AdmPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPeriodsEdge
  "Reads a single `AdmStrType` that is related to this `AdmPeriod`."
  admStrTypeByIdAdmStrType: AdmStrType
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmPractice` mutation."
type UpdateAdmPracticePayload {
  "Reads a single `AdmCapacity` that is related to this `AdmPractice`."
  admCapacityByIdAdmCapacity: AdmCapacity
  "Reads a single `AdmFramework` that is related to this `AdmPractice`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmPractice` that was updated by this mutation."
  admPractice: AdmPractice
  "An edge for our `AdmPractice`. May be used by Relay 1."
  admPracticeEdge(
    "The method to use when ordering `AdmPractice`."
    orderBy: [AdmPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmPracticesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmRubricMap` mutation."
type UpdateAdmRubricMapPayload {
  "Reads a single `AdmPractice` that is related to this `AdmRubricMap`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmRubric` that is related to this `AdmRubricMap`."
  admRubricByIdAdmRubric: AdmRubric
  "The `AdmRubricMap` that was updated by this mutation."
  admRubricMap: AdmRubricMap
  "An edge for our `AdmRubricMap`. May be used by Relay 1."
  admRubricMapEdge(
    "The method to use when ordering `AdmRubricMap`."
    orderBy: [AdmRubricMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmRubric` mutation."
type UpdateAdmRubricPayload {
  "Reads a single `AdmFramework` that is related to this `AdmRubric`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmRubric` that was updated by this mutation."
  admRubric: AdmRubric
  "An edge for our `AdmRubric`. May be used by Relay 1."
  admRubricEdge(
    "The method to use when ordering `AdmRubric`."
    orderBy: [AdmRubricsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmRubricsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmScale` mutation."
type UpdateAdmScalePayload {
  "The `AdmScale` that was updated by this mutation."
  admScale: AdmScale
  "An edge for our `AdmScale`. May be used by Relay 1."
  admScaleEdge(
    "The method to use when ordering `AdmScale`."
    orderBy: [AdmScalesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScalesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmScore` mutation."
type UpdateAdmScorePayload {
  "Reads a single `AdmScale` that is related to this `AdmScore`."
  admScaleByIdAdmScale: AdmScale
  "The `AdmScore` that was updated by this mutation."
  admScore: AdmScore
  "An edge for our `AdmScore`. May be used by Relay 1."
  admScoreEdge(
    "The method to use when ordering `AdmScore`."
    orderBy: [AdmScoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmScoresEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmSkool` mutation."
type UpdateAdmSkoolPayload {
  "Reads a single `AdmApp` that is related to this `AdmSkool`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmDistrikt` that is related to this `AdmSkool`."
  admDistriktByIdDistrictNces: AdmDistrikt
  "The `AdmSkool` that was updated by this mutation."
  admSkool: AdmSkool
  "An edge for our `AdmSkool`. May be used by Relay 1."
  admSkoolEdge(
    "The method to use when ordering `AdmSkool`."
    orderBy: [AdmSkoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmSkoolsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmStrSequence` mutation."
type UpdateAdmStrSequencePayload {
  "The `AdmStrSequence` that was updated by this mutation."
  admStrSequence: AdmStrSequence
  "An edge for our `AdmStrSequence`. May be used by Relay 1."
  admStrSequenceEdge(
    "The method to use when ordering `AdmStrSequence`."
    orderBy: [AdmStrSequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrSequencesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmStrTypeMap` mutation."
type UpdateAdmStrTypeMapPayload {
  "Reads a single `AdmApp` that is related to this `AdmStrTypeMap`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmStrType` that is related to this `AdmStrTypeMap`."
  admStrTypeByIdAdmStrType: AdmStrType
  "The `AdmStrTypeMap` that was updated by this mutation."
  admStrTypeMap: AdmStrTypeMap
  "An edge for our `AdmStrTypeMap`. May be used by Relay 1."
  admStrTypeMapEdge(
    "The method to use when ordering `AdmStrTypeMap`."
    orderBy: [AdmStrTypeMapsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypeMapsEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `AdmStrTypeMap`."
  refRelationByIdRelation: RefRelation
}

"The output of our update `AdmStrType` mutation."
type UpdateAdmStrTypePayload {
  "Reads a single `AdmApp` that is related to this `AdmStrType`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `AdmStrType`."
  admFrameworkByIdAdmFramework: AdmFramework
  "The `AdmStrType` that was updated by this mutation."
  admStrType: AdmStrType
  "An edge for our `AdmStrType`. May be used by Relay 1."
  admStrTypeEdge(
    "The method to use when ordering `AdmStrType`."
    orderBy: [AdmStrTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmStrTypesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmTemplate` mutation."
type UpdateAdmTemplatePayload {
  "Reads a single `AdmApp` that is related to this `AdmTemplate`."
  admAppByIdAdmApp: AdmApp
  "The `AdmTemplate` that was updated by this mutation."
  admTemplate: AdmTemplate
  "An edge for our `AdmTemplate`. May be used by Relay 1."
  admTemplateEdge(
    "The method to use when ordering `AdmTemplate`."
    orderBy: [AdmTemplatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmTemplatesEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `AdmUser` mutation."
type UpdateAdmUserPayload {
  "The `AdmUser` that was updated by this mutation."
  admUser: AdmUser
  "Reads a single `AdmUser` that is related to this `AdmUser`."
  admUserByIdManager: AdmUser
  "An edge for our `AdmUser`. May be used by Relay 1."
  admUserEdge(
    "The method to use when ordering `AdmUser`."
    orderBy: [AdmUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AdmUsersEdge
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `FlywaySchemaHistory` mutation."
type UpdateFlywaySchemaHistoryPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "The `FlywaySchemaHistory` that was updated by this mutation."
  flywaySchemaHistory: FlywaySchemaHistory
  "An edge for our `FlywaySchemaHistory`. May be used by Relay 1."
  flywaySchemaHistoryEdge(
    "The method to use when ordering `FlywaySchemaHistory`."
    orderBy: [FlywaySchemaHistoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FlywaySchemaHistoriesEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `Post` mutation."
type UpdatePostPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "The `Post` that was updated by this mutation."
  post: Post
  "An edge for our `Post`. May be used by Relay 1."
  postEdge(
    "The method to use when ordering `Post`."
    orderBy: [PostsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PostsEdge
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
}

"The output of our update `RefObject` mutation."
type UpdateRefObjectPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefObject` that was updated by this mutation."
  refObject: RefObject
  "An edge for our `RefObject`. May be used by Relay 1."
  refObjectEdge(
    "The method to use when ordering `RefObject`."
    orderBy: [RefObjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefObjectsEdge
}

"The output of our update `RefRelation` mutation."
type UpdateRefRelationPayload {
  "Reads a single `AdmApp` that is related to this `RefRelation`."
  admAppByIdAdmApp: AdmApp
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefRelation` that was updated by this mutation."
  refRelation: RefRelation
  "An edge for our `RefRelation`. May be used by Relay 1."
  refRelationEdge(
    "The method to use when ordering `RefRelation`."
    orderBy: [RefRelationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefRelationsEdge
}

"The output of our update `RefStatus` mutation."
type UpdateRefStatusPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefStatus` that was updated by this mutation."
  refStatus: RefStatus
  "An edge for our `RefStatus`. May be used by Relay 1."
  refStatusEdge(
    "The method to use when ordering `RefStatus`."
    orderBy: [RefStatusesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefStatusesEdge
}

"The output of our update `RefUserType` mutation."
type UpdateRefUserTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `RefUserType` that was updated by this mutation."
  refUserType: RefUserType
  "An edge for our `RefUserType`. May be used by Relay 1."
  refUserTypeEdge(
    "The method to use when ordering `RefUserType`."
    orderBy: [RefUserTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): RefUserTypesEdge
}

"The output of our update `SActivity` mutation."
type UpdateSActivityPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SActivity` that was updated by this mutation."
  sActivity: SActivity
  "An edge for our `SActivity`. May be used by Relay 1."
  sActivityEdge(
    "The method to use when ordering `SActivity`."
    orderBy: [SActivitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SActivitiesEdge
}

"The output of our update `SErr` mutation."
type UpdateSErrPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SErr` that was updated by this mutation."
  sErr: SErr
  "An edge for our `SErr`. May be used by Relay 1."
  sErrEdge(
    "The method to use when ordering `SErr`."
    orderBy: [SErrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SErrsEdge
}

"The output of our update `SLogCode` mutation."
type UpdateSLogCodePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogCode` that was updated by this mutation."
  sLogCode: SLogCode
  "An edge for our `SLogCode`. May be used by Relay 1."
  sLogCodeEdge(
    "The method to use when ordering `SLogCode`."
    orderBy: [SLogCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogCodesEdge
}

"The output of our update `SLogDetail` mutation."
type UpdateSLogDetailPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLogDetail` that was updated by this mutation."
  sLogDetail: SLogDetail
  "An edge for our `SLogDetail`. May be used by Relay 1."
  sLogDetailEdge(
    "The method to use when ordering `SLogDetail`."
    orderBy: [SLogDetailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogDetailsEdge
}

"The output of our update `SLog` mutation."
type UpdateSLogPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `SLog` that was updated by this mutation."
  sLog: SLog
  "An edge for our `SLog`. May be used by Relay 1."
  sLogEdge(
    "The method to use when ordering `SLog`."
    orderBy: [SLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SLogsEdge
}

"The output of our update `STable` mutation."
type UpdateSTablePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STable` that was updated by this mutation."
  sTable: STable
  "An edge for our `STable`. May be used by Relay 1."
  sTableEdge(
    "The method to use when ordering `STable`."
    orderBy: [STablesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STablesEdge
}

"The output of our update `STableType` mutation."
type UpdateSTableTypePayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `STableType` that was updated by this mutation."
  sTableType: STableType
  "An edge for our `STableType`. May be used by Relay 1."
  sTableTypeEdge(
    "The method to use when ordering `STableType`."
    orderBy: [STableTypesOrderBy!] = [PRIMARY_KEY_ASC]
  ): STableTypesEdge
}

"The output of our update `UsrCapacity` mutation."
type UpdateUsrCapacityPayload {
  "Reads a single `AdmCapacity` that is related to this `UsrCapacity`."
  admCapacityByIdAdmCapacity: AdmCapacity
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrCapacity` that was updated by this mutation."
  usrCapacity: UsrCapacity
  "An edge for our `UsrCapacity`. May be used by Relay 1."
  usrCapacityEdge(
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesEdge
  "Reads a single `UsrDomain` that is related to this `UsrCapacity`."
  usrDomainByIdUsrDomain: UsrDomain
  "Reads a single `UsrStr` that is related to this `UsrCapacity`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our update `UsrDoc` mutation."
type UpdateUsrDocPayload {
  "Reads a single `AdmApp` that is related to this `UsrDoc`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrDoc`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDoc` that was updated by this mutation."
  usrDoc: UsrDoc
  "An edge for our `UsrDoc`. May be used by Relay 1."
  usrDocEdge(
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsEdge
  "Reads a single `UsrStr` that is related to this `UsrDoc`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our update `UsrDomain` mutation."
type UpdateUsrDomainPayload {
  "Reads a single `AdmDomain` that is related to this `UsrDomain`."
  admDomainByIdAdmDomain: AdmDomain
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrDomain` that was updated by this mutation."
  usrDomain: UsrDomain
  "An edge for our `UsrDomain`. May be used by Relay 1."
  usrDomainEdge(
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsEdge
  "Reads a single `UsrStr` that is related to this `UsrDomain`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our update `UsrFocus` mutation."
type UpdateUsrFocusPayload {
  "Reads a single `AdmPractice` that is related to this `UsrFocus`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmSkool` that is related to this `UsrFocus`."
  admSkoolByIdSchoolNces: AdmSkool
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrFocus` that was updated by this mutation."
  usrFocus: UsrFocus
  "An edge for our `UsrFocus`. May be used by Relay 1."
  usrFocusEdge(
    "The method to use when ordering `UsrFocus`."
    orderBy: [UsrFociOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrFociEdge
}

"The output of our update `UsrNotify` mutation."
type UpdateUsrNotifyPayload {
  "Reads a single `AdmApp` that is related to this `UsrNotify`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrNotify`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `UsrNotify` that was updated by this mutation."
  usrNotify: UsrNotify
  "An edge for our `UsrNotify`. May be used by Relay 1."
  usrNotifyEdge(
    "The method to use when ordering `UsrNotify`."
    orderBy: [UsrNotifiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrNotifiesEdge
}

"The output of our update `UsrPractice` mutation."
type UpdateUsrPracticePayload {
  "Reads a single `AdmPractice` that is related to this `UsrPractice`."
  admPracticeByIdAdmPractice: AdmPractice
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrCapacity` that is related to this `UsrPractice`."
  usrCapacityByIdUsrCapacity: UsrCapacity
  "The `UsrPractice` that was updated by this mutation."
  usrPractice: UsrPractice
  "An edge for our `UsrPractice`. May be used by Relay 1."
  usrPracticeEdge(
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesEdge
  "Reads a single `UsrStr` that is related to this `UsrPractice`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our update `UsrRelationship` mutation."
type UpdateUsrRelationshipPayload {
  "Reads a single `AdmApp` that is related to this `UsrRelationship`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrRelationship`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `RefRelation` that is related to this `UsrRelationship`."
  refRelationByIdRelation: RefRelation
  "The `UsrRelationship` that was updated by this mutation."
  usrRelationship: UsrRelationship
  "An edge for our `UsrRelationship`. May be used by Relay 1."
  usrRelationshipEdge(
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsEdge
  "Reads a single `UsrStr` that is related to this `UsrRelationship`."
  usrStrByIdUsrStr: UsrStr
}

"The output of our update `UsrStr` mutation."
type UpdateUsrStrPayload {
  "Reads a single `AdmApp` that is related to this `UsrStr`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `UsrStr`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads a single `AdmPeriod` that is related to this `UsrStr`."
  admPeriodByIdAdmPeriod: AdmPeriod
  "Reads a single `AdmRubric` that is related to this `UsrStr`."
  admRubricByIdAdmRubric: AdmRubric
  "Reads a single `AdmSkool` that is related to this `UsrStr`."
  admSkoolByIdSchoolNces: AdmSkool
  "Reads a single `AdmStrType` that is related to this `UsrStr`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmUser` that is related to this `UsrStr`."
  admUserByIdAdmUser: AdmUser
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "Reads a single `UsrRelationship` that is related to this `UsrStr`."
  usrRelationshipByCurrentIdUsrRelationship: UsrRelationship
  "The `UsrStr` that was updated by this mutation."
  usrStr: UsrStr
  "An edge for our `UsrStr`. May be used by Relay 1."
  usrStrEdge(
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsEdge
}

"The output of our update `VwDistrict` mutation."
type UpdateVwDistrictPayload {
  """

  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  "Our root query field type. Allows us to run any query from our mutation payload."
  query: Query
  "The `VwDistrict` that was updated by this mutation."
  vwDistrict: VwDistrict
  "An edge for our `VwDistrict`. May be used by Relay 1."
  vwDistrictEdge(
    "The method to use when ordering `VwDistrict`."
    orderBy: [VwDistrictsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDistrictsEdge
}

"A connection to a list of `UsrCapacity` values."
type UsrCapacitiesConnection {
  "A list of edges which contains the `UsrCapacity` and cursor to aid in pagination."
  edges: [UsrCapacitiesEdge!]!
  "A list of `UsrCapacity` objects."
  nodes: [UsrCapacity]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrCapacity` you could get from the connection."
  totalCount: Int!
}

"A `UsrCapacity` edge in the connection."
type UsrCapacitiesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrCapacity` at the end of the edge."
  node: UsrCapacity
}

type UsrCapacity implements Node {
  "Reads a single `AdmCapacity` that is related to this `UsrCapacity`."
  admCapacityByIdAdmCapacity: AdmCapacity
  capacityNote: String
  capacityScore: BigFloat
  idAdmCapacity: Int!
  idUsrCapacity: Int!
  idUsrDomain: Int
  idUsrStr: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads a single `UsrDomain` that is related to this `UsrCapacity`."
  usrDomainByIdUsrDomain: UsrDomain
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdUsrCapacity(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesConnection!
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdUsrCapacityList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!]
  ): [UsrPractice!]!
  "Reads a single `UsrStr` that is related to this `UsrCapacity`."
  usrStrByIdUsrStr: UsrStr
}

type UsrDoc implements Node {
  "Reads a single `AdmApp` that is related to this `UsrDoc`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrDoc`."
  admUserByIdAdmUser: AdmUser
  docAttachmentPath: String
  docNotes: String
  docTitle: String!
  docUrlPath: String
  idAdmApp: Int!
  idAdmDocCategory: Int
  idAdmUser: Int!
  idUsrCapacity: Int
  idUsrDoc: Int!
  idUsrDomain: Int
  idUsrPractice: Int
  idUsrStr: Int!
  idUsrStrAdd: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads a single `UsrStr` that is related to this `UsrDoc`."
  usrStrByIdUsrStr: UsrStr
}

"A connection to a list of `UsrDoc` values."
type UsrDocsConnection {
  "A list of edges which contains the `UsrDoc` and cursor to aid in pagination."
  edges: [UsrDocsEdge!]!
  "A list of `UsrDoc` objects."
  nodes: [UsrDoc]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrDoc` you could get from the connection."
  totalCount: Int!
}

"A `UsrDoc` edge in the connection."
type UsrDocsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrDoc` at the end of the edge."
  node: UsrDoc
}

type UsrDomain implements Node {
  addOpportunities: String
  addStrengths: String
  "Reads a single `AdmDomain` that is related to this `UsrDomain`."
  admDomainByIdAdmDomain: AdmDomain
  domainScore: BigFloat
  gapClosure: BigFloat
  idAdmDomain: Int!
  idUsrDomain: Int!
  idUsrStr: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  opportunities: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strengths: String
  themes: String
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdUsrDomain(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesConnection!
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdUsrDomainList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!]
  ): [UsrCapacity!]!
  "Reads a single `UsrStr` that is related to this `UsrDomain`."
  usrStrByIdUsrStr: UsrStr
}

"A connection to a list of `UsrDomain` values."
type UsrDomainsConnection {
  "A list of edges which contains the `UsrDomain` and cursor to aid in pagination."
  edges: [UsrDomainsEdge!]!
  "A list of `UsrDomain` objects."
  nodes: [UsrDomain]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrDomain` you could get from the connection."
  totalCount: Int!
}

"A `UsrDomain` edge in the connection."
type UsrDomainsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrDomain` at the end of the edge."
  node: UsrDomain
}

"A connection to a list of `UsrFocus` values."
type UsrFociConnection {
  "A list of edges which contains the `UsrFocus` and cursor to aid in pagination."
  edges: [UsrFociEdge!]!
  "A list of `UsrFocus` objects."
  nodes: [UsrFocus]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrFocus` you could get from the connection."
  totalCount: Int!
}

"A `UsrFocus` edge in the connection."
type UsrFociEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrFocus` at the end of the edge."
  node: UsrFocus
}

type UsrFocus implements Node {
  "Reads a single `AdmPractice` that is related to this `UsrFocus`."
  admPracticeByIdAdmPractice: AdmPractice
  "Reads a single `AdmSkool` that is related to this `UsrFocus`."
  admSkoolByIdSchoolNces: AdmSkool
  idAdmPractice: Int!
  idSchoolNces: BigInt!
  idUsrFocus: Int!
  idUsrPractice: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int!
  score: Int
}

"A connection to a list of `UsrNotify` values."
type UsrNotifiesConnection {
  "A list of edges which contains the `UsrNotify` and cursor to aid in pagination."
  edges: [UsrNotifiesEdge!]!
  "A list of `UsrNotify` objects."
  nodes: [UsrNotify]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrNotify` you could get from the connection."
  totalCount: Int!
}

"A `UsrNotify` edge in the connection."
type UsrNotifiesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrNotify` at the end of the edge."
  node: UsrNotify
}

type UsrNotify implements Node {
  "Reads a single `AdmApp` that is related to this `UsrNotify`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrNotify`."
  admUserByIdAdmUser: AdmUser
  idAdmApp: Int!
  idAdmUser: Int!
  idNotify: Int!
  isRead: Boolean!
  linkedId: Int
  linkedObject: Int
  linkedUser: Int
  message: String!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  readReceipt: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

type UsrPractice implements Node {
  "Reads a single `AdmPractice` that is related to this `UsrPractice`."
  admPracticeByIdAdmPractice: AdmPractice
  idAction: Int
  idAdmPractice: Int!
  idUsrCapacity: Int!
  idUsrPractice: Int!
  idUsrStr: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  notes: String
  practiceScore: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  uidPractice: String
  uidStr: String
  "Reads a single `UsrCapacity` that is related to this `UsrPractice`."
  usrCapacityByIdUsrCapacity: UsrCapacity
  "Reads a single `UsrStr` that is related to this `UsrPractice`."
  usrStrByIdUsrStr: UsrStr
}

"A connection to a list of `UsrPractice` values."
type UsrPracticesConnection {
  "A list of edges which contains the `UsrPractice` and cursor to aid in pagination."
  edges: [UsrPracticesEdge!]!
  "A list of `UsrPractice` objects."
  nodes: [UsrPractice]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrPractice` you could get from the connection."
  totalCount: Int!
}

"A `UsrPractice` edge in the connection."
type UsrPracticesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrPractice` at the end of the edge."
  node: UsrPractice
}

type UsrRelationship implements Node {
  "Reads a single `AdmApp` that is related to this `UsrRelationship`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmUser` that is related to this `UsrRelationship`."
  admUserByIdAdmUser: AdmUser
  idAdmApp: Int!
  idAdmUser: Int
  idRelation: Int!
  idUsrRelationship: Int!
  idUsrStr: Int!
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  "Reads a single `RefRelation` that is related to this `UsrRelationship`."
  refRelationByIdRelation: RefRelation
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads a single `UsrStr` that is related to this `UsrRelationship`."
  usrStrByIdUsrStr: UsrStr
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByCurrentIdUsrRelationship(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrStrsConnection!
  "Reads and enables pagination through a set of `UsrStr`."
  usrStrsByCurrentIdUsrRelationshipList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrStrCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrStr`."
    orderBy: [UsrStrsOrderBy!]
  ): [UsrStr!]!
}

"A connection to a list of `UsrRelationship` values."
type UsrRelationshipsConnection {
  "A list of edges which contains the `UsrRelationship` and cursor to aid in pagination."
  edges: [UsrRelationshipsEdge!]!
  "A list of `UsrRelationship` objects."
  nodes: [UsrRelationship]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrRelationship` you could get from the connection."
  totalCount: Int!
}

"A `UsrRelationship` edge in the connection."
type UsrRelationshipsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrRelationship` at the end of the edge."
  node: UsrRelationship
}

type UsrStr implements Node {
  "Reads a single `AdmApp` that is related to this `UsrStr`."
  admAppByIdAdmApp: AdmApp
  "Reads a single `AdmFramework` that is related to this `UsrStr`."
  admFrameworkByIdAdmFramework: AdmFramework
  "Reads a single `AdmPeriod` that is related to this `UsrStr`."
  admPeriodByIdAdmPeriod: AdmPeriod
  "Reads a single `AdmRubric` that is related to this `UsrStr`."
  admRubricByIdAdmRubric: AdmRubric
  "Reads a single `AdmSkool` that is related to this `UsrStr`."
  admSkoolByIdSchoolNces: AdmSkool
  "Reads a single `AdmStrType` that is related to this `UsrStr`."
  admStrTypeByIdAdmStrType: AdmStrType
  "Reads a single `AdmUser` that is related to this `UsrStr`."
  admUserByIdAdmUser: AdmUser
  "The relationship currently managing the STR"
  currentIdUsrRelationship: Int
  currentStatus: String
  idAdmApp: Int
  idAdmFramework: Int!
  idAdmPeriod: Int!
  idAdmRubric: Int
  idAdmStrType: Int!
  "The user the str is owned by"
  idAdmUser: Int
  idLog: Int
  idSchoolNces: BigInt
  idStatus: Int
  idUsrStr: Int!
  idUsrStrNext: Int
  idUsrStrPrev: Int
  isComplete: Boolean!
  isScored: Boolean!
  lastLog: Datetime
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  overallThemes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strDate: Date!
  strScore: BigFloat
  strSeason: String
  strTeam: String
  tags: String
  uidStr: String
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrCapacitiesConnection!
  "Reads and enables pagination through a set of `UsrCapacity`."
  usrCapacitiesByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrCapacity`."
    orderBy: [UsrCapacitiesOrderBy!]
  ): [UsrCapacity!]!
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDocsConnection!
  "Reads and enables pagination through a set of `UsrDoc`."
  usrDocsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDoc`."
    orderBy: [UsrDocsOrderBy!]
  ): [UsrDoc!]!
  "Reads and enables pagination through a set of `UsrDomain`."
  usrDomainsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrDomainsConnection!
  "Reads and enables pagination through a set of `UsrDomain`."
  usrDomainsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrDomain`."
    orderBy: [UsrDomainsOrderBy!]
  ): [UsrDomain!]!
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrPracticesConnection!
  "Reads and enables pagination through a set of `UsrPractice`."
  usrPracticesByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrPractice`."
    orderBy: [UsrPracticesOrderBy!]
  ): [UsrPractice!]!
  "Reads a single `UsrRelationship` that is related to this `UsrStr`."
  usrRelationshipByCurrentIdUsrRelationship: UsrRelationship
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsrRelationshipsConnection!
  "Reads and enables pagination through a set of `UsrRelationship`."
  usrRelationshipsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: UsrRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `UsrRelationship`."
    orderBy: [UsrRelationshipsOrderBy!]
  ): [UsrRelationship!]!
}

"A connection to a list of `UsrStr` values."
type UsrStrsConnection {
  "A list of edges which contains the `UsrStr` and cursor to aid in pagination."
  edges: [UsrStrsEdge!]!
  "A list of `UsrStr` objects."
  nodes: [UsrStr]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `UsrStr` you could get from the connection."
  totalCount: Int!
}

"A `UsrStr` edge in the connection."
type UsrStrsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `UsrStr` at the end of the edge."
  node: UsrStr
}

"A connection to a list of `VwCapacity` values."
type VwCapacitiesConnection {
  "A list of edges which contains the `VwCapacity` and cursor to aid in pagination."
  edges: [VwCapacitiesEdge!]!
  "A list of `VwCapacity` objects."
  nodes: [VwCapacity]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwCapacity` you could get from the connection."
  totalCount: Int!
}

"A `VwCapacity` edge in the connection."
type VwCapacitiesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwCapacity` at the end of the edge."
  node: VwCapacity
}

type VwCapacity {
  capacityDescription: String
  capacityExemplar: String
  capacityName: String
  capacityNote: String
  capacityScore: BigFloat
  capacityTag: String
  domainName: String
  domainOrder: Int
  domainShort: String
  domainTag: String
  idAdmCapacity: Int
  idAdmDomain: Int
  idUsrCapacity: Int
  idUsrDomain: Int
  idUsrStr: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  "Reads a single `VwReview` that is related to this `VwCapacity`."
  vwReviewByIdUsrStr: VwReview
}

type VwDefaultTemplate {
  "Reads a single `AdmStrType` that is related to this `VwDefaultTemplate`."
  admStrTypeByIdAdmStrType: AdmStrType
  idAdmDomain: Int
  idAdmNarrative: Int
  idAdmStrType: Int
  narrativeName: String
  narrativeTags: String
  sortOrder: Int
  tags: String
  templateDescription: String
  templateLink: String
  templateName: String
  templateText: String
}

"A connection to a list of `VwDefaultTemplate` values."
type VwDefaultTemplatesConnection {
  "A list of edges which contains the `VwDefaultTemplate` and cursor to aid in pagination."
  edges: [VwDefaultTemplatesEdge!]!
  "A list of `VwDefaultTemplate` objects."
  nodes: [VwDefaultTemplate]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwDefaultTemplate` you could get from the connection."
  totalCount: Int!
}

"A `VwDefaultTemplate` edge in the connection."
type VwDefaultTemplatesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwDefaultTemplate` at the end of the edge."
  node: VwDefaultTemplate
}

type VwDistrict implements Node {
  districtName: String
  districtNameLocal: String
  idAdmApp: Int
  idDistrictNces: Int!
  isActive: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
  "Reads and enables pagination through a set of `VwSchool`."
  vwSchoolsByIdDistrictNces(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwSchool`."
    orderBy: [VwSchoolsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwSchoolsConnection!
  "Reads and enables pagination through a set of `VwSchool`."
  vwSchoolsByIdDistrictNcesList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwSchoolCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwSchool`."
    orderBy: [VwSchoolsOrderBy!]
  ): [VwSchool!]!
}

"A connection to a list of `VwDistrict` values."
type VwDistrictsConnection {
  "A list of edges which contains the `VwDistrict` and cursor to aid in pagination."
  edges: [VwDistrictsEdge!]!
  "A list of `VwDistrict` objects."
  nodes: [VwDistrict]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwDistrict` you could get from the connection."
  totalCount: Int!
}

"A `VwDistrict` edge in the connection."
type VwDistrictsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwDistrict` at the end of the edge."
  node: VwDistrict
}

type VwDoc implements Node {
  docAttachmentPath: String
  docCategoryName: String
  docNotes: String
  docTitle: String
  docUrlPath: String
  idAdmApp: Int
  idAdmDocCategory: Int
  idAdmStrType: Int
  idAdmUser: Int
  idReview: Int
  idUsrCapacity: Int
  idUsrDoc: Int!
  idUsrDomain: Int
  idUsrPractice: Int
  idUsrStr: Int
  idUsrStrAdd: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sCreateUserEmail: String
  sCreateUserName: String
  sUpdate: Datetime
  sUpdateUser: Int
  sUpdateUserEmail: String
  sUpdateUserName: String
  sortOrder: Int
  userEmail: String
  userName: String
  "Reads a single `VwReview` that is related to this `VwDoc`."
  vwReviewByIdReview: VwReview
  "Reads a single `VwReview` that is related to this `VwDoc`."
  vwReviewByIdUsrStr: VwReview
}

"A connection to a list of `VwDoc` values."
type VwDocsConnection {
  "A list of edges which contains the `VwDoc` and cursor to aid in pagination."
  edges: [VwDocsEdge!]!
  "A list of `VwDoc` objects."
  nodes: [VwDoc]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwDoc` you could get from the connection."
  totalCount: Int!
}

"A `VwDoc` edge in the connection."
type VwDocsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwDoc` at the end of the edge."
  node: VwDoc
}

type VwDomain {
  addOpportunities: String
  addStrengths: String
  domainDescription: String
  domainGapClosure: BigFloat
  domainName: String
  domainOrder: Int
  domainScore: BigFloat
  domainShort: String
  domainTag: String
  exemplar: String
  gapClosure: BigFloat
  idAdmDomain: Int
  idUsrDomain: Int
  idUsrStr: Int
  opportunities: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strengths: String
  themes: String
  "Reads a single `VwReview` that is related to this `VwDomain`."
  vwReviewByIdUsrStr: VwReview
}

"A connection to a list of `VwDomain` values."
type VwDomainsConnection {
  "A list of edges which contains the `VwDomain` and cursor to aid in pagination."
  edges: [VwDomainsEdge!]!
  "A list of `VwDomain` objects."
  nodes: [VwDomain]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwDomain` you could get from the connection."
  totalCount: Int!
}

"A `VwDomain` edge in the connection."
type VwDomainsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwDomain` at the end of the edge."
  node: VwDomain
}

type VwEngagementPeriod implements Node {
  currentIdAdmUser: Int
  currentIdUsrRelationship: Int
  districtName: String
  engagementKind: String
  engagementType: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmPeriod: Int
  idAdmRubric: Int
  idAdmStrType: Int
  idAdmUser: Int
  idDistrictNces: Int
  idEngagementKind: Int
  idEngagementType: Int
  idRelation: Int
  idSchoolNces: BigInt!
  idUsrStr: Int
  idUsrStrNext: Int
  idUsrStrPrev: Int
  isComplete: Boolean
  isOfficialRecord: Boolean
  isScored: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  overallThemes: String
  periodName: String
  relationUserEmail: String
  relationUserName: String
  relationshipDescription: String
  relationshipName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  schoolYearEnding: Int!
  strDate: Date
  strScore: BigFloat
  strSeason: String
  strTeam: String
  typeName: String
  typeTag: String
  uidStr: String
  userEmail: String
  userName: String
  "Reads a single `VwUser` that is related to this `VwEngagementPeriod`."
  vwUserByIdAdmUser: VwUser
}

"A connection to a list of `VwEngagementPeriod` values."
type VwEngagementPeriodsConnection {
  "A list of edges which contains the `VwEngagementPeriod` and cursor to aid in pagination."
  edges: [VwEngagementPeriodsEdge!]!
  "A list of `VwEngagementPeriod` objects."
  nodes: [VwEngagementPeriod]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwEngagementPeriod` you could get from the connection."
  totalCount: Int!
}

"A `VwEngagementPeriod` edge in the connection."
type VwEngagementPeriodsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwEngagementPeriod` at the end of the edge."
  node: VwEngagementPeriod
}

type VwPractice {
  capacityDescription: String
  capacityName: String
  capacityScore: BigFloat
  capacityTag: String
  domainDescription: String
  domainName: String
  domainOrder: Int
  domainScore: BigFloat
  domainShort: String
  domainTag: String
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
  idAdmPractice: Int
  idUsrCapacity: Int
  idUsrPractice: Int
  idUsrStr: Int
  notes: String
  practiceDescription: String
  practiceExemplar: String
  practiceName: String
  practiceScore: Int
  practiceTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  uidPractice: String
  uidStr: String
  "Reads a single `VwReview` that is related to this `VwPractice`."
  vwReviewByIdUsrStr: VwReview
}

"A connection to a list of `VwPractice` values."
type VwPracticesConnection {
  "A list of edges which contains the `VwPractice` and cursor to aid in pagination."
  edges: [VwPracticesEdge!]!
  "A list of `VwPractice` objects."
  nodes: [VwPractice]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwPractice` you could get from the connection."
  totalCount: Int!
}

"A `VwPractice` edge in the connection."
type VwPracticesEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwPractice` at the end of the edge."
  node: VwPractice
}

type VwRelationship implements Node {
  displayOrder: Int
  idAdmApp: Int
  idAdmUser: Int
  idRelation: Int
  idUsrRelationship: Int!
  idUsrStr: Int
  imageLink: String
  imageUrl: String
  isActive: Boolean
  nextIdRelation: Int
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  relationStrTypeId: Int
  relationshipDescription: String
  relationshipName: String
  userEmail: String
  userName: String
  userScore: Int
  "Reads a single `VwReview` that is related to this `VwRelationship`."
  vwReviewByIdUsrStr: VwReview
}

"A connection to a list of `VwRelationship` values."
type VwRelationshipsConnection {
  "A list of edges which contains the `VwRelationship` and cursor to aid in pagination."
  edges: [VwRelationshipsEdge!]!
  "A list of `VwRelationship` objects."
  nodes: [VwRelationship]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwRelationship` you could get from the connection."
  totalCount: Int!
}

"A `VwRelationship` edge in the connection."
type VwRelationshipsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwRelationship` at the end of the edge."
  node: VwRelationship
}

" @foreignKey (id_adm_user) references vw_user (id_adm_user)  "
type VwReview implements Node {
  currentIdAdmUser: Int
  currentIdUsrRelationship: Int
  currentStatus: String
  districtName: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmPeriod: Int
  idAdmRubric: Int
  idAdmStrType: Int
  idAdmUser: Int
  idDistrictNces: Int
  idRelation: Int
  idSchoolNces: BigInt
  idStatus: Int
  idUsrStr: Int!
  idUsrStrNext: Int
  idUsrStrPrev: Int
  isComplete: Boolean
  isOfficialRecord: Boolean
  isScored: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  overallThemes: String
  periodName: String
  relationUserEmail: String
  relationUserName: String
  relationshipDescription: String
  relationshipName: String
  rubricDescription: String
  rubricName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  schoolYearEnding: Int
  strDate: Date
  strScore: BigFloat
  strSeason: String
  strTeam: String
  strYear: Float
  tags: String
  typeName: String
  typeTag: String
  uidStr: String
  userEmail: String
  userName: String
  "Reads and enables pagination through a set of `VwCapacity`."
  vwCapacitiesByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwCapacity`."
    orderBy: [VwCapacitiesOrderBy!] = [NATURAL]
  ): VwCapacitiesConnection!
  "Reads and enables pagination through a set of `VwCapacity`."
  vwCapacitiesByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwCapacityCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwCapacity`."
    orderBy: [VwCapacitiesOrderBy!]
  ): [VwCapacity!]!
  "Reads and enables pagination through a set of `VwDoc`."
  vwDocsByIdReview(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDocsConnection!
  "Reads and enables pagination through a set of `VwDoc`."
  vwDocsByIdReviewList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!]
  ): [VwDoc!]!
  "Reads and enables pagination through a set of `VwDoc`."
  vwDocsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwDocsConnection!
  "Reads and enables pagination through a set of `VwDoc`."
  vwDocsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDocCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDoc`."
    orderBy: [VwDocsOrderBy!]
  ): [VwDoc!]!
  "Reads and enables pagination through a set of `VwDomain`."
  vwDomainsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwDomain`."
    orderBy: [VwDomainsOrderBy!] = [NATURAL]
  ): VwDomainsConnection!
  "Reads and enables pagination through a set of `VwDomain`."
  vwDomainsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwDomainCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwDomain`."
    orderBy: [VwDomainsOrderBy!]
  ): [VwDomain!]!
  "Reads and enables pagination through a set of `VwPractice`."
  vwPracticesByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwPractice`."
    orderBy: [VwPracticesOrderBy!] = [NATURAL]
  ): VwPracticesConnection!
  "Reads and enables pagination through a set of `VwPractice`."
  vwPracticesByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwPracticeCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwPractice`."
    orderBy: [VwPracticesOrderBy!]
  ): [VwPractice!]!
  "Reads and enables pagination through a set of `VwRelationship`."
  vwRelationshipsByIdUsrStr(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwRelationship`."
    orderBy: [VwRelationshipsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwRelationshipsConnection!
  "Reads and enables pagination through a set of `VwRelationship`."
  vwRelationshipsByIdUsrStrList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwRelationshipCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwRelationship`."
    orderBy: [VwRelationshipsOrderBy!]
  ): [VwRelationship!]!
}

"A connection to a list of `VwReview` values."
type VwReviewsConnection {
  "A list of edges which contains the `VwReview` and cursor to aid in pagination."
  edges: [VwReviewsEdge!]!
  "A list of `VwReview` objects."
  nodes: [VwReview]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwReview` you could get from the connection."
  totalCount: Int!
}

"A `VwReview` edge in the connection."
type VwReviewsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwReview` at the end of the edge."
  node: VwReview
}

type VwSchema {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: Datetime
  installedRank: Int
  script: String
  success: Boolean
  type: String
  version: String
}

"A connection to a list of `VwSchema` values."
type VwSchemasConnection {
  "A list of edges which contains the `VwSchema` and cursor to aid in pagination."
  edges: [VwSchemasEdge!]!
  "A list of `VwSchema` objects."
  nodes: [VwSchema]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwSchema` you could get from the connection."
  totalCount: Int!
}

"A `VwSchema` edge in the connection."
type VwSchemasEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwSchema` at the end of the edge."
  node: VwSchema
}

type VwSchool implements Node {
  districtName: String
  districtNameLocal: String
  districtTags: String
  id: Int
  idAdmApp: Int
  idDistrictNces: Int
  idSchoolNces: BigInt!
  isActive: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  state: String
  tags: String
  uidDistrict: String
  uidSchool: String
  "Reads a single `VwDistrict` that is related to this `VwSchool`."
  vwDistrictByIdDistrictNces: VwDistrict
}

"A connection to a list of `VwSchool` values."
type VwSchoolsConnection {
  "A list of edges which contains the `VwSchool` and cursor to aid in pagination."
  edges: [VwSchoolsEdge!]!
  "A list of `VwSchool` objects."
  nodes: [VwSchool]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwSchool` you could get from the connection."
  totalCount: Int!
}

"A `VwSchool` edge in the connection."
type VwSchoolsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwSchool` at the end of the edge."
  node: VwSchool
}

type VwSeason {
  "Reads a single `AdmApp` that is related to this `VwSeason`."
  admAppByIdAdmApp: AdmApp
  idAdmApp: Int
  strSeason: String
}

"A connection to a list of `VwSeason` values."
type VwSeasonsConnection {
  "A list of edges which contains the `VwSeason` and cursor to aid in pagination."
  edges: [VwSeasonsEdge!]!
  "A list of `VwSeason` objects."
  nodes: [VwSeason]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwSeason` you could get from the connection."
  totalCount: Int!
}

"A `VwSeason` edge in the connection."
type VwSeasonsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwSeason` at the end of the edge."
  node: VwSeason
}

"selects apps with isTest as a property in their prefs"
type VwTestApp {
  appPreferences: JSON
  description: String
  helpCalibrate: String
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"A connection to a list of `VwTestApp` values."
type VwTestAppsConnection {
  "A list of edges which contains the `VwTestApp` and cursor to aid in pagination."
  edges: [VwTestAppsEdge!]!
  "A list of `VwTestApp` objects."
  nodes: [VwTestApp]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwTestApp` you could get from the connection."
  totalCount: Int!
}

"A `VwTestApp` edge in the connection."
type VwTestAppsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwTestApp` at the end of the edge."
  node: VwTestApp
}

type VwUser implements Node {
  "Reads a single `AdmApp` that is related to this `VwUser`."
  admAppByIdAdmApp: AdmApp
  idAdmApp: Int!
  idAdmUser: Int!
  idManager: Int
  idUserType: Int
  imageLink: String
  imageUrl: String
  isActive: Boolean
  "A globally unique identifier. Can be used in various places throughout the system to identify this single value."
  nodeId: ID!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: Int
  userEmail: String
  userName: String
  userPreferences: JSON
  userScore: Int
  userTypeNotes: String
  userTypeTitle: String
  "Reads and enables pagination through a set of `VwEngagementPeriod`."
  vwEngagementPeriodsByIdAdmUser(
    "Read all values in the set after (below) this cursor."
    after: Cursor,
    "Read all values in the set before (above) this cursor."
    before: Cursor,
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwEngagementPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Only read the last `n` values of the set."
    last: Int,
    """

    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int,
    "The method to use when ordering `VwEngagementPeriod`."
    orderBy: [VwEngagementPeriodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VwEngagementPeriodsConnection!
  "Reads and enables pagination through a set of `VwEngagementPeriod`."
  vwEngagementPeriodsByIdAdmUserList(
    "A condition to be used in determining which values should be returned by the collection."
    condition: VwEngagementPeriodCondition,
    "Only read the first `n` values of the set."
    first: Int,
    "Skip the first `n` values."
    offset: Int,
    "The method to use when ordering `VwEngagementPeriod`."
    orderBy: [VwEngagementPeriodsOrderBy!]
  ): [VwEngagementPeriod!]!
}

"A connection to a list of `VwUser` values."
type VwUsersConnection {
  "A list of edges which contains the `VwUser` and cursor to aid in pagination."
  edges: [VwUsersEdge!]!
  "A list of `VwUser` objects."
  nodes: [VwUser]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `VwUser` you could get from the connection."
  totalCount: Int!
}

"A `VwUser` edge in the connection."
type VwUsersEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `VwUser` at the end of the edge."
  node: VwUser
}

type _VwAdmCapacityFramework {
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
}

"A connection to a list of `_VwAdmCapacityFramework` values."
type _VwAdmCapacityFrameworksConnection {
  "A list of edges which contains the `_VwAdmCapacityFramework` and cursor to aid in pagination."
  edges: [_VwAdmCapacityFrameworksEdge!]!
  "A list of `_VwAdmCapacityFramework` objects."
  nodes: [_VwAdmCapacityFramework]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwAdmCapacityFramework` you could get from the connection."
  totalCount: Int!
}

"A `_VwAdmCapacityFramework` edge in the connection."
type _VwAdmCapacityFrameworksEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwAdmCapacityFramework` at the end of the edge."
  node: _VwAdmCapacityFramework
}

type _VwAdmCapacityRubric {
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
  idAdmRubric: Int
}

"A connection to a list of `_VwAdmCapacityRubric` values."
type _VwAdmCapacityRubricsConnection {
  "A list of edges which contains the `_VwAdmCapacityRubric` and cursor to aid in pagination."
  edges: [_VwAdmCapacityRubricsEdge!]!
  "A list of `_VwAdmCapacityRubric` objects."
  nodes: [_VwAdmCapacityRubric]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwAdmCapacityRubric` you could get from the connection."
  totalCount: Int!
}

"A `_VwAdmCapacityRubric` edge in the connection."
type _VwAdmCapacityRubricsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwAdmCapacityRubric` at the end of the edge."
  node: _VwAdmCapacityRubric
}

"an easy way to pull the combined setup for a framework - flattened view of adm_domain, adm_capacity, adm_practice"
type _VwAdmPracticeFramework {
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
  idAdmPractice: Int
}

"A connection to a list of `_VwAdmPracticeFramework` values."
type _VwAdmPracticeFrameworksConnection {
  "A list of edges which contains the `_VwAdmPracticeFramework` and cursor to aid in pagination."
  edges: [_VwAdmPracticeFrameworksEdge!]!
  "A list of `_VwAdmPracticeFramework` objects."
  nodes: [_VwAdmPracticeFramework]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwAdmPracticeFramework` you could get from the connection."
  totalCount: Int!
}

"A `_VwAdmPracticeFramework` edge in the connection."
type _VwAdmPracticeFrameworksEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwAdmPracticeFramework` at the end of the edge."
  node: _VwAdmPracticeFramework
}

type _VwAdmPracticeFull {
  analysisName: String
  capacityDescription: String
  capacityName: String
  capacityTag: String
  domainDescription: String
  domainGapClosure: BigFloat
  domainName: String
  domainOrder: Int
  domainShort: String
  domainTag: String
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
  idAdmPractice: Int
  practiceDescription: String
  practiceGrouping: String
  practiceName: String
  practiceTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A connection to a list of `_VwAdmPracticeFull` values."
type _VwAdmPracticeFullsConnection {
  "A list of edges which contains the `_VwAdmPracticeFull` and cursor to aid in pagination."
  edges: [_VwAdmPracticeFullsEdge!]!
  "A list of `_VwAdmPracticeFull` objects."
  nodes: [_VwAdmPracticeFull]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwAdmPracticeFull` you could get from the connection."
  totalCount: Int!
}

"A `_VwAdmPracticeFull` edge in the connection."
type _VwAdmPracticeFullsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwAdmPracticeFull` at the end of the edge."
  node: _VwAdmPracticeFull
}

type _VwAdmPracticeRubric {
  idAdmCapacity: Int
  idAdmDomain: Int
  idAdmFramework: Int
  idAdmPractice: Int
  idAdmRubric: Int
}

"A connection to a list of `_VwAdmPracticeRubric` values."
type _VwAdmPracticeRubricsConnection {
  "A list of edges which contains the `_VwAdmPracticeRubric` and cursor to aid in pagination."
  edges: [_VwAdmPracticeRubricsEdge!]!
  "A list of `_VwAdmPracticeRubric` objects."
  nodes: [_VwAdmPracticeRubric]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwAdmPracticeRubric` you could get from the connection."
  totalCount: Int!
}

"A `_VwAdmPracticeRubric` edge in the connection."
type _VwAdmPracticeRubricsEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwAdmPracticeRubric` at the end of the edge."
  node: _VwAdmPracticeRubric
}

type _VwCapacityScore {
  capacityScore: BigFloat
  idUsrCapacity: Int
  idUsrStr: Int
}

"A connection to a list of `_VwCapacityScore` values."
type _VwCapacityScoresConnection {
  "A list of edges which contains the `_VwCapacityScore` and cursor to aid in pagination."
  edges: [_VwCapacityScoresEdge!]!
  "A list of `_VwCapacityScore` objects."
  nodes: [_VwCapacityScore]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwCapacityScore` you could get from the connection."
  totalCount: Int!
}

"A `_VwCapacityScore` edge in the connection."
type _VwCapacityScoresEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwCapacityScore` at the end of the edge."
  node: _VwCapacityScore
}

type _VwDomainScore {
  domainScore: BigFloat
  idUsrDomain: Int
  idUsrStr: Int
}

"A connection to a list of `_VwDomainScore` values."
type _VwDomainScoresConnection {
  "A list of edges which contains the `_VwDomainScore` and cursor to aid in pagination."
  edges: [_VwDomainScoresEdge!]!
  "A list of `_VwDomainScore` objects."
  nodes: [_VwDomainScore]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwDomainScore` you could get from the connection."
  totalCount: Int!
}

"A `_VwDomainScore` edge in the connection."
type _VwDomainScoresEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwDomainScore` at the end of the edge."
  node: _VwDomainScore
}

type _VwStrScore {
  idUsrStr: Int
  strScore: BigFloat
}

"A connection to a list of `_VwStrScore` values."
type _VwStrScoresConnection {
  "A list of edges which contains the `_VwStrScore` and cursor to aid in pagination."
  edges: [_VwStrScoresEdge!]!
  "A list of `_VwStrScore` objects."
  nodes: [_VwStrScore]!
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "The count of *all* `_VwStrScore` you could get from the connection."
  totalCount: Int!
}

"A `_VwStrScore` edge in the connection."
type _VwStrScoresEdge {
  "A cursor for use in pagination."
  cursor: Cursor
  "The `_VwStrScore` at the end of the edge."
  node: _VwStrScore
}

"Methods to use when ordering `AdmAccess`."
enum AdmAccessesOrderBy {
  ID_ADM_ACCESS_ASC
  ID_ADM_ACCESS_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_USER_TYPE_ASC
  ID_USER_TYPE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmApp`."
enum AdmAppsOrderBy {
  APP_PREFERENCES_ASC
  APP_PREFERENCES_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  HELP_CALIBRATE_ASC
  HELP_CALIBRATE_DESC
  HELP_FACILITATE_ASC
  HELP_FACILITATE_DESC
  HELP_SCORE_ASC
  HELP_SCORE_DESC
  HELP_SUMMARY_ASC
  HELP_SUMMARY_DESC
  HELP_VIEW_ASC
  HELP_VIEW_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TITLE_ASC
  TITLE_DESC
}

"Methods to use when ordering `AdmCapacity`."
enum AdmCapacitiesOrderBy {
  CAPACITY_DESCRIPTION_ASC
  CAPACITY_DESCRIPTION_DESC
  CAPACITY_EXEMPLAR_ASC
  CAPACITY_EXEMPLAR_DESC
  CAPACITY_NAME_ASC
  CAPACITY_NAME_DESC
  CAPACITY_TAG_ASC
  CAPACITY_TAG_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmDefaultTemplate`."
enum AdmDefaultTemplatesOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DEFAULT_NT_ASC
  ID_ADM_DEFAULT_NT_DESC
  ID_ADM_NARRATIVE_ASC
  ID_ADM_NARRATIVE_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_TEMPLATE_ASC
  ID_TEMPLATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmDistrikt`."
enum AdmDistriktsOrderBy {
  DISTRICT_ABBR_ASC
  DISTRICT_ABBR_DESC
  DISTRICT_NAME_ASC
  DISTRICT_NAME_DESC
  DISTRICT_NAME_LOCAL_ASC
  DISTRICT_NAME_LOCAL_DESC
  EMAIL_MANAGER_ASC
  EMAIL_MANAGER_DESC
  EMAIL_STAFF_ASC
  EMAIL_STAFF_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REGION_NAME_ASC
  REGION_NAME_DESC
  STATE_ASC
  STATE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_DISTRICT_ASC
  UID_DISTRICT_DESC
}

"Methods to use when ordering `AdmDocCategory`."
enum AdmDocCategoriesOrderBy {
  DOC_CATEGORY_NAME_ASC
  DOC_CATEGORY_NAME_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DOC_CATEGORY_ASC
  ID_ADM_DOC_CATEGORY_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmDocSuggest`."
enum AdmDocSuggestsOrderBy {
  DOC_NOTES_ASC
  DOC_NOTES_DESC
  DOC_TITLE_ASC
  DOC_TITLE_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DOC_CATEGORY_ASC
  ID_ADM_DOC_CATEGORY_DESC
  ID_ADM_DOC_SUGGEST_ASC
  ID_ADM_DOC_SUGGEST_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmDomain`."
enum AdmDomainsOrderBy {
  DOMAIN_DESCRIPTION_ASC
  DOMAIN_DESCRIPTION_DESC
  DOMAIN_GAP_CLOSURE_ASC
  DOMAIN_GAP_CLOSURE_DESC
  DOMAIN_NAME_ASC
  DOMAIN_NAME_DESC
  DOMAIN_ORDER_ASC
  DOMAIN_ORDER_DESC
  DOMAIN_SHORT_ASC
  DOMAIN_SHORT_DESC
  DOMAIN_TAG_ASC
  DOMAIN_TAG_DESC
  EXEMPLAR_ASC
  EXEMPLAR_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmEngagement`."
enum AdmEngagementsOrderBy {
  ENGAGEMENT_KIND_ASC
  ENGAGEMENT_KIND_DESC
  ENGAGEMENT_TYPE_ASC
  ENGAGEMENT_TYPE_DESC
  ID_ADM_ENGAGEMENT_ASC
  ID_ADM_ENGAGEMENT_DESC
  ID_ENGAGEMENT_KIND_ASC
  ID_ENGAGEMENT_KIND_DESC
  ID_ENGAGEMENT_TYPE_ASC
  ID_ENGAGEMENT_TYPE_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCHOOL_YEAR_ENDING_ASC
  SCHOOL_YEAR_ENDING_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmFramework`."
enum AdmFrameworksOrderBy {
  EFFECTIVE_DATE_ASC
  EFFECTIVE_DATE_DESC
  END_DATE_ASC
  END_DATE_DESC
  FRAMEWORK_NAME_ASC
  FRAMEWORK_NAME_DESC
  FRAMEWORK_VERSION_ASC
  FRAMEWORK_VERSION_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_SCALE_ASC
  ID_ADM_SCALE_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
}

"Methods to use when ordering `AdmNarrative`."
enum AdmNarrativesOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_NARRATIVE_ASC
  ID_ADM_NARRATIVE_DESC
  NARRATIVE_NAME_ASC
  NARRATIVE_NAME_DESC
  NARRATIVE_TAGS_ASC
  NARRATIVE_TAGS_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TRIAL_TAGS_ASC
  TRIAL_TAGS_DESC
}

"Methods to use when ordering `AdmPeriod`."
enum AdmPeriodsOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_PERIOD_ASC
  ID_ADM_PERIOD_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  NATURAL
  PERIOD_END_MONTH_ASC
  PERIOD_END_MONTH_DESC
  PERIOD_NAME_ASC
  PERIOD_NAME_DESC
  PERIOD_START_MONTH_ASC
  PERIOD_START_MONTH_DESC
  PERIOD_TAG_ASC
  PERIOD_TAG_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STARTS_NEW_SEQUENCE_ASC
  STARTS_NEW_SEQUENCE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmPractice`."
enum AdmPracticesOrderBy {
  ANALYSIS_NAME_ASC
  ANALYSIS_NAME_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  NATURAL
  PRACTICE_DESCRIPTION_ASC
  PRACTICE_DESCRIPTION_DESC
  PRACTICE_EXEMPLAR_ASC
  PRACTICE_EXEMPLAR_DESC
  PRACTICE_GROUPING_ASC
  PRACTICE_GROUPING_DESC
  PRACTICE_NAME_ASC
  PRACTICE_NAME_DESC
  PRACTICE_TAG_ASC
  PRACTICE_TAG_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_PRACTICE_ASC
  UID_PRACTICE_DESC
}

"Methods to use when ordering `AdmRubricMap`."
enum AdmRubricMapsOrderBy {
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  ID_ADM_RUBRIC_MAP_ASC
  ID_ADM_RUBRIC_MAP_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmRubric`."
enum AdmRubricsOrderBy {
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RUBRIC_DESCRIPTION_ASC
  RUBRIC_DESCRIPTION_DESC
  RUBRIC_NAME_ASC
  RUBRIC_NAME_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
}

"Methods to use when ordering `AdmScale`."
enum AdmScalesOrderBy {
  DISPLAY_ORDER_ASC
  DISPLAY_ORDER_DESC
  ID_ADM_SCALE_ASC
  ID_ADM_SCALE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCALE_DESCRIPTION_ASC
  SCALE_DESCRIPTION_DESC
  SCALE_GRAPHIC_URL_ASC
  SCALE_GRAPHIC_URL_DESC
  SCALE_NAME_ASC
  SCALE_NAME_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmScore`."
enum AdmScoresOrderBy {
  CONSISTENCY_ASC
  CONSISTENCY_DESC
  DISPLAY_ORDER_ASC
  DISPLAY_ORDER_DESC
  FREQUENCY_ASC
  FREQUENCY_DESC
  ID_ADM_SCALE_ASC
  ID_ADM_SCALE_DESC
  ID_ADM_SCORE_ASC
  ID_ADM_SCORE_DESC
  INTENTIONALITY_ASC
  INTENTIONALITY_DESC
  NATURAL
  OWNERSHIP_ASC
  OWNERSHIP_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  QUALITY_ASC
  QUALITY_DESC
  SCORE_DESCRIPTION_ASC
  SCORE_DESCRIPTION_DESC
  SCORE_NAME_ASC
  SCORE_NAME_DESC
  SCORE_VALUE_ASC
  SCORE_VALUE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmSkool`."
enum AdmSkoolsOrderBy {
  EMAIL_MANAGER_ASC
  EMAIL_MANAGER_DESC
  EMAIL_STAFF_ASC
  EMAIL_STAFF_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_ASC
  ID_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCHOOL_NAME_ASC
  SCHOOL_NAME_DESC
  SCHOOL_NAME_LOCAL_ASC
  SCHOOL_NAME_LOCAL_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_SCHOOL_ASC
  UID_SCHOOL_DESC
}

"Methods to use when ordering `AdmStrSequence`."
enum AdmStrSequencesOrderBy {
  ID_ADM_STR_SEQUENCE_ASC
  ID_ADM_STR_SEQUENCE_DESC
  ID_USER_STR_PREV_ASC
  ID_USER_STR_PREV_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  ID_USR_STR_NEXT_ASC
  ID_USR_STR_NEXT_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REASON_ASC
  REASON_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmStrTypeMap`."
enum AdmStrTypeMapsOrderBy {
  DISPLAY_ORDER_ASC
  DISPLAY_ORDER_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_ADM_STR_TYPE_MAP_ASC
  ID_ADM_STR_TYPE_MAP_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  NATURAL
  NEXT_ID_RELATION_ASC
  NEXT_ID_RELATION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RELATION_STR_TYPE_ID_ASC
  RELATION_STR_TYPE_ID_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `AdmStrType`."
enum AdmStrTypesOrderBy {
  CONTRIBUTE_TO_STR_TYPE_ASC
  CONTRIBUTE_TO_STR_TYPE_DESC
  EDIT_ACTION_ASC
  EDIT_ACTION_DESC
  HAS_GOALS_ASC
  HAS_GOALS_DESC
  HAS_PERIOD_ASC
  HAS_PERIOD_DESC
  HAS_SCHOOL_ASC
  HAS_SCHOOL_DESC
  HAS_SUMMARY_ASC
  HAS_SUMMARY_DESC
  HELP_FACILITATE_ASC
  HELP_FACILITATE_DESC
  HELP_SCORE_ASC
  HELP_SCORE_DESC
  HELP_SUMMARY_ASC
  HELP_SUMMARY_DESC
  HELP_VIEW_ASC
  HELP_VIEW_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_OBJECT_ASC
  ID_OBJECT_DESC
  INITIAL_ID_RELATION_ASC
  INITIAL_ID_RELATION_DESC
  IS_CALIBRATED_ASC
  IS_CALIBRATED_DESC
  IS_EXPORTED_ASC
  IS_EXPORTED_DESC
  IS_OFFICIAL_RECORD_ASC
  IS_OFFICIAL_RECORD_DESC
  NATURAL
  NEXT_STR_TYPE_ASC
  NEXT_STR_TYPE_DESC
  PREV_STR_TYPE_ASC
  PREV_STR_TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRINT_ACTION_ASC
  PRINT_ACTION_DESC
  REQUIRE_BASELINE_ASC
  REQUIRE_BASELINE_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  SUMMARY_ACTION_ASC
  SUMMARY_ACTION_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TYPE_DESCRIPTION_ASC
  TYPE_DESCRIPTION_DESC
  TYPE_ICON_ASC
  TYPE_ICON_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
  TYPE_TAG_ASC
  TYPE_TAG_DESC
  VIEW_ACTION_ASC
  VIEW_ACTION_DESC
}

"Methods to use when ordering `AdmTemplate`."
enum AdmTemplatesOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_TEMPLATE_ASC
  ID_TEMPLATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  TEMPLATE_DESCRIPTION_ASC
  TEMPLATE_DESCRIPTION_DESC
  TEMPLATE_LINK_ASC
  TEMPLATE_LINK_DESC
  TEMPLATE_NAME_ASC
  TEMPLATE_NAME_DESC
  TEMPLATE_TEXT_ASC
  TEMPLATE_TEXT_DESC
}

"Methods to use when ordering `AdmUser`."
enum AdmUsersOrderBy {
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_MANAGER_ASC
  ID_MANAGER_DESC
  IMAGE_LINK_ASC
  IMAGE_LINK_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SPARE_ASC
  SPARE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
  USER_PREFERENCES_ASC
  USER_PREFERENCES_DESC
  USER_SCORE_ASC
  USER_SCORE_DESC
}

"Methods to use when ordering `FlywaySchemaHistory`."
enum FlywaySchemaHistoriesOrderBy {
  CHECKSUM_ASC
  CHECKSUM_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  EXECUTION_TIME_ASC
  EXECUTION_TIME_DESC
  INSTALLED_BY_ASC
  INSTALLED_BY_DESC
  INSTALLED_ON_ASC
  INSTALLED_ON_DESC
  INSTALLED_RANK_ASC
  INSTALLED_RANK_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCRIPT_ASC
  SCRIPT_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TYPE_ASC
  TYPE_DESC
  VERSION_ASC
  VERSION_DESC
}

"Methods to use when ordering `Post`."
enum PostsOrderBy {
  ID_ASC
  ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TITLE_ASC
  TITLE_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"Methods to use when ordering `RefObject`."
enum RefObjectsOrderBy {
  DEPENDS_ON_ASC
  DEPENDS_ON_DESC
  ID_OBJECT_ASC
  ID_OBJECT_DESC
  NATURAL
  OBJECT_DESCRIPTION_ASC
  OBJECT_DESCRIPTION_DESC
  OBJECT_NAME_ASC
  OBJECT_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
}

"Methods to use when ordering `RefRelation`."
enum RefRelationsOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RELATIONSHIP_DESCRIPTION_ASC
  RELATIONSHIP_DESCRIPTION_DESC
  RELATIONSHIP_NAME_ASC
  RELATIONSHIP_NAME_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `RefStatus`."
enum RefStatusesOrderBy {
  DISPLAY_ORDER_ASC
  DISPLAY_ORDER_DESC
  ICON_ASC
  ICON_DESC
  ID_STATUS_ASC
  ID_STATUS_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STATE_ASC
  STATE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  VERB_ASC
  VERB_DESC
}

"Methods to use when ordering `RefUserType`."
enum RefUserTypesOrderBy {
  ID_USER_TYPE_ASC
  ID_USER_TYPE_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TITLE_ASC
  TITLE_DESC
}

"Methods to use when ordering `SActivity`."
enum SActivitiesOrderBy {
  ID_ASC
  ID_DESC
  IS_COMPLETE_ASC
  IS_COMPLETE_DESC
  LINKED_ID_ASC
  LINKED_ID_DESC
  LINKED_OBJECT_ASC
  LINKED_OBJECT_DESC
  NATURAL
  NOTE_ASC
  NOTE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STATUS_ASC
  STATUS_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
}

"Methods to use when ordering `SErr`."
enum SErrsOrderBy {
  AREA_ASC
  AREA_DESC
  ERROR_TEXT_ASC
  ERROR_TEXT_DESC
  ID_APP_ASC
  ID_APP_DESC
  ID_ASC
  ID_DESC
  ID_RELATED_ASC
  ID_RELATED_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
}

"Methods to use when ordering `SLogCode`."
enum SLogCodesOrderBy {
  CODE_COMMENT_ASC
  CODE_COMMENT_DESC
  CODE_EXECUTED_ASC
  CODE_EXECUTED_DESC
  CODE_REPLACED_ASC
  CODE_REPLACED_DESC
  ID_CODE_ASC
  ID_CODE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_WHOM_ASC
  S_WHOM_DESC
  VERSION_ASC
  VERSION_DESC
}

"Methods to use when ordering `SLogDetail`."
enum SLogDetailsOrderBy {
  ACTION_NAME_ASC
  ACTION_NAME_DESC
  ID_LOG_ASC
  ID_LOG_DESC
  ID_LOG_DETAIL_ASC
  ID_LOG_DETAIL_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STEP_INTERVAL_ASC
  STEP_INTERVAL_DESC
  STEP_LENGTH_ASC
  STEP_LENGTH_DESC
  STEP_NAME_ASC
  STEP_NAME_DESC
  STEP_NOTE_ASC
  STEP_NOTE_DESC
  STEP_ROWS_ASC
  STEP_ROWS_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
}

"Methods to use when ordering `SLog`."
enum SLogsOrderBy {
  ACTION_ROWS_ASC
  ACTION_ROWS_DESC
  APP_ASC
  APP_DESC
  APP_VERSION_ASC
  APP_VERSION_DESC
  AREA_ASC
  AREA_DESC
  DB_USER_ASC
  DB_USER_DESC
  ID_LOG_ASC
  ID_LOG_DESC
  IS_COMPLETE_ASC
  IS_COMPLETE_DESC
  LOG_TEXT_ASC
  LOG_TEXT_DESC
  MAIN_ROWS_START_ASC
  MAIN_ROWS_START_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
}

"Methods to use when ordering `STableType`."
enum STableTypesOrderBy {
  HAS_CREATE_ASC
  HAS_CREATE_DESC
  HAS_UPDATE_ASC
  HAS_UPDATE_DESC
  HAS_USER_ASC
  HAS_USER_DESC
  ID_TABLETYPE_ASC
  ID_TABLETYPE_DESC
  NATURAL
  PREFIX_ASC
  PREFIX_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  TYPE_DESCRIPTION_ASC
  TYPE_DESCRIPTION_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
}

"Methods to use when ordering `STable`."
enum STablesOrderBy {
  ID_ASC
  ID_DESC
  ID_TABLETYPE_ASC
  ID_TABLETYPE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  TABLE_DESCRIPTION_ASC
  TABLE_DESCRIPTION_DESC
  TABLE_NAME_ASC
  TABLE_NAME_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
}

"Methods to use when ordering `UsrCapacity`."
enum UsrCapacitiesOrderBy {
  CAPACITY_NOTE_ASC
  CAPACITY_NOTE_DESC
  CAPACITY_SCORE_ASC
  CAPACITY_SCORE_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `UsrDoc`."
enum UsrDocsOrderBy {
  DOC_ATTACHMENT_PATH_ASC
  DOC_ATTACHMENT_PATH_DESC
  DOC_NOTES_ASC
  DOC_NOTES_DESC
  DOC_TITLE_ASC
  DOC_TITLE_DESC
  DOC_URL_PATH_ASC
  DOC_URL_PATH_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DOC_CATEGORY_ASC
  ID_ADM_DOC_CATEGORY_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_DOC_ASC
  ID_USR_DOC_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_PRACTICE_ASC
  ID_USR_PRACTICE_DESC
  ID_USR_STR_ADD_ASC
  ID_USR_STR_ADD_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `UsrDomain`."
enum UsrDomainsOrderBy {
  ADD_OPPORTUNITIES_ASC
  ADD_OPPORTUNITIES_DESC
  ADD_STRENGTHS_ASC
  ADD_STRENGTHS_DESC
  DOMAIN_SCORE_ASC
  DOMAIN_SCORE_DESC
  GAP_CLOSURE_ASC
  GAP_CLOSURE_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  OPPORTUNITIES_ASC
  OPPORTUNITIES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STRENGTHS_ASC
  STRENGTHS_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  THEMES_ASC
  THEMES_DESC
}

"Methods to use when ordering `UsrFocus`."
enum UsrFociOrderBy {
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  ID_USR_FOCUS_ASC
  ID_USR_FOCUS_DESC
  ID_USR_PRACTICE_ASC
  ID_USR_PRACTICE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCHOOL_YEAR_ENDING_ASC
  SCHOOL_YEAR_ENDING_DESC
  SCORE_ASC
  SCORE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `UsrNotify`."
enum UsrNotifiesOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_NOTIFY_ASC
  ID_NOTIFY_DESC
  IS_READ_ASC
  IS_READ_DESC
  LINKED_ID_ASC
  LINKED_ID_DESC
  LINKED_OBJECT_ASC
  LINKED_OBJECT_DESC
  LINKED_USER_ASC
  LINKED_USER_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  READ_RECEIPT_ASC
  READ_RECEIPT_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `UsrPractice`."
enum UsrPracticesOrderBy {
  ID_ACTION_ASC
  ID_ACTION_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_PRACTICE_ASC
  ID_USR_PRACTICE_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PRACTICE_SCORE_ASC
  PRACTICE_SCORE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  UID_PRACTICE_ASC
  UID_PRACTICE_DESC
  UID_STR_ASC
  UID_STR_DESC
}

"Methods to use when ordering `UsrRelationship`."
enum UsrRelationshipsOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  ID_USR_RELATIONSHIP_ASC
  ID_USR_RELATIONSHIP_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `UsrStr`."
enum UsrStrsOrderBy {
  CURRENT_ID_USR_RELATIONSHIP_ASC
  CURRENT_ID_USR_RELATIONSHIP_DESC
  CURRENT_STATUS_ASC
  CURRENT_STATUS_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PERIOD_ASC
  ID_ADM_PERIOD_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_LOG_ASC
  ID_LOG_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  ID_STATUS_ASC
  ID_STATUS_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  ID_USR_STR_NEXT_ASC
  ID_USR_STR_NEXT_DESC
  ID_USR_STR_PREV_ASC
  ID_USR_STR_PREV_DESC
  IS_COMPLETE_ASC
  IS_COMPLETE_DESC
  IS_SCORED_ASC
  IS_SCORED_DESC
  LAST_LOG_ASC
  LAST_LOG_DESC
  NATURAL
  OVERALL_THEMES_ASC
  OVERALL_THEMES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STR_DATE_ASC
  STR_DATE_DESC
  STR_SCORE_ASC
  STR_SCORE_DESC
  STR_SEASON_ASC
  STR_SEASON_DESC
  STR_TEAM_ASC
  STR_TEAM_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_STR_ASC
  UID_STR_DESC
}

"Methods to use when ordering `VwCapacity`."
enum VwCapacitiesOrderBy {
  CAPACITY_DESCRIPTION_ASC
  CAPACITY_DESCRIPTION_DESC
  CAPACITY_EXEMPLAR_ASC
  CAPACITY_EXEMPLAR_DESC
  CAPACITY_NAME_ASC
  CAPACITY_NAME_DESC
  CAPACITY_NOTE_ASC
  CAPACITY_NOTE_DESC
  CAPACITY_SCORE_ASC
  CAPACITY_SCORE_DESC
  CAPACITY_TAG_ASC
  CAPACITY_TAG_DESC
  DOMAIN_NAME_ASC
  DOMAIN_NAME_DESC
  DOMAIN_ORDER_ASC
  DOMAIN_ORDER_DESC
  DOMAIN_SHORT_ASC
  DOMAIN_SHORT_DESC
  DOMAIN_TAG_ASC
  DOMAIN_TAG_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `VwDefaultTemplate`."
enum VwDefaultTemplatesOrderBy {
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_NARRATIVE_ASC
  ID_ADM_NARRATIVE_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  NARRATIVE_NAME_ASC
  NARRATIVE_NAME_DESC
  NARRATIVE_TAGS_ASC
  NARRATIVE_TAGS_DESC
  NATURAL
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  TAGS_ASC
  TAGS_DESC
  TEMPLATE_DESCRIPTION_ASC
  TEMPLATE_DESCRIPTION_DESC
  TEMPLATE_LINK_ASC
  TEMPLATE_LINK_DESC
  TEMPLATE_NAME_ASC
  TEMPLATE_NAME_DESC
  TEMPLATE_TEXT_ASC
  TEMPLATE_TEXT_DESC
}

"Methods to use when ordering `VwDistrict`."
enum VwDistrictsOrderBy {
  DISTRICT_NAME_ASC
  DISTRICT_NAME_DESC
  DISTRICT_NAME_LOCAL_ASC
  DISTRICT_NAME_LOCAL_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STATE_ASC
  STATE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_DISTRICT_ASC
  UID_DISTRICT_DESC
}

"Methods to use when ordering `VwDoc`."
enum VwDocsOrderBy {
  DOC_ATTACHMENT_PATH_ASC
  DOC_ATTACHMENT_PATH_DESC
  DOC_CATEGORY_NAME_ASC
  DOC_CATEGORY_NAME_DESC
  DOC_NOTES_ASC
  DOC_NOTES_DESC
  DOC_TITLE_ASC
  DOC_TITLE_DESC
  DOC_URL_PATH_ASC
  DOC_URL_PATH_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_DOC_CATEGORY_ASC
  ID_ADM_DOC_CATEGORY_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_REVIEW_ASC
  ID_REVIEW_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_DOC_ASC
  ID_USR_DOC_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_PRACTICE_ASC
  ID_USR_PRACTICE_DESC
  ID_USR_STR_ADD_ASC
  ID_USR_STR_ADD_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORT_ORDER_ASC
  SORT_ORDER_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_CREATE_USER_EMAIL_ASC
  S_CREATE_USER_EMAIL_DESC
  S_CREATE_USER_NAME_ASC
  S_CREATE_USER_NAME_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  S_UPDATE_USER_EMAIL_ASC
  S_UPDATE_USER_EMAIL_DESC
  S_UPDATE_USER_NAME_ASC
  S_UPDATE_USER_NAME_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
}

"Methods to use when ordering `VwDomain`."
enum VwDomainsOrderBy {
  ADD_OPPORTUNITIES_ASC
  ADD_OPPORTUNITIES_DESC
  ADD_STRENGTHS_ASC
  ADD_STRENGTHS_DESC
  DOMAIN_DESCRIPTION_ASC
  DOMAIN_DESCRIPTION_DESC
  DOMAIN_GAP_CLOSURE_ASC
  DOMAIN_GAP_CLOSURE_DESC
  DOMAIN_NAME_ASC
  DOMAIN_NAME_DESC
  DOMAIN_ORDER_ASC
  DOMAIN_ORDER_DESC
  DOMAIN_SCORE_ASC
  DOMAIN_SCORE_DESC
  DOMAIN_SHORT_ASC
  DOMAIN_SHORT_DESC
  DOMAIN_TAG_ASC
  DOMAIN_TAG_DESC
  EXEMPLAR_ASC
  EXEMPLAR_DESC
  GAP_CLOSURE_ASC
  GAP_CLOSURE_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  OPPORTUNITIES_ASC
  OPPORTUNITIES_DESC
  STRENGTHS_ASC
  STRENGTHS_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  THEMES_ASC
  THEMES_DESC
}

"Methods to use when ordering `VwEngagementPeriod`."
enum VwEngagementPeriodsOrderBy {
  CURRENT_ID_ADM_USER_ASC
  CURRENT_ID_ADM_USER_DESC
  CURRENT_ID_USR_RELATIONSHIP_ASC
  CURRENT_ID_USR_RELATIONSHIP_DESC
  DISTRICT_NAME_ASC
  DISTRICT_NAME_DESC
  ENGAGEMENT_KIND_ASC
  ENGAGEMENT_KIND_DESC
  ENGAGEMENT_TYPE_ASC
  ENGAGEMENT_TYPE_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PERIOD_ASC
  ID_ADM_PERIOD_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  ID_ENGAGEMENT_KIND_ASC
  ID_ENGAGEMENT_KIND_DESC
  ID_ENGAGEMENT_TYPE_ASC
  ID_ENGAGEMENT_TYPE_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  ID_USR_STR_NEXT_ASC
  ID_USR_STR_NEXT_DESC
  ID_USR_STR_PREV_ASC
  ID_USR_STR_PREV_DESC
  IS_COMPLETE_ASC
  IS_COMPLETE_DESC
  IS_OFFICIAL_RECORD_ASC
  IS_OFFICIAL_RECORD_DESC
  IS_SCORED_ASC
  IS_SCORED_DESC
  NATURAL
  OVERALL_THEMES_ASC
  OVERALL_THEMES_DESC
  PERIOD_NAME_ASC
  PERIOD_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RELATIONSHIP_DESCRIPTION_ASC
  RELATIONSHIP_DESCRIPTION_DESC
  RELATIONSHIP_NAME_ASC
  RELATIONSHIP_NAME_DESC
  RELATION_USER_EMAIL_ASC
  RELATION_USER_EMAIL_DESC
  RELATION_USER_NAME_ASC
  RELATION_USER_NAME_DESC
  SCHOOL_NAME_ASC
  SCHOOL_NAME_DESC
  SCHOOL_YEAR_ENDING_ASC
  SCHOOL_YEAR_ENDING_DESC
  STR_DATE_ASC
  STR_DATE_DESC
  STR_SCORE_ASC
  STR_SCORE_DESC
  STR_SEASON_ASC
  STR_SEASON_DESC
  STR_TEAM_ASC
  STR_TEAM_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
  TYPE_TAG_ASC
  TYPE_TAG_DESC
  UID_STR_ASC
  UID_STR_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
}

"Methods to use when ordering `VwPractice`."
enum VwPracticesOrderBy {
  CAPACITY_DESCRIPTION_ASC
  CAPACITY_DESCRIPTION_DESC
  CAPACITY_NAME_ASC
  CAPACITY_NAME_DESC
  CAPACITY_SCORE_ASC
  CAPACITY_SCORE_DESC
  CAPACITY_TAG_ASC
  CAPACITY_TAG_DESC
  DOMAIN_DESCRIPTION_ASC
  DOMAIN_DESCRIPTION_DESC
  DOMAIN_NAME_ASC
  DOMAIN_NAME_DESC
  DOMAIN_ORDER_ASC
  DOMAIN_ORDER_DESC
  DOMAIN_SCORE_ASC
  DOMAIN_SCORE_DESC
  DOMAIN_SHORT_ASC
  DOMAIN_SHORT_DESC
  DOMAIN_TAG_ASC
  DOMAIN_TAG_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_PRACTICE_ASC
  ID_USR_PRACTICE_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PRACTICE_DESCRIPTION_ASC
  PRACTICE_DESCRIPTION_DESC
  PRACTICE_EXEMPLAR_ASC
  PRACTICE_EXEMPLAR_DESC
  PRACTICE_NAME_ASC
  PRACTICE_NAME_DESC
  PRACTICE_SCORE_ASC
  PRACTICE_SCORE_DESC
  PRACTICE_TAG_ASC
  PRACTICE_TAG_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  UID_PRACTICE_ASC
  UID_PRACTICE_DESC
  UID_STR_ASC
  UID_STR_DESC
}

"Methods to use when ordering `VwRelationship`."
enum VwRelationshipsOrderBy {
  DISPLAY_ORDER_ASC
  DISPLAY_ORDER_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  ID_USR_RELATIONSHIP_ASC
  ID_USR_RELATIONSHIP_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  IMAGE_LINK_ASC
  IMAGE_LINK_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  NEXT_ID_RELATION_ASC
  NEXT_ID_RELATION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RELATIONSHIP_DESCRIPTION_ASC
  RELATIONSHIP_DESCRIPTION_DESC
  RELATIONSHIP_NAME_ASC
  RELATIONSHIP_NAME_DESC
  RELATION_STR_TYPE_ID_ASC
  RELATION_STR_TYPE_ID_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
  USER_SCORE_ASC
  USER_SCORE_DESC
}

"Methods to use when ordering `VwReview`."
enum VwReviewsOrderBy {
  CURRENT_ID_ADM_USER_ASC
  CURRENT_ID_ADM_USER_DESC
  CURRENT_ID_USR_RELATIONSHIP_ASC
  CURRENT_ID_USR_RELATIONSHIP_DESC
  CURRENT_STATUS_ASC
  CURRENT_STATUS_DESC
  DISTRICT_NAME_ASC
  DISTRICT_NAME_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PERIOD_ASC
  ID_ADM_PERIOD_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  ID_ADM_STR_TYPE_ASC
  ID_ADM_STR_TYPE_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  ID_RELATION_ASC
  ID_RELATION_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  ID_STATUS_ASC
  ID_STATUS_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  ID_USR_STR_NEXT_ASC
  ID_USR_STR_NEXT_DESC
  ID_USR_STR_PREV_ASC
  ID_USR_STR_PREV_DESC
  IS_COMPLETE_ASC
  IS_COMPLETE_DESC
  IS_OFFICIAL_RECORD_ASC
  IS_OFFICIAL_RECORD_DESC
  IS_SCORED_ASC
  IS_SCORED_DESC
  NATURAL
  OVERALL_THEMES_ASC
  OVERALL_THEMES_DESC
  PERIOD_NAME_ASC
  PERIOD_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RELATIONSHIP_DESCRIPTION_ASC
  RELATIONSHIP_DESCRIPTION_DESC
  RELATIONSHIP_NAME_ASC
  RELATIONSHIP_NAME_DESC
  RELATION_USER_EMAIL_ASC
  RELATION_USER_EMAIL_DESC
  RELATION_USER_NAME_ASC
  RELATION_USER_NAME_DESC
  RUBRIC_DESCRIPTION_ASC
  RUBRIC_DESCRIPTION_DESC
  RUBRIC_NAME_ASC
  RUBRIC_NAME_DESC
  SCHOOL_NAME_ASC
  SCHOOL_NAME_DESC
  SCHOOL_YEAR_ENDING_ASC
  SCHOOL_YEAR_ENDING_DESC
  STR_DATE_ASC
  STR_DATE_DESC
  STR_SCORE_ASC
  STR_SCORE_DESC
  STR_SEASON_ASC
  STR_SEASON_DESC
  STR_TEAM_ASC
  STR_TEAM_DESC
  STR_YEAR_ASC
  STR_YEAR_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  TYPE_NAME_ASC
  TYPE_NAME_DESC
  TYPE_TAG_ASC
  TYPE_TAG_DESC
  UID_STR_ASC
  UID_STR_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
}

"Methods to use when ordering `VwSchema`."
enum VwSchemasOrderBy {
  CHECKSUM_ASC
  CHECKSUM_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  EXECUTION_TIME_ASC
  EXECUTION_TIME_DESC
  INSTALLED_BY_ASC
  INSTALLED_BY_DESC
  INSTALLED_ON_ASC
  INSTALLED_ON_DESC
  INSTALLED_RANK_ASC
  INSTALLED_RANK_DESC
  NATURAL
  SCRIPT_ASC
  SCRIPT_DESC
  SUCCESS_ASC
  SUCCESS_DESC
  TYPE_ASC
  TYPE_DESC
  VERSION_ASC
  VERSION_DESC
}

"Methods to use when ordering `VwSchool`."
enum VwSchoolsOrderBy {
  DISTRICT_NAME_ASC
  DISTRICT_NAME_DESC
  DISTRICT_NAME_LOCAL_ASC
  DISTRICT_NAME_LOCAL_DESC
  DISTRICT_TAGS_ASC
  DISTRICT_TAGS_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ASC
  ID_DESC
  ID_DISTRICT_NCES_ASC
  ID_DISTRICT_NCES_DESC
  ID_SCHOOL_NCES_ASC
  ID_SCHOOL_NCES_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SCHOOL_NAME_ASC
  SCHOOL_NAME_DESC
  STATE_ASC
  STATE_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  UID_DISTRICT_ASC
  UID_DISTRICT_DESC
  UID_SCHOOL_ASC
  UID_SCHOOL_DESC
}

"Methods to use when ordering `VwSeason`."
enum VwSeasonsOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  NATURAL
  STR_SEASON_ASC
  STR_SEASON_DESC
}

"Methods to use when ordering `VwTestApp`."
enum VwTestAppsOrderBy {
  APP_PREFERENCES_ASC
  APP_PREFERENCES_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  HELP_CALIBRATE_ASC
  HELP_CALIBRATE_DESC
  HELP_FACILITATE_ASC
  HELP_FACILITATE_DESC
  HELP_SCORE_ASC
  HELP_SCORE_DESC
  HELP_SUMMARY_ASC
  HELP_SUMMARY_DESC
  HELP_VIEW_ASC
  HELP_VIEW_DESC
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  NATURAL
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TITLE_ASC
  TITLE_DESC
}

"Methods to use when ordering `VwUser`."
enum VwUsersOrderBy {
  ID_ADM_APP_ASC
  ID_ADM_APP_DESC
  ID_ADM_USER_ASC
  ID_ADM_USER_DESC
  ID_MANAGER_ASC
  ID_MANAGER_DESC
  ID_USER_TYPE_ASC
  ID_USER_TYPE_DESC
  IMAGE_LINK_ASC
  IMAGE_LINK_DESC
  IMAGE_URL_ASC
  IMAGE_URL_DESC
  IS_ACTIVE_ASC
  IS_ACTIVE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
  TAGS_ASC
  TAGS_DESC
  USER_EMAIL_ASC
  USER_EMAIL_DESC
  USER_NAME_ASC
  USER_NAME_DESC
  USER_PREFERENCES_ASC
  USER_PREFERENCES_DESC
  USER_SCORE_ASC
  USER_SCORE_DESC
  USER_TYPE_NOTES_ASC
  USER_TYPE_NOTES_DESC
  USER_TYPE_TITLE_ASC
  USER_TYPE_TITLE_DESC
}

"Methods to use when ordering `_VwAdmCapacityFramework`."
enum _VwAdmCapacityFrameworksOrderBy {
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  NATURAL
}

"Methods to use when ordering `_VwAdmCapacityRubric`."
enum _VwAdmCapacityRubricsOrderBy {
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  NATURAL
}

"Methods to use when ordering `_VwAdmPracticeFramework`."
enum _VwAdmPracticeFrameworksOrderBy {
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  NATURAL
}

"Methods to use when ordering `_VwAdmPracticeFull`."
enum _VwAdmPracticeFullsOrderBy {
  ANALYSIS_NAME_ASC
  ANALYSIS_NAME_DESC
  CAPACITY_DESCRIPTION_ASC
  CAPACITY_DESCRIPTION_DESC
  CAPACITY_NAME_ASC
  CAPACITY_NAME_DESC
  CAPACITY_TAG_ASC
  CAPACITY_TAG_DESC
  DOMAIN_DESCRIPTION_ASC
  DOMAIN_DESCRIPTION_DESC
  DOMAIN_GAP_CLOSURE_ASC
  DOMAIN_GAP_CLOSURE_DESC
  DOMAIN_NAME_ASC
  DOMAIN_NAME_DESC
  DOMAIN_ORDER_ASC
  DOMAIN_ORDER_DESC
  DOMAIN_SHORT_ASC
  DOMAIN_SHORT_DESC
  DOMAIN_TAG_ASC
  DOMAIN_TAG_DESC
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  NATURAL
  PRACTICE_DESCRIPTION_ASC
  PRACTICE_DESCRIPTION_DESC
  PRACTICE_GROUPING_ASC
  PRACTICE_GROUPING_DESC
  PRACTICE_NAME_ASC
  PRACTICE_NAME_DESC
  PRACTICE_TAG_ASC
  PRACTICE_TAG_DESC
  S_CREATE_ASC
  S_CREATE_DESC
  S_CREATE_USER_ASC
  S_CREATE_USER_DESC
  S_UPDATE_ASC
  S_UPDATE_DESC
  S_UPDATE_USER_ASC
  S_UPDATE_USER_DESC
}

"Methods to use when ordering `_VwAdmPracticeRubric`."
enum _VwAdmPracticeRubricsOrderBy {
  ID_ADM_CAPACITY_ASC
  ID_ADM_CAPACITY_DESC
  ID_ADM_DOMAIN_ASC
  ID_ADM_DOMAIN_DESC
  ID_ADM_FRAMEWORK_ASC
  ID_ADM_FRAMEWORK_DESC
  ID_ADM_PRACTICE_ASC
  ID_ADM_PRACTICE_DESC
  ID_ADM_RUBRIC_ASC
  ID_ADM_RUBRIC_DESC
  NATURAL
}

"Methods to use when ordering `_VwCapacityScore`."
enum _VwCapacityScoresOrderBy {
  CAPACITY_SCORE_ASC
  CAPACITY_SCORE_DESC
  ID_USR_CAPACITY_ASC
  ID_USR_CAPACITY_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
}

"Methods to use when ordering `_VwDomainScore`."
enum _VwDomainScoresOrderBy {
  DOMAIN_SCORE_ASC
  DOMAIN_SCORE_DESC
  ID_USR_DOMAIN_ASC
  ID_USR_DOMAIN_DESC
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
}

"Methods to use when ordering `_VwStrScore`."
enum _VwStrScoresOrderBy {
  ID_USR_STR_ASC
  ID_USR_STR_DESC
  NATURAL
  STR_SCORE_ASC
  STR_SCORE_DESC
}

"""

A condition to be used against `AdmAccess` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmAccessCondition {
  "Checks for equality with the objects `idAdmAccess` field."
  idAdmAccess: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idUserType` field."
  idUserType: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmAccess`"
input AdmAccessInput {
  idAdmAccess: Int
  idAdmApp: Int!
  idAdmUser: Int!
  idUserType: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmAccess`. Fields that are set will be updated."
input AdmAccessPatch {
  idAdmAccess: Int
  idAdmApp: Int
  idAdmUser: Int
  idUserType: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A condition to be used against `AdmApp` object types. All fields are tested for equality and combined with a logical and."
input AdmAppCondition {
  "Checks for equality with the objects `appPreferences` field."
  appPreferences: JSON
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `helpCalibrate` field."
  helpCalibrate: String
  "Checks for equality with the objects `helpFacilitate` field."
  helpFacilitate: String
  "Checks for equality with the objects `helpScore` field."
  helpScore: String
  "Checks for equality with the objects `helpSummary` field."
  helpSummary: String
  "Checks for equality with the objects `helpView` field."
  helpView: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `title` field."
  title: String
}

"An input for mutations affecting `AdmApp`"
input AdmAppInput {
  appPreferences: JSON
  description: String
  helpCalibrate: String
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"Represents an update to a `AdmApp`. Fields that are set will be updated."
input AdmAppPatch {
  appPreferences: JSON
  description: String
  helpCalibrate: String
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"""

A condition to be used against `AdmCapacity` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmCapacityCondition {
  "Checks for equality with the objects `capacityDescription` field."
  capacityDescription: String
  "Checks for equality with the objects `capacityExemplar` field."
  capacityExemplar: String
  "Checks for equality with the objects `capacityName` field."
  capacityName: String
  "Checks for equality with the objects `capacityTag` field."
  capacityTag: String
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmCapacity`"
input AdmCapacityInput {
  capacityDescription: String!
  capacityExemplar: String
  capacityName: String!
  capacityTag: String!
  idAdmCapacity: Int
  idAdmDomain: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmCapacity`. Fields that are set will be updated."
input AdmCapacityPatch {
  capacityDescription: String
  capacityExemplar: String
  capacityName: String
  capacityTag: String
  idAdmCapacity: Int
  idAdmDomain: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `AdmDefaultTemplate` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmDefaultTemplateCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDefaultNt` field."
  idAdmDefaultNt: Int
  "Checks for equality with the objects `idAdmNarrative` field."
  idAdmNarrative: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idTemplate` field."
  idTemplate: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmDefaultTemplate`"
input AdmDefaultTemplateInput {
  idAdmApp: Int
  idAdmDefaultNt: Int
  idAdmNarrative: Int!
  idAdmStrType: Int!
  idTemplate: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmDefaultTemplate`. Fields that are set will be updated."
input AdmDefaultTemplatePatch {
  idAdmApp: Int
  idAdmDefaultNt: Int
  idAdmNarrative: Int
  idAdmStrType: Int
  idTemplate: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `AdmDistrikt` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmDistriktCondition {
  "Checks for equality with the objects `districtAbbr` field."
  districtAbbr: String
  "Checks for equality with the objects `districtName` field."
  districtName: String
  "Checks for equality with the objects `districtNameLocal` field."
  districtNameLocal: String
  "Checks for equality with the objects `emailManager` field."
  emailManager: String
  "Checks for equality with the objects `emailStaff` field."
  emailStaff: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `regionName` field."
  regionName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `state` field."
  state: String
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidDistrict` field."
  uidDistrict: String
}

"An input for mutations affecting `AdmDistrikt`"
input AdmDistriktInput {
  districtAbbr: String
  districtName: String
  districtNameLocal: String
  emailManager: String
  emailStaff: String
  idAdmApp: Int
  idDistrictNces: Int!
  isActive: Boolean
  regionName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
}

"Represents an update to a `AdmDistrikt`. Fields that are set will be updated."
input AdmDistriktPatch {
  districtAbbr: String
  districtName: String
  districtNameLocal: String
  emailManager: String
  emailStaff: String
  idAdmApp: Int
  idDistrictNces: Int
  isActive: Boolean
  regionName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
}

"""

A condition to be used against `AdmDocCategory` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmDocCategoryCondition {
  "Checks for equality with the objects `docCategoryName` field."
  docCategoryName: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDocCategory` field."
  idAdmDocCategory: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
}

"An input for mutations affecting `AdmDocCategory`"
input AdmDocCategoryInput {
  docCategoryName: String
  idAdmApp: Int!
  idAdmDocCategory: Int
  idAdmStrType: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

"Represents an update to a `AdmDocCategory`. Fields that are set will be updated."
input AdmDocCategoryPatch {
  docCategoryName: String
  idAdmApp: Int
  idAdmDocCategory: Int
  idAdmStrType: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

"""

A condition to be used against `AdmDocSuggest` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmDocSuggestCondition {
  "Checks for equality with the objects `docNotes` field."
  docNotes: Int
  "Checks for equality with the objects `docTitle` field."
  docTitle: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDocCategory` field."
  idAdmDocCategory: Int
  "Checks for equality with the objects `idAdmDocSuggest` field."
  idAdmDocSuggest: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
}

"An input for mutations affecting `AdmDocSuggest`"
input AdmDocSuggestInput {
  docNotes: Int
  docTitle: String!
  idAdmApp: Int!
  idAdmDocCategory: Int!
  idAdmDocSuggest: Int
  idAdmStrType: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

"Represents an update to a `AdmDocSuggest`. Fields that are set will be updated."
input AdmDocSuggestPatch {
  docNotes: Int
  docTitle: String
  idAdmApp: Int
  idAdmDocCategory: Int
  idAdmDocSuggest: Int
  idAdmStrType: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
}

"""

A condition to be used against `AdmDomain` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmDomainCondition {
  "Checks for equality with the objects `domainDescription` field."
  domainDescription: String
  "Checks for equality with the objects `domainGapClosure` field."
  domainGapClosure: BigFloat
  "Checks for equality with the objects `domainName` field."
  domainName: String
  "Checks for equality with the objects `domainOrder` field."
  domainOrder: Int
  "Checks for equality with the objects `domainShort` field."
  domainShort: String
  "Checks for equality with the objects `domainTag` field."
  domainTag: String
  "Checks for equality with the objects `exemplar` field."
  exemplar: String
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmDomain`"
input AdmDomainInput {
  domainDescription: String!
  domainGapClosure: BigFloat
  domainName: String!
  domainOrder: Int
  domainShort: String
  domainTag: String
  exemplar: String
  idAdmDomain: Int
  idAdmFramework: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmDomain`. Fields that are set will be updated."
input AdmDomainPatch {
  domainDescription: String
  domainGapClosure: BigFloat
  domainName: String
  domainOrder: Int
  domainShort: String
  domainTag: String
  exemplar: String
  idAdmDomain: Int
  idAdmFramework: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `AdmEngagement` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmEngagementCondition {
  "Checks for equality with the objects `engagementKind` field."
  engagementKind: String
  "Checks for equality with the objects `engagementType` field."
  engagementType: String
  "Checks for equality with the objects `idAdmEngagement` field."
  idAdmEngagement: Int
  "Checks for equality with the objects `idEngagementKind` field."
  idEngagementKind: Int
  "Checks for equality with the objects `idEngagementType` field."
  idEngagementType: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolYearEnding` field."
  schoolYearEnding: Int
}

"An input for mutations affecting `AdmEngagement`"
input AdmEngagementInput {
  engagementKind: String
  engagementType: String
  idAdmEngagement: Int
  idEngagementKind: Int
  idEngagementType: Int
  idSchoolNces: BigInt!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int!
}

"Represents an update to a `AdmEngagement`. Fields that are set will be updated."
input AdmEngagementPatch {
  engagementKind: String
  engagementType: String
  idAdmEngagement: Int
  idEngagementKind: Int
  idEngagementType: Int
  idSchoolNces: BigInt
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int
}

"""

A condition to be used against `AdmFramework` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmFrameworkCondition {
  "Checks for equality with the objects `effectiveDate` field."
  effectiveDate: Datetime
  "Checks for equality with the objects `endDate` field."
  endDate: Datetime
  "Checks for equality with the objects `frameworkName` field."
  frameworkName: String
  "Checks for equality with the objects `frameworkVersion` field."
  frameworkVersion: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmScale` field."
  idAdmScale: Int
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `tags` field."
  tags: String
}

"An input for mutations affecting `AdmFramework`"
input AdmFrameworkInput {
  effectiveDate: Datetime
  endDate: Datetime
  frameworkName: String
  frameworkVersion: Int
  idAdmApp: Int
  idAdmFramework: Int
  idAdmScale: Int
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
}

"Represents an update to a `AdmFramework`. Fields that are set will be updated."
input AdmFrameworkPatch {
  effectiveDate: Datetime
  endDate: Datetime
  frameworkName: String
  frameworkVersion: Int
  idAdmApp: Int
  idAdmFramework: Int
  idAdmScale: Int
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
}

"""

A condition to be used against `AdmNarrative` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmNarrativeCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmNarrative` field."
  idAdmNarrative: Int
  "Checks for equality with the objects `narrativeName` field."
  narrativeName: String
  "Checks for equality with the objects `narrativeTags` field."
  narrativeTags: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `trialTags` field."
  trialTags: [String]
}

"An input for mutations affecting `AdmNarrative`"
input AdmNarrativeInput {
  idAdmApp: Int!
  idAdmDomain: Int
  idAdmNarrative: Int
  narrativeName: String
  narrativeTags: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  trialTags: [String]
}

"Represents an update to a `AdmNarrative`. Fields that are set will be updated."
input AdmNarrativePatch {
  idAdmApp: Int
  idAdmDomain: Int
  idAdmNarrative: Int
  narrativeName: String
  narrativeTags: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  trialTags: [String]
}

"""

A condition to be used against `AdmPeriod` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmPeriodCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmPeriod` field."
  idAdmPeriod: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `periodEndMonth` field."
  periodEndMonth: Int
  "Checks for equality with the objects `periodName` field."
  periodName: String
  "Checks for equality with the objects `periodStartMonth` field."
  periodStartMonth: Int
  "Checks for equality with the objects `periodTag` field."
  periodTag: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `startsNewSequence` field."
  startsNewSequence: Boolean
}

"An input for mutations affecting `AdmPeriod`"
input AdmPeriodInput {
  idAdmApp: Int
  idAdmPeriod: Int
  idAdmStrType: Int
  periodEndMonth: Int!
  periodName: String!
  periodStartMonth: Int!
  periodTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  startsNewSequence: Boolean
}

"Represents an update to a `AdmPeriod`. Fields that are set will be updated."
input AdmPeriodPatch {
  idAdmApp: Int
  idAdmPeriod: Int
  idAdmStrType: Int
  periodEndMonth: Int
  periodName: String
  periodStartMonth: Int
  periodTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  startsNewSequence: Boolean
}

"""

A condition to be used against `AdmPractice` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmPracticeCondition {
  "Checks for equality with the objects `analysisName` field."
  analysisName: String
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `practiceDescription` field."
  practiceDescription: String
  "Checks for equality with the objects `practiceExemplar` field."
  practiceExemplar: String
  "Checks for equality with the objects `practiceGrouping` field."
  practiceGrouping: String
  "Checks for equality with the objects `practiceName` field."
  practiceName: String
  "Checks for equality with the objects `practiceTag` field."
  practiceTag: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidPractice` field."
  uidPractice: String
}

"An input for mutations affecting `AdmPractice`"
input AdmPracticeInput {
  analysisName: String
  idAdmCapacity: Int!
  idAdmFramework: Int
  idAdmPractice: Int
  practiceDescription: String!
  practiceExemplar: String
  practiceGrouping: String
  practiceName: String!
  practiceTag: String!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
  uidPractice: String
}

"Represents an update to a `AdmPractice`. Fields that are set will be updated."
input AdmPracticePatch {
  analysisName: String
  idAdmCapacity: Int
  idAdmFramework: Int
  idAdmPractice: Int
  practiceDescription: String
  practiceExemplar: String
  practiceGrouping: String
  practiceName: String
  practiceTag: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
  uidPractice: String
}

"""

A condition to be used against `AdmRubric` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmRubricCondition {
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
  "Checks for equality with the objects `rubricDescription` field."
  rubricDescription: String
  "Checks for equality with the objects `rubricName` field."
  rubricName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `tags` field."
  tags: String
}

"An input for mutations affecting `AdmRubric`"
input AdmRubricInput {
  idAdmFramework: Int!
  idAdmRubric: Int
  rubricDescription: String!
  rubricName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
}

"""

A condition to be used against `AdmRubricMap` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmRubricMapCondition {
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
  "Checks for equality with the objects `idAdmRubricMap` field."
  idAdmRubricMap: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmRubricMap`"
input AdmRubricMapInput {
  idAdmPractice: Int!
  idAdmRubric: Int!
  idAdmRubricMap: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmRubricMap`. Fields that are set will be updated."
input AdmRubricMapPatch {
  idAdmPractice: Int
  idAdmRubric: Int
  idAdmRubricMap: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmRubric`. Fields that are set will be updated."
input AdmRubricPatch {
  idAdmFramework: Int
  idAdmRubric: Int
  rubricDescription: String
  rubricName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  tags: String
}

"""

A condition to be used against `AdmScale` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmScaleCondition {
  "Checks for equality with the objects `displayOrder` field."
  displayOrder: Int
  "Checks for equality with the objects `idAdmScale` field."
  idAdmScale: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `scaleDescription` field."
  scaleDescription: String
  "Checks for equality with the objects `scaleGraphicUrl` field."
  scaleGraphicUrl: String
  "Checks for equality with the objects `scaleName` field."
  scaleName: String
}

"An input for mutations affecting `AdmScale`"
input AdmScaleInput {
  displayOrder: Int
  idAdmScale: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scaleDescription: String
  scaleGraphicUrl: String
  scaleName: String
}

"Represents an update to a `AdmScale`. Fields that are set will be updated."
input AdmScalePatch {
  displayOrder: Int
  idAdmScale: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scaleDescription: String
  scaleGraphicUrl: String
  scaleName: String
}

"""

A condition to be used against `AdmScore` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmScoreCondition {
  "Checks for equality with the objects `consistency` field."
  consistency: String
  "Checks for equality with the objects `displayOrder` field."
  displayOrder: Int
  "Checks for equality with the objects `frequency` field."
  frequency: String
  "Checks for equality with the objects `idAdmScale` field."
  idAdmScale: Int
  "Checks for equality with the objects `idAdmScore` field."
  idAdmScore: Int
  "Checks for equality with the objects `intentionality` field."
  intentionality: String
  "Checks for equality with the objects `ownership` field."
  ownership: String
  "Checks for equality with the objects `quality` field."
  quality: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `scoreDescription` field."
  scoreDescription: String
  "Checks for equality with the objects `scoreName` field."
  scoreName: String
  "Checks for equality with the objects `scoreValue` field."
  scoreValue: Int
}

"An input for mutations affecting `AdmScore`"
input AdmScoreInput {
  consistency: String
  displayOrder: Int
  frequency: String
  idAdmScale: Int
  idAdmScore: Int
  intentionality: String
  ownership: String
  quality: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scoreDescription: String
  scoreName: String
  scoreValue: Int
}

"Represents an update to a `AdmScore`. Fields that are set will be updated."
input AdmScorePatch {
  consistency: String
  displayOrder: Int
  frequency: String
  idAdmScale: Int
  idAdmScore: Int
  intentionality: String
  ownership: String
  quality: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  scoreDescription: String
  scoreName: String
  scoreValue: Int
}

"""

A condition to be used against `AdmSkool` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmSkoolCondition {
  "Checks for equality with the objects `emailManager` field."
  emailManager: String
  "Checks for equality with the objects `emailStaff` field."
  emailStaff: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolName` field."
  schoolName: String
  "Checks for equality with the objects `schoolNameLocal` field."
  schoolNameLocal: String
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidSchool` field."
  uidSchool: String
}

"An input for mutations affecting `AdmSkool`"
input AdmSkoolInput {
  emailManager: String
  emailStaff: String
  id: Int
  idAdmApp: Int
  idAdmUser: Int
  idDistrictNces: Int
  idSchoolNces: BigInt!
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  schoolNameLocal: String
  tags: String
  uidSchool: String
}

"Represents an update to a `AdmSkool`. Fields that are set will be updated."
input AdmSkoolPatch {
  emailManager: String
  emailStaff: String
  id: Int
  idAdmApp: Int
  idAdmUser: Int
  idDistrictNces: Int
  idSchoolNces: BigInt
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolName: String
  schoolNameLocal: String
  tags: String
  uidSchool: String
}

"""

A condition to be used against `AdmStrSequence` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmStrSequenceCondition {
  "Checks for equality with the objects `idAdmStrSequence` field."
  idAdmStrSequence: Int
  "Checks for equality with the objects `idUserStrPrev` field."
  idUserStrPrev: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrNext` field."
  idUsrStrNext: Int
  "Checks for equality with the objects `reason` field."
  reason: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmStrSequence`"
input AdmStrSequenceInput {
  idAdmStrSequence: Int
  idUserStrPrev: Int
  "first str in the sequence!"
  idUsrStr: Int
  idUsrStrNext: Int
  reason: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmStrSequence`. Fields that are set will be updated."
input AdmStrSequencePatch {
  idAdmStrSequence: Int
  idUserStrPrev: Int
  "first str in the sequence!"
  idUsrStr: Int
  idUsrStrNext: Int
  reason: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `AdmStrType` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmStrTypeCondition {
  "Checks for equality with the objects `contributeToStrType` field."
  contributeToStrType: Int
  "Checks for equality with the objects `editAction` field."
  editAction: String
  "Checks for equality with the objects `hasGoals` field."
  hasGoals: Boolean
  "Checks for equality with the objects `hasPeriod` field."
  hasPeriod: Boolean
  "Checks for equality with the objects `hasSchool` field."
  hasSchool: Boolean
  "Checks for equality with the objects `hasSummary` field."
  hasSummary: Boolean
  "Checks for equality with the objects `helpFacilitate` field."
  helpFacilitate: String
  "Checks for equality with the objects `helpScore` field."
  helpScore: String
  "Checks for equality with the objects `helpSummary` field."
  helpSummary: String
  "Checks for equality with the objects `helpView` field."
  helpView: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idObject` field."
  idObject: Int
  "Checks for equality with the objects `initialIdRelation` field."
  initialIdRelation: Int
  "Checks for equality with the objects `isCalibrated` field."
  isCalibrated: Boolean
  "Checks for equality with the objects `isExported` field."
  isExported: Boolean
  "Checks for equality with the objects `isOfficialRecord` field."
  isOfficialRecord: Boolean
  "Checks for equality with the objects `nextStrType` field."
  nextStrType: Int
  "Checks for equality with the objects `prevStrType` field."
  prevStrType: Int
  "Checks for equality with the objects `printAction` field."
  printAction: String
  "Checks for equality with the objects `requireBaseline` field."
  requireBaseline: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
  "Checks for equality with the objects `summaryAction` field."
  summaryAction: String
  "Checks for equality with the objects `typeDescription` field."
  typeDescription: String
  "Checks for equality with the objects `typeIcon` field."
  typeIcon: String
  "Checks for equality with the objects `typeName` field."
  typeName: String
  "Checks for equality with the objects `typeTag` field."
  typeTag: String
  "Checks for equality with the objects `viewAction` field."
  viewAction: String
}

"An input for mutations affecting `AdmStrType`"
input AdmStrTypeInput {
  contributeToStrType: Int
  editAction: String
  hasGoals: Boolean
  hasPeriod: Boolean
  hasSchool: Boolean
  hasSummary: Boolean
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmStrType: Int
  idObject: Int
  initialIdRelation: Int
  isCalibrated: Boolean
  isExported: Boolean
  isOfficialRecord: Boolean
  nextStrType: Int
  prevStrType: Int
  printAction: String
  requireBaseline: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  summaryAction: String
  typeDescription: String
  typeIcon: String
  typeName: String
  typeTag: String
  viewAction: String
}

"""

A condition to be used against `AdmStrTypeMap` object types. All fields are
tested for equality and combined with a logical and.
"""
input AdmStrTypeMapCondition {
  "Checks for equality with the objects `displayOrder` field."
  displayOrder: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idAdmStrTypeMap` field."
  idAdmStrTypeMap: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `nextIdRelation` field."
  nextIdRelation: Int
  "Checks for equality with the objects `relationStrTypeId` field."
  relationStrTypeId: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `AdmStrTypeMap`"
input AdmStrTypeMapInput {
  displayOrder: Int
  idAdmApp: Int
  idAdmStrType: Int
  idAdmStrTypeMap: Int
  idRelation: Int
  nextIdRelation: Int
  relationStrTypeId: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmStrTypeMap`. Fields that are set will be updated."
input AdmStrTypeMapPatch {
  displayOrder: Int
  idAdmApp: Int
  idAdmStrType: Int
  idAdmStrTypeMap: Int
  idRelation: Int
  nextIdRelation: Int
  relationStrTypeId: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `AdmStrType`. Fields that are set will be updated."
input AdmStrTypePatch {
  contributeToStrType: Int
  editAction: String
  hasGoals: Boolean
  hasPeriod: Boolean
  hasSchool: Boolean
  hasSummary: Boolean
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmStrType: Int
  idObject: Int
  initialIdRelation: Int
  isCalibrated: Boolean
  isExported: Boolean
  isOfficialRecord: Boolean
  nextStrType: Int
  prevStrType: Int
  printAction: String
  requireBaseline: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  summaryAction: String
  typeDescription: String
  typeIcon: String
  typeName: String
  typeTag: String
  viewAction: String
}

"""

A condition to be used against `AdmTemplate` object types. All fields are tested
for equality and combined with a logical and.
"""
input AdmTemplateCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idTemplate` field."
  idTemplate: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `templateDescription` field."
  templateDescription: String
  "Checks for equality with the objects `templateLink` field."
  templateLink: String
  "Checks for equality with the objects `templateName` field."
  templateName: String
  "Checks for equality with the objects `templateText` field."
  templateText: String
}

"An input for mutations affecting `AdmTemplate`"
input AdmTemplateInput {
  idAdmApp: Int!
  idTemplate: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  tags: String
  templateDescription: String
  templateLink: String
  templateName: String!
  templateText: String!
}

"Represents an update to a `AdmTemplate`. Fields that are set will be updated."
input AdmTemplatePatch {
  idAdmApp: Int
  idTemplate: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  sortOrder: Int
  tags: String
  templateDescription: String
  templateLink: String
  templateName: String
  templateText: String
}

"A condition to be used against `AdmUser` object types. All fields are tested for equality and combined with a logical and."
input AdmUserCondition {
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idManager` field."
  idManager: Int
  "Checks for equality with the objects `imageLink` field."
  imageLink: String
  "Checks for equality with the objects `imageUrl` field."
  imageUrl: String
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `spare` field."
  spare: Int
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
  "Checks for equality with the objects `userPreferences` field."
  userPreferences: JSON
  "Checks for equality with the objects `userScore` field."
  userScore: Int
}

"An input for mutations affecting `AdmUser`"
input AdmUserInput {
  idAdmUser: Int
  idManager: Int
  imageLink: String
  imageUrl: String
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  spare: Int
  tags: String
  userEmail: String
  userName: String
  userPreferences: JSON
  userScore: Int
}

"Represents an update to a `AdmUser`. Fields that are set will be updated."
input AdmUserPatch {
  idAdmUser: Int
  idManager: Int
  imageLink: String
  imageUrl: String
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  spare: Int
  tags: String
  userEmail: String
  userName: String
  userPreferences: JSON
  userScore: Int
}

"All input for the create `AdmAccess` mutation."
input CreateAdmAccessInput {
  "The `AdmAccess` to be created by this mutation."
  admAccess: AdmAccessInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmApp` mutation."
input CreateAdmAppInput {
  "The `AdmApp` to be created by this mutation."
  admApp: AdmAppInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmCapacity` mutation."
input CreateAdmCapacityInput {
  "The `AdmCapacity` to be created by this mutation."
  admCapacity: AdmCapacityInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmDefaultTemplate` mutation."
input CreateAdmDefaultTemplateInput {
  "The `AdmDefaultTemplate` to be created by this mutation."
  admDefaultTemplate: AdmDefaultTemplateInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmDistrikt` mutation."
input CreateAdmDistriktInput {
  "The `AdmDistrikt` to be created by this mutation."
  admDistrikt: AdmDistriktInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmDocCategory` mutation."
input CreateAdmDocCategoryInput {
  "The `AdmDocCategory` to be created by this mutation."
  admDocCategory: AdmDocCategoryInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmDocSuggest` mutation."
input CreateAdmDocSuggestInput {
  "The `AdmDocSuggest` to be created by this mutation."
  admDocSuggest: AdmDocSuggestInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmDomain` mutation."
input CreateAdmDomainInput {
  "The `AdmDomain` to be created by this mutation."
  admDomain: AdmDomainInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmEngagement` mutation."
input CreateAdmEngagementInput {
  "The `AdmEngagement` to be created by this mutation."
  admEngagement: AdmEngagementInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmFramework` mutation."
input CreateAdmFrameworkInput {
  "The `AdmFramework` to be created by this mutation."
  admFramework: AdmFrameworkInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmNarrative` mutation."
input CreateAdmNarrativeInput {
  "The `AdmNarrative` to be created by this mutation."
  admNarrative: AdmNarrativeInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmPeriod` mutation."
input CreateAdmPeriodInput {
  "The `AdmPeriod` to be created by this mutation."
  admPeriod: AdmPeriodInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmPractice` mutation."
input CreateAdmPracticeInput {
  "The `AdmPractice` to be created by this mutation."
  admPractice: AdmPracticeInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmRubric` mutation."
input CreateAdmRubricInput {
  "The `AdmRubric` to be created by this mutation."
  admRubric: AdmRubricInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmRubricMap` mutation."
input CreateAdmRubricMapInput {
  "The `AdmRubricMap` to be created by this mutation."
  admRubricMap: AdmRubricMapInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmScale` mutation."
input CreateAdmScaleInput {
  "The `AdmScale` to be created by this mutation."
  admScale: AdmScaleInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmScore` mutation."
input CreateAdmScoreInput {
  "The `AdmScore` to be created by this mutation."
  admScore: AdmScoreInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmSkool` mutation."
input CreateAdmSkoolInput {
  "The `AdmSkool` to be created by this mutation."
  admSkool: AdmSkoolInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmStrSequence` mutation."
input CreateAdmStrSequenceInput {
  "The `AdmStrSequence` to be created by this mutation."
  admStrSequence: AdmStrSequenceInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmStrType` mutation."
input CreateAdmStrTypeInput {
  "The `AdmStrType` to be created by this mutation."
  admStrType: AdmStrTypeInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmStrTypeMap` mutation."
input CreateAdmStrTypeMapInput {
  "The `AdmStrTypeMap` to be created by this mutation."
  admStrTypeMap: AdmStrTypeMapInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmTemplate` mutation."
input CreateAdmTemplateInput {
  "The `AdmTemplate` to be created by this mutation."
  admTemplate: AdmTemplateInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `AdmUser` mutation."
input CreateAdmUserInput {
  "The `AdmUser` to be created by this mutation."
  admUser: AdmUserInput!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"All input for the create `FlywaySchemaHistory` mutation."
input CreateFlywaySchemaHistoryInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `FlywaySchemaHistory` to be created by this mutation."
  flywaySchemaHistory: FlywaySchemaHistoryInput!
}

"All input for the create `Post` mutation."
input CreatePostInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `Post` to be created by this mutation."
  post: PostInput!
}

"All input for the create `RefObject` mutation."
input CreateRefObjectInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `RefObject` to be created by this mutation."
  refObject: RefObjectInput!
}

"All input for the create `RefRelation` mutation."
input CreateRefRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `RefRelation` to be created by this mutation."
  refRelation: RefRelationInput!
}

"All input for the create `RefStatus` mutation."
input CreateRefStatusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `RefStatus` to be created by this mutation."
  refStatus: RefStatusInput!
}

"All input for the create `RefUserType` mutation."
input CreateRefUserTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `RefUserType` to be created by this mutation."
  refUserType: RefUserTypeInput!
}

"All input for the create `SActivity` mutation."
input CreateSActivityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `SActivity` to be created by this mutation."
  sActivity: SActivityInput!
}

"All input for the create `SErr` mutation."
input CreateSErrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `SErr` to be created by this mutation."
  sErr: SErrInput!
}

"All input for the create `SLogCode` mutation."
input CreateSLogCodeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `SLogCode` to be created by this mutation."
  sLogCode: SLogCodeInput!
}

"All input for the create `SLogDetail` mutation."
input CreateSLogDetailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `SLogDetail` to be created by this mutation."
  sLogDetail: SLogDetailInput!
}

"All input for the create `SLog` mutation."
input CreateSLogInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `SLog` to be created by this mutation."
  sLog: SLogInput!
}

"All input for the create `STable` mutation."
input CreateSTableInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `STable` to be created by this mutation."
  sTable: STableInput!
}

"All input for the create `STableType` mutation."
input CreateSTableTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `STableType` to be created by this mutation."
  sTableType: STableTypeInput!
}

"All input for the create `UsrCapacity` mutation."
input CreateUsrCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrCapacity` to be created by this mutation."
  usrCapacity: UsrCapacityInput!
}

"All input for the create `UsrDoc` mutation."
input CreateUsrDocInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrDoc` to be created by this mutation."
  usrDoc: UsrDocInput!
}

"All input for the create `UsrDomain` mutation."
input CreateUsrDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrDomain` to be created by this mutation."
  usrDomain: UsrDomainInput!
}

"All input for the create `UsrFocus` mutation."
input CreateUsrFocusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrFocus` to be created by this mutation."
  usrFocus: UsrFocusInput!
}

"All input for the create `UsrNotify` mutation."
input CreateUsrNotifyInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrNotify` to be created by this mutation."
  usrNotify: UsrNotifyInput!
}

"All input for the create `UsrPractice` mutation."
input CreateUsrPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrPractice` to be created by this mutation."
  usrPractice: UsrPracticeInput!
}

"All input for the create `UsrRelationship` mutation."
input CreateUsrRelationshipInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrRelationship` to be created by this mutation."
  usrRelationship: UsrRelationshipInput!
}

"All input for the create `UsrStr` mutation."
input CreateUsrStrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `UsrStr` to be created by this mutation."
  usrStr: UsrStrInput!
}

"All input for the create `VwDistrict` mutation."
input CreateVwDistrictInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `VwDistrict` to be created by this mutation."
  vwDistrict: VwDistrictInput!
}

"All input for the create `VwTestApp` mutation."
input CreateVwTestAppInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The `VwTestApp` to be created by this mutation."
  vwTestApp: VwTestAppInput!
}

"All input for the `currentreviewer` mutation."
input CurrentreviewerInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idstr: Int
}

"All input for the `currentreviewuser` mutation."
input CurrentreviewuserInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idstr: Int
}

"All input for the `deleteAdmAccessByIdAdmAccess` mutation."
input DeleteAdmAccessByIdAdmAccessInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmAccess: Int!
}

"All input for the `deleteAdmAccess` mutation."
input DeleteAdmAccessInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmAccess` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmAppByIdAdmApp` mutation."
input DeleteAdmAppByIdAdmAppInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmApp: Int!
}

"All input for the `deleteAdmApp` mutation."
input DeleteAdmAppInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmApp` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmCapacityByIdAdmCapacityAndIdAdmDomain` mutation."
input DeleteAdmCapacityByIdAdmCapacityAndIdAdmDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmCapacity: Int!
  idAdmDomain: Int!
}

"All input for the `deleteAdmCapacityByIdAdmCapacity` mutation."
input DeleteAdmCapacityByIdAdmCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmCapacity: Int!
}

"All input for the `deleteAdmCapacity` mutation."
input DeleteAdmCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmCapacity` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmDefaultTemplateByIdAdmDefaultNt` mutation."
input DeleteAdmDefaultTemplateByIdAdmDefaultNtInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDefaultNt: Int!
}

"All input for the `deleteAdmDefaultTemplate` mutation."
input DeleteAdmDefaultTemplateInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDefaultTemplate` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmDistriktByIdDistrictNces` mutation."
input DeleteAdmDistriktByIdDistrictNcesInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idDistrictNces: Int!
}

"All input for the `deleteAdmDistrikt` mutation."
input DeleteAdmDistriktInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDistrikt` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmDocCategoryByIdAdmDocCategory` mutation."
input DeleteAdmDocCategoryByIdAdmDocCategoryInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDocCategory: Int!
}

"All input for the `deleteAdmDocCategory` mutation."
input DeleteAdmDocCategoryInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDocCategory` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmDocSuggestByIdAdmDocSuggest` mutation."
input DeleteAdmDocSuggestByIdAdmDocSuggestInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDocSuggest: Int!
}

"All input for the `deleteAdmDocSuggest` mutation."
input DeleteAdmDocSuggestInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDocSuggest` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmDomainByIdAdmDomainAndIdAdmFramework` mutation."
input DeleteAdmDomainByIdAdmDomainAndIdAdmFrameworkInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDomain: Int!
  idAdmFramework: Int!
}

"All input for the `deleteAdmDomainByIdAdmDomain` mutation."
input DeleteAdmDomainByIdAdmDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDomain: Int!
}

"All input for the `deleteAdmDomain` mutation."
input DeleteAdmDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDomain` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmEngagementByIdAdmEngagement` mutation."
input DeleteAdmEngagementByIdAdmEngagementInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmEngagement: Int!
}

"All input for the `deleteAdmEngagement` mutation."
input DeleteAdmEngagementInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmEngagement` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmFrameworkByIdAdmFramework` mutation."
input DeleteAdmFrameworkByIdAdmFrameworkInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmFramework: Int!
}

"All input for the `deleteAdmFramework` mutation."
input DeleteAdmFrameworkInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmFramework` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmNarrativeByIdAdmNarrative` mutation."
input DeleteAdmNarrativeByIdAdmNarrativeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmNarrative: Int!
}

"All input for the `deleteAdmNarrative` mutation."
input DeleteAdmNarrativeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmNarrative` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmPeriodByIdAdmPeriod` mutation."
input DeleteAdmPeriodByIdAdmPeriodInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmPeriod: Int!
}

"All input for the `deleteAdmPeriod` mutation."
input DeleteAdmPeriodInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmPeriod` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmPracticeByIdAdmPractice` mutation."
input DeleteAdmPracticeByIdAdmPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmPractice: Int!
}

"All input for the `deleteAdmPractice` mutation."
input DeleteAdmPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmPractice` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmRubricByIdAdmRubric` mutation."
input DeleteAdmRubricByIdAdmRubricInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmRubric: Int!
}

"All input for the `deleteAdmRubric` mutation."
input DeleteAdmRubricInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmRubric` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmRubricMapByIdAdmRubricMap` mutation."
input DeleteAdmRubricMapByIdAdmRubricMapInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmRubricMap: Int!
}

"All input for the `deleteAdmRubricMap` mutation."
input DeleteAdmRubricMapInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmRubricMap` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmScaleByIdAdmScale` mutation."
input DeleteAdmScaleByIdAdmScaleInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmScale: Int!
}

"All input for the `deleteAdmScale` mutation."
input DeleteAdmScaleInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmScale` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmScoreByIdAdmScore` mutation."
input DeleteAdmScoreByIdAdmScoreInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmScore: Int!
}

"All input for the `deleteAdmScore` mutation."
input DeleteAdmScoreInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmScore` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmSkoolByIdSchoolNces` mutation."
input DeleteAdmSkoolByIdSchoolNcesInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idSchoolNces: BigInt!
}

"All input for the `deleteAdmSkool` mutation."
input DeleteAdmSkoolInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmSkool` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmStrSequenceByIdAdmStrSequence` mutation."
input DeleteAdmStrSequenceByIdAdmStrSequenceInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrSequence: Int!
}

"All input for the `deleteAdmStrSequence` mutation."
input DeleteAdmStrSequenceInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrSequence` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmStrTypeByIdAdmStrType` mutation."
input DeleteAdmStrTypeByIdAdmStrTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrType: Int!
}

"All input for the `deleteAdmStrType` mutation."
input DeleteAdmStrTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrType` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmStrTypeMapByIdAdmStrTypeMap` mutation."
input DeleteAdmStrTypeMapByIdAdmStrTypeMapInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrTypeMap: Int!
}

"All input for the `deleteAdmStrTypeMap` mutation."
input DeleteAdmStrTypeMapInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrTypeMap` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmTemplateByIdTemplate` mutation."
input DeleteAdmTemplateByIdTemplateInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idTemplate: Int!
}

"All input for the `deleteAdmTemplate` mutation."
input DeleteAdmTemplateInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmTemplate` to be deleted."
  nodeId: ID!
}

"All input for the `deleteAdmUserByIdAdmUser` mutation."
input DeleteAdmUserByIdAdmUserInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmUser: Int!
}

"All input for the `deleteAdmUser` mutation."
input DeleteAdmUserInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmUser` to be deleted."
  nodeId: ID!
}

"All input for the `deleteFlywaySchemaHistoryByInstalledRank` mutation."
input DeleteFlywaySchemaHistoryByInstalledRankInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  installedRank: Int!
}

"All input for the `deleteFlywaySchemaHistory` mutation."
input DeleteFlywaySchemaHistoryInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `FlywaySchemaHistory` to be deleted."
  nodeId: ID!
}

"All input for the `deletePostById` mutation."
input DeletePostByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"All input for the `deletePost` mutation."
input DeletePostInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Post` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRefObjectByIdObject` mutation."
input DeleteRefObjectByIdObjectInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idObject: Int!
}

"All input for the `deleteRefObject` mutation."
input DeleteRefObjectInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefObject` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRefRelationByIdRelation` mutation."
input DeleteRefRelationByIdRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idRelation: Int!
}

"All input for the `deleteRefRelation` mutation."
input DeleteRefRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefRelation` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRefStatusByIdStatus` mutation."
input DeleteRefStatusByIdStatusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idStatus: Int!
}

"All input for the `deleteRefStatus` mutation."
input DeleteRefStatusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefStatus` to be deleted."
  nodeId: ID!
}

"All input for the `deleteRefUserTypeByIdUserType` mutation."
input DeleteRefUserTypeByIdUserTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUserType: Int!
}

"All input for the `deleteRefUserType` mutation."
input DeleteRefUserTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefUserType` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSActivityById` mutation."
input DeleteSActivityByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"All input for the `deleteSActivity` mutation."
input DeleteSActivityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SActivity` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSErrById` mutation."
input DeleteSErrByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"All input for the `deleteSErr` mutation."
input DeleteSErrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SErr` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSLogByIdLog` mutation."
input DeleteSLogByIdLogInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idLog: Int!
}

"All input for the `deleteSLogCodeByIdCode` mutation."
input DeleteSLogCodeByIdCodeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idCode: Int!
}

"All input for the `deleteSLogCode` mutation."
input DeleteSLogCodeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLogCode` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSLogDetailByIdLogDetail` mutation."
input DeleteSLogDetailByIdLogDetailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idLogDetail: Int!
}

"All input for the `deleteSLogDetail` mutation."
input DeleteSLogDetailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLogDetail` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSLog` mutation."
input DeleteSLogInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLog` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSTableById` mutation."
input DeleteSTableByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
}

"All input for the `deleteSTable` mutation."
input DeleteSTableInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `STable` to be deleted."
  nodeId: ID!
}

"All input for the `deleteSTableTypeByIdTabletype` mutation."
input DeleteSTableTypeByIdTabletypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idTabletype: Int!
}

"All input for the `deleteSTableType` mutation."
input DeleteSTableTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `STableType` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrCapacityByIdUsrCapacity` mutation."
input DeleteUsrCapacityByIdUsrCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrCapacity: Int!
}

"All input for the `deleteUsrCapacity` mutation."
input DeleteUsrCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrCapacity` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrDocByIdUsrDoc` mutation."
input DeleteUsrDocByIdUsrDocInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrDoc: Int!
}

"All input for the `deleteUsrDoc` mutation."
input DeleteUsrDocInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrDoc` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrDomainByIdUsrDomain` mutation."
input DeleteUsrDomainByIdUsrDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrDomain: Int!
}

"All input for the `deleteUsrDomain` mutation."
input DeleteUsrDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrDomain` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrFocusByIdUsrFocus` mutation."
input DeleteUsrFocusByIdUsrFocusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrFocus: Int!
}

"All input for the `deleteUsrFocus` mutation."
input DeleteUsrFocusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrFocus` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrNotifyByIdNotify` mutation."
input DeleteUsrNotifyByIdNotifyInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idNotify: Int!
}

"All input for the `deleteUsrNotify` mutation."
input DeleteUsrNotifyInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrNotify` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrPracticeByIdUsrPractice` mutation."
input DeleteUsrPracticeByIdUsrPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrPractice: Int!
}

"All input for the `deleteUsrPractice` mutation."
input DeleteUsrPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrPractice` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrRelationshipByIdUsrRelationship` mutation."
input DeleteUsrRelationshipByIdUsrRelationshipInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrRelationship: Int!
}

"All input for the `deleteUsrRelationship` mutation."
input DeleteUsrRelationshipInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrRelationship` to be deleted."
  nodeId: ID!
}

"All input for the `deleteUsrStrByIdUsrStr` mutation."
input DeleteUsrStrByIdUsrStrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrStr: Int!
}

"All input for the `deleteUsrStr` mutation."
input DeleteUsrStrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrStr` to be deleted."
  nodeId: ID!
}

"All input for the `deleteVwDistrictByIdDistrictNces` mutation."
input DeleteVwDistrictByIdDistrictNcesInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idDistrictNces: Int!
}

"All input for the `deleteVwDistrict` mutation."
input DeleteVwDistrictInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `VwDistrict` to be deleted."
  nodeId: ID!
}

"""

A condition to be used against `FlywaySchemaHistory` object types. All fields
are tested for equality and combined with a logical and.
"""
input FlywaySchemaHistoryCondition {
  "Checks for equality with the objects `checksum` field."
  checksum: Int
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `executionTime` field."
  executionTime: Int
  "Checks for equality with the objects `installedBy` field."
  installedBy: String
  "Checks for equality with the objects `installedOn` field."
  installedOn: Datetime
  "Checks for equality with the objects `installedRank` field."
  installedRank: Int
  "Checks for equality with the objects `script` field."
  script: String
  "Checks for equality with the objects `success` field."
  success: Boolean
  "Checks for equality with the objects `type` field."
  type: String
  "Checks for equality with the objects `version` field."
  version: String
}

"An input for mutations affecting `FlywaySchemaHistory`"
input FlywaySchemaHistoryInput {
  checksum: Int
  description: String!
  executionTime: Int!
  installedBy: String!
  installedOn: Datetime
  installedRank: Int!
  script: String!
  success: Boolean!
  type: String!
  version: String
}

"Represents an update to a `FlywaySchemaHistory`. Fields that are set will be updated."
input FlywaySchemaHistoryPatch {
  checksum: Int
  description: String
  executionTime: Int
  installedBy: String
  installedOn: Datetime
  installedRank: Int
  script: String
  success: Boolean
  type: String
  version: String
}

"All input for the `getmanager` mutation."
input GetmanagerInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  iduser: Int
}

"All input for the `getnextreview` mutation."
input GetnextreviewInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idreview: Int
}

"All input for the `getpreviousreview` mutation."
input GetpreviousreviewInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idreview: Int
}

"All input for the `getuseremail` mutation."
input GetuseremailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"All input for the `getuseridbyemail` mutation."
input GetuseridbyemailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String
}

"An interval of time that has passed where the smallest distinct unit is a second."
input IntervalInput {
  "A quantity of days."
  days: Int
  "A quantity of hours."
  hours: Int
  "A quantity of minutes."
  minutes: Int
  "A quantity of months."
  months: Int
  """

  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals dont
  have a smaller unit than seconds.
  """
  seconds: Float
  "A quantity of years."
  years: Int
}

"All input for the `logEnd` mutation."
input LogEndInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idlog: Int
}

"All input for the `logStart` mutation."
input LogStartInput {
  actionname: String
  actionrows: Int
  actionversion: String
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  mainrowsstart: Int
}

"All input for the `makeUidSchool` mutation."
input MakeUidSchoolInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  district: String
  school: String
  state: String
}

"All input for the `nextreviewer` mutation."
input NextreviewerInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idstr: Int
}

"All input for the `nextreviewuser` mutation."
input NextreviewuserInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idstr: Int
}

"A condition to be used against `Post` object types. All fields are tested for equality and combined with a logical and."
input PostCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `title` field."
  title: String
  "Checks for equality with the objects `userId` field."
  userId: Int
}

"An input for mutations affecting `Post`"
input PostInput {
  id: Int
  title: String
  userId: Int
}

"Represents an update to a `Post`. Fields that are set will be updated."
input PostPatch {
  id: Int
  title: String
  userId: Int
}

"All input for the `readAllNotifies` mutation."
input ReadAllNotifiesInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idapp: Int
  iduser: Int
}

"""

A condition to be used against `RefObject` object types. All fields are tested
for equality and combined with a logical and.
"""
input RefObjectCondition {
  "Checks for equality with the objects `dependsOn` field."
  dependsOn: Int
  "Checks for equality with the objects `idObject` field."
  idObject: Int
  "Checks for equality with the objects `objectDescription` field."
  objectDescription: String
  "Checks for equality with the objects `objectName` field."
  objectName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
}

"An input for mutations affecting `RefObject`"
input RefObjectInput {
  dependsOn: Int
  idObject: Int!
  objectDescription: String
  objectName: String!
  sCreate: Datetime
  sUpdate: Datetime
}

"Represents an update to a `RefObject`. Fields that are set will be updated."
input RefObjectPatch {
  dependsOn: Int
  idObject: Int
  objectDescription: String
  objectName: String
  sCreate: Datetime
  sUpdate: Datetime
}

"""

A condition to be used against `RefRelation` object types. All fields are tested
for equality and combined with a logical and.
"""
input RefRelationCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `relationshipDescription` field."
  relationshipDescription: String
  "Checks for equality with the objects `relationshipName` field."
  relationshipName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `RefRelation`"
input RefRelationInput {
  idAdmApp: Int
  idRelation: Int
  relationshipDescription: String
  relationshipName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `RefRelation`. Fields that are set will be updated."
input RefRelationPatch {
  idAdmApp: Int
  idRelation: Int
  relationshipDescription: String
  relationshipName: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `RefStatus` object types. All fields are tested
for equality and combined with a logical and.
"""
input RefStatusCondition {
  "Checks for equality with the objects `displayOrder` field."
  displayOrder: Int
  "Checks for equality with the objects `icon` field."
  icon: String
  "Checks for equality with the objects `idStatus` field."
  idStatus: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `state` field."
  state: String
  "Checks for equality with the objects `verb` field."
  verb: String
}

"An input for mutations affecting `RefStatus`"
input RefStatusInput {
  displayOrder: Int
  icon: String
  idStatus: Int
  sCreate: Datetime
  sUpdate: Datetime
  state: String
  verb: String
}

"Represents an update to a `RefStatus`. Fields that are set will be updated."
input RefStatusPatch {
  displayOrder: Int
  icon: String
  idStatus: Int
  sCreate: Datetime
  sUpdate: Datetime
  state: String
  verb: String
}

"""

A condition to be used against `RefUserType` object types. All fields are tested
for equality and combined with a logical and.
"""
input RefUserTypeCondition {
  "Checks for equality with the objects `idUserType` field."
  idUserType: Int
  "Checks for equality with the objects `notes` field."
  notes: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `title` field."
  title: String
}

"An input for mutations affecting `RefUserType`"
input RefUserTypeInput {
  idUserType: Int
  notes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"Represents an update to a `RefUserType`. Fields that are set will be updated."
input RefUserTypePatch {
  idUserType: Int
  notes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"All input for the `reviewApprove` mutation."
input ReviewApproveInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idreview: Int
  iduser: Int
}

"All input for the `reviewBackfill` mutation."
input ReviewBackfillInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idreview: Int
  idwhom: Int
}

"All input for the `reviewCalculateScores` mutation."
input ReviewCalculateScoresInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
  updatereview: Boolean
}

"All input for the `reviewCreateDependent` mutation."
input ReviewCreateDependentInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idreview: Int
  predate: Date
}

"All input for the `reviewSetInitialRelation` mutation."
input ReviewSetInitialRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int
}

"""

A condition to be used against `SActivity` object types. All fields are tested
for equality and combined with a logical and.
"""
input SActivityCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `isComplete` field."
  isComplete: Boolean
  "Checks for equality with the objects `linkedId` field."
  linkedId: Int
  "Checks for equality with the objects `linkedObject` field."
  linkedObject: Int
  "Checks for equality with the objects `note` field."
  note: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `status` field."
  status: String
}

"An input for mutations affecting `SActivity`"
input SActivityInput {
  id: Int
  isComplete: Boolean
  linkedId: Int
  linkedObject: Int
  note: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  status: String
}

"Represents an update to a `SActivity`. Fields that are set will be updated."
input SActivityPatch {
  id: Int
  isComplete: Boolean
  linkedId: Int
  linkedObject: Int
  note: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  status: String
}

"A condition to be used against `SErr` object types. All fields are tested for equality and combined with a logical and."
input SErrCondition {
  "Checks for equality with the objects `area` field."
  area: String
  "Checks for equality with the objects `errorText` field."
  errorText: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `idApp` field."
  idApp: Int
  "Checks for equality with the objects `idRelated` field."
  idRelated: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
}

"An input for mutations affecting `SErr`"
input SErrInput {
  area: String
  errorText: String
  id: Int
  idApp: Int
  idRelated: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

"Represents an update to a `SErr`. Fields that are set will be updated."
input SErrPatch {
  area: String
  errorText: String
  id: Int
  idApp: Int
  idRelated: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

"""

A condition to be used against `SLogCode` object types. All fields are tested
for equality and combined with a logical and.
"""
input SLogCodeCondition {
  "Checks for equality with the objects `codeComment` field."
  codeComment: String
  "Checks for equality with the objects `codeExecuted` field."
  codeExecuted: String
  "Checks for equality with the objects `codeReplaced` field."
  codeReplaced: String
  "Checks for equality with the objects `idCode` field."
  idCode: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sWhom` field."
  sWhom: String
  "Checks for equality with the objects `version` field."
  version: Int
}

"An input for mutations affecting `SLogCode`"
input SLogCodeInput {
  codeComment: String
  codeExecuted: String
  codeReplaced: String
  idCode: Int
  sCreate: Datetime
  sUpdate: Datetime
  sWhom: String
  version: Int
}

"Represents an update to a `SLogCode`. Fields that are set will be updated."
input SLogCodePatch {
  codeComment: String
  codeExecuted: String
  codeReplaced: String
  idCode: Int
  sCreate: Datetime
  sUpdate: Datetime
  sWhom: String
  version: Int
}

"A condition to be used against `SLog` object types. All fields are tested for equality and combined with a logical and."
input SLogCondition {
  "Checks for equality with the objects `actionRows` field."
  actionRows: Int
  "Checks for equality with the objects `app` field."
  app: String
  "Checks for equality with the objects `appVersion` field."
  appVersion: String
  "Checks for equality with the objects `area` field."
  area: String
  "Checks for equality with the objects `dbUser` field."
  dbUser: String
  "Checks for equality with the objects `idLog` field."
  idLog: Int
  "Checks for equality with the objects `isComplete` field."
  isComplete: Boolean
  "Checks for equality with the objects `logText` field."
  logText: String
  "Checks for equality with the objects `mainRowsStart` field."
  mainRowsStart: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
}

"""

A condition to be used against `SLogDetail` object types. All fields are tested
for equality and combined with a logical and.
"""
input SLogDetailCondition {
  "Checks for equality with the objects `actionName` field."
  actionName: String
  "Checks for equality with the objects `idLog` field."
  idLog: Int
  "Checks for equality with the objects `idLogDetail` field."
  idLogDetail: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `stepInterval` field."
  stepInterval: IntervalInput
  "Checks for equality with the objects `stepLength` field."
  stepLength: Int
  "Checks for equality with the objects `stepName` field."
  stepName: String
  "Checks for equality with the objects `stepNote` field."
  stepNote: String
  "Checks for equality with the objects `stepRows` field."
  stepRows: Int
}

"An input for mutations affecting `SLogDetail`"
input SLogDetailInput {
  actionName: String
  idLog: Int
  idLogDetail: Int
  sCreate: Datetime
  sUpdate: Datetime
  stepInterval: IntervalInput
  stepLength: Int
  stepName: String
  stepNote: String
  stepRows: Int
}

"Represents an update to a `SLogDetail`. Fields that are set will be updated."
input SLogDetailPatch {
  actionName: String
  idLog: Int
  idLogDetail: Int
  sCreate: Datetime
  sUpdate: Datetime
  stepInterval: IntervalInput
  stepLength: Int
  stepName: String
  stepNote: String
  stepRows: Int
}

"An input for mutations affecting `SLog`"
input SLogInput {
  actionRows: Int
  app: String
  appVersion: String
  area: String
  dbUser: String
  idLog: Int
  isComplete: Boolean
  logText: String
  mainRowsStart: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

"Represents an update to a `SLog`. Fields that are set will be updated."
input SLogPatch {
  actionRows: Int
  app: String
  appVersion: String
  area: String
  dbUser: String
  idLog: Int
  isComplete: Boolean
  logText: String
  mainRowsStart: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
}

"A condition to be used against `STable` object types. All fields are tested for equality and combined with a logical and."
input STableCondition {
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `idTabletype` field."
  idTabletype: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `tableDescription` field."
  tableDescription: String
  "Checks for equality with the objects `tableName` field."
  tableName: String
  "Checks for equality with the objects `typeName` field."
  typeName: String
}

"An input for mutations affecting `STable`"
input STableInput {
  id: Int
  idTabletype: Int
  sCreate: Datetime
  sUpdate: Datetime
  tableDescription: String
  tableName: String!
  typeName: String
}

"Represents an update to a `STable`. Fields that are set will be updated."
input STablePatch {
  id: Int
  idTabletype: Int
  sCreate: Datetime
  sUpdate: Datetime
  tableDescription: String
  tableName: String
  typeName: String
}

"""

A condition to be used against `STableType` object types. All fields are tested
for equality and combined with a logical and.
"""
input STableTypeCondition {
  "Checks for equality with the objects `hasCreate` field."
  hasCreate: Boolean
  "Checks for equality with the objects `hasUpdate` field."
  hasUpdate: Boolean
  "Checks for equality with the objects `hasUser` field."
  hasUser: Boolean
  "Checks for equality with the objects `idTabletype` field."
  idTabletype: Int
  "Checks for equality with the objects `prefix` field."
  prefix: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `typeDescription` field."
  typeDescription: String
  "Checks for equality with the objects `typeName` field."
  typeName: String
}

"An input for mutations affecting `STableType`"
input STableTypeInput {
  hasCreate: Boolean
  hasUpdate: Boolean
  hasUser: Boolean
  idTabletype: Int
  prefix: String
  sCreate: Datetime
  sUpdate: Datetime
  typeDescription: String
  typeName: String!
}

"Represents an update to a `STableType`. Fields that are set will be updated."
input STableTypePatch {
  hasCreate: Boolean
  hasUpdate: Boolean
  hasUser: Boolean
  idTabletype: Int
  prefix: String
  sCreate: Datetime
  sUpdate: Datetime
  typeDescription: String
  typeName: String
}

"All input for the `schoolAddFromReference` mutation."
input SchoolAddFromReferenceInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idapp: Int
  idnces: BigInt
  iduser: Int
}

"All input for the `updateAdmAccessByIdAdmAccess` mutation."
input UpdateAdmAccessByIdAdmAccessInput {
  "An object where the defined keys will be set on the `AdmAccess` being updated."
  admAccessPatch: AdmAccessPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmAccess: Int!
}

"All input for the `updateAdmAccess` mutation."
input UpdateAdmAccessInput {
  "An object where the defined keys will be set on the `AdmAccess` being updated."
  admAccessPatch: AdmAccessPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmAccess` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmAppByIdAdmApp` mutation."
input UpdateAdmAppByIdAdmAppInput {
  "An object where the defined keys will be set on the `AdmApp` being updated."
  admAppPatch: AdmAppPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmApp: Int!
}

"All input for the `updateAdmApp` mutation."
input UpdateAdmAppInput {
  "An object where the defined keys will be set on the `AdmApp` being updated."
  admAppPatch: AdmAppPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmApp` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmCapacityByIdAdmCapacityAndIdAdmDomain` mutation."
input UpdateAdmCapacityByIdAdmCapacityAndIdAdmDomainInput {
  "An object where the defined keys will be set on the `AdmCapacity` being updated."
  admCapacityPatch: AdmCapacityPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmCapacity: Int!
  idAdmDomain: Int!
}

"All input for the `updateAdmCapacityByIdAdmCapacity` mutation."
input UpdateAdmCapacityByIdAdmCapacityInput {
  "An object where the defined keys will be set on the `AdmCapacity` being updated."
  admCapacityPatch: AdmCapacityPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmCapacity: Int!
}

"All input for the `updateAdmCapacity` mutation."
input UpdateAdmCapacityInput {
  "An object where the defined keys will be set on the `AdmCapacity` being updated."
  admCapacityPatch: AdmCapacityPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmCapacity` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmDefaultTemplateByIdAdmDefaultNt` mutation."
input UpdateAdmDefaultTemplateByIdAdmDefaultNtInput {
  "An object where the defined keys will be set on the `AdmDefaultTemplate` being updated."
  admDefaultTemplatePatch: AdmDefaultTemplatePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDefaultNt: Int!
}

"All input for the `updateAdmDefaultTemplate` mutation."
input UpdateAdmDefaultTemplateInput {
  "An object where the defined keys will be set on the `AdmDefaultTemplate` being updated."
  admDefaultTemplatePatch: AdmDefaultTemplatePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDefaultTemplate` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmDistriktByIdDistrictNces` mutation."
input UpdateAdmDistriktByIdDistrictNcesInput {
  "An object where the defined keys will be set on the `AdmDistrikt` being updated."
  admDistriktPatch: AdmDistriktPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idDistrictNces: Int!
}

"All input for the `updateAdmDistrikt` mutation."
input UpdateAdmDistriktInput {
  "An object where the defined keys will be set on the `AdmDistrikt` being updated."
  admDistriktPatch: AdmDistriktPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDistrikt` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmDocCategoryByIdAdmDocCategory` mutation."
input UpdateAdmDocCategoryByIdAdmDocCategoryInput {
  "An object where the defined keys will be set on the `AdmDocCategory` being updated."
  admDocCategoryPatch: AdmDocCategoryPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDocCategory: Int!
}

"All input for the `updateAdmDocCategory` mutation."
input UpdateAdmDocCategoryInput {
  "An object where the defined keys will be set on the `AdmDocCategory` being updated."
  admDocCategoryPatch: AdmDocCategoryPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDocCategory` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmDocSuggestByIdAdmDocSuggest` mutation."
input UpdateAdmDocSuggestByIdAdmDocSuggestInput {
  "An object where the defined keys will be set on the `AdmDocSuggest` being updated."
  admDocSuggestPatch: AdmDocSuggestPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDocSuggest: Int!
}

"All input for the `updateAdmDocSuggest` mutation."
input UpdateAdmDocSuggestInput {
  "An object where the defined keys will be set on the `AdmDocSuggest` being updated."
  admDocSuggestPatch: AdmDocSuggestPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDocSuggest` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmDomainByIdAdmDomainAndIdAdmFramework` mutation."
input UpdateAdmDomainByIdAdmDomainAndIdAdmFrameworkInput {
  "An object where the defined keys will be set on the `AdmDomain` being updated."
  admDomainPatch: AdmDomainPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDomain: Int!
  idAdmFramework: Int!
}

"All input for the `updateAdmDomainByIdAdmDomain` mutation."
input UpdateAdmDomainByIdAdmDomainInput {
  "An object where the defined keys will be set on the `AdmDomain` being updated."
  admDomainPatch: AdmDomainPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmDomain: Int!
}

"All input for the `updateAdmDomain` mutation."
input UpdateAdmDomainInput {
  "An object where the defined keys will be set on the `AdmDomain` being updated."
  admDomainPatch: AdmDomainPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmDomain` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmEngagementByIdAdmEngagement` mutation."
input UpdateAdmEngagementByIdAdmEngagementInput {
  "An object where the defined keys will be set on the `AdmEngagement` being updated."
  admEngagementPatch: AdmEngagementPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmEngagement: Int!
}

"All input for the `updateAdmEngagement` mutation."
input UpdateAdmEngagementInput {
  "An object where the defined keys will be set on the `AdmEngagement` being updated."
  admEngagementPatch: AdmEngagementPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmEngagement` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmFrameworkByIdAdmFramework` mutation."
input UpdateAdmFrameworkByIdAdmFrameworkInput {
  "An object where the defined keys will be set on the `AdmFramework` being updated."
  admFrameworkPatch: AdmFrameworkPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmFramework: Int!
}

"All input for the `updateAdmFramework` mutation."
input UpdateAdmFrameworkInput {
  "An object where the defined keys will be set on the `AdmFramework` being updated."
  admFrameworkPatch: AdmFrameworkPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmFramework` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmNarrativeByIdAdmNarrative` mutation."
input UpdateAdmNarrativeByIdAdmNarrativeInput {
  "An object where the defined keys will be set on the `AdmNarrative` being updated."
  admNarrativePatch: AdmNarrativePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmNarrative: Int!
}

"All input for the `updateAdmNarrative` mutation."
input UpdateAdmNarrativeInput {
  "An object where the defined keys will be set on the `AdmNarrative` being updated."
  admNarrativePatch: AdmNarrativePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmNarrative` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmPeriodByIdAdmPeriod` mutation."
input UpdateAdmPeriodByIdAdmPeriodInput {
  "An object where the defined keys will be set on the `AdmPeriod` being updated."
  admPeriodPatch: AdmPeriodPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmPeriod: Int!
}

"All input for the `updateAdmPeriod` mutation."
input UpdateAdmPeriodInput {
  "An object where the defined keys will be set on the `AdmPeriod` being updated."
  admPeriodPatch: AdmPeriodPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmPeriod` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmPracticeByIdAdmPractice` mutation."
input UpdateAdmPracticeByIdAdmPracticeInput {
  "An object where the defined keys will be set on the `AdmPractice` being updated."
  admPracticePatch: AdmPracticePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmPractice: Int!
}

"All input for the `updateAdmPractice` mutation."
input UpdateAdmPracticeInput {
  "An object where the defined keys will be set on the `AdmPractice` being updated."
  admPracticePatch: AdmPracticePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmPractice` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmRubricByIdAdmRubric` mutation."
input UpdateAdmRubricByIdAdmRubricInput {
  "An object where the defined keys will be set on the `AdmRubric` being updated."
  admRubricPatch: AdmRubricPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmRubric: Int!
}

"All input for the `updateAdmRubric` mutation."
input UpdateAdmRubricInput {
  "An object where the defined keys will be set on the `AdmRubric` being updated."
  admRubricPatch: AdmRubricPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmRubric` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmRubricMapByIdAdmRubricMap` mutation."
input UpdateAdmRubricMapByIdAdmRubricMapInput {
  "An object where the defined keys will be set on the `AdmRubricMap` being updated."
  admRubricMapPatch: AdmRubricMapPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmRubricMap: Int!
}

"All input for the `updateAdmRubricMap` mutation."
input UpdateAdmRubricMapInput {
  "An object where the defined keys will be set on the `AdmRubricMap` being updated."
  admRubricMapPatch: AdmRubricMapPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmRubricMap` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmScaleByIdAdmScale` mutation."
input UpdateAdmScaleByIdAdmScaleInput {
  "An object where the defined keys will be set on the `AdmScale` being updated."
  admScalePatch: AdmScalePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmScale: Int!
}

"All input for the `updateAdmScale` mutation."
input UpdateAdmScaleInput {
  "An object where the defined keys will be set on the `AdmScale` being updated."
  admScalePatch: AdmScalePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmScale` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmScoreByIdAdmScore` mutation."
input UpdateAdmScoreByIdAdmScoreInput {
  "An object where the defined keys will be set on the `AdmScore` being updated."
  admScorePatch: AdmScorePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmScore: Int!
}

"All input for the `updateAdmScore` mutation."
input UpdateAdmScoreInput {
  "An object where the defined keys will be set on the `AdmScore` being updated."
  admScorePatch: AdmScorePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmScore` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmSkoolByIdSchoolNces` mutation."
input UpdateAdmSkoolByIdSchoolNcesInput {
  "An object where the defined keys will be set on the `AdmSkool` being updated."
  admSkoolPatch: AdmSkoolPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idSchoolNces: BigInt!
}

"All input for the `updateAdmSkool` mutation."
input UpdateAdmSkoolInput {
  "An object where the defined keys will be set on the `AdmSkool` being updated."
  admSkoolPatch: AdmSkoolPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmSkool` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmStrSequenceByIdAdmStrSequence` mutation."
input UpdateAdmStrSequenceByIdAdmStrSequenceInput {
  "An object where the defined keys will be set on the `AdmStrSequence` being updated."
  admStrSequencePatch: AdmStrSequencePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrSequence: Int!
}

"All input for the `updateAdmStrSequence` mutation."
input UpdateAdmStrSequenceInput {
  "An object where the defined keys will be set on the `AdmStrSequence` being updated."
  admStrSequencePatch: AdmStrSequencePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrSequence` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmStrTypeByIdAdmStrType` mutation."
input UpdateAdmStrTypeByIdAdmStrTypeInput {
  "An object where the defined keys will be set on the `AdmStrType` being updated."
  admStrTypePatch: AdmStrTypePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrType: Int!
}

"All input for the `updateAdmStrType` mutation."
input UpdateAdmStrTypeInput {
  "An object where the defined keys will be set on the `AdmStrType` being updated."
  admStrTypePatch: AdmStrTypePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrType` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmStrTypeMapByIdAdmStrTypeMap` mutation."
input UpdateAdmStrTypeMapByIdAdmStrTypeMapInput {
  "An object where the defined keys will be set on the `AdmStrTypeMap` being updated."
  admStrTypeMapPatch: AdmStrTypeMapPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmStrTypeMap: Int!
}

"All input for the `updateAdmStrTypeMap` mutation."
input UpdateAdmStrTypeMapInput {
  "An object where the defined keys will be set on the `AdmStrTypeMap` being updated."
  admStrTypeMapPatch: AdmStrTypeMapPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmStrTypeMap` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmTemplateByIdTemplate` mutation."
input UpdateAdmTemplateByIdTemplateInput {
  "An object where the defined keys will be set on the `AdmTemplate` being updated."
  admTemplatePatch: AdmTemplatePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idTemplate: Int!
}

"All input for the `updateAdmTemplate` mutation."
input UpdateAdmTemplateInput {
  "An object where the defined keys will be set on the `AdmTemplate` being updated."
  admTemplatePatch: AdmTemplatePatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmTemplate` to be updated."
  nodeId: ID!
}

"All input for the `updateAdmUserByIdAdmUser` mutation."
input UpdateAdmUserByIdAdmUserInput {
  "An object where the defined keys will be set on the `AdmUser` being updated."
  admUserPatch: AdmUserPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idAdmUser: Int!
}

"All input for the `updateAdmUser` mutation."
input UpdateAdmUserInput {
  "An object where the defined keys will be set on the `AdmUser` being updated."
  admUserPatch: AdmUserPatch!
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `AdmUser` to be updated."
  nodeId: ID!
}

"All input for the `updateFlywaySchemaHistoryByInstalledRank` mutation."
input UpdateFlywaySchemaHistoryByInstalledRankInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "An object where the defined keys will be set on the `FlywaySchemaHistory` being updated."
  flywaySchemaHistoryPatch: FlywaySchemaHistoryPatch!
  installedRank: Int!
}

"All input for the `updateFlywaySchemaHistory` mutation."
input UpdateFlywaySchemaHistoryInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "An object where the defined keys will be set on the `FlywaySchemaHistory` being updated."
  flywaySchemaHistoryPatch: FlywaySchemaHistoryPatch!
  "The globally unique `ID` which will identify a single `FlywaySchemaHistory` to be updated."
  nodeId: ID!
}

"All input for the `updatePostById` mutation."
input UpdatePostByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `Post` being updated."
  postPatch: PostPatch!
}

"All input for the `updatePost` mutation."
input UpdatePostInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `Post` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `Post` being updated."
  postPatch: PostPatch!
}

"All input for the `updateRefObjectByIdObject` mutation."
input UpdateRefObjectByIdObjectInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idObject: Int!
  "An object where the defined keys will be set on the `RefObject` being updated."
  refObjectPatch: RefObjectPatch!
}

"All input for the `updateRefObject` mutation."
input UpdateRefObjectInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefObject` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `RefObject` being updated."
  refObjectPatch: RefObjectPatch!
}

"All input for the `updateRefRelationByIdRelation` mutation."
input UpdateRefRelationByIdRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idRelation: Int!
  "An object where the defined keys will be set on the `RefRelation` being updated."
  refRelationPatch: RefRelationPatch!
}

"All input for the `updateRefRelation` mutation."
input UpdateRefRelationInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefRelation` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `RefRelation` being updated."
  refRelationPatch: RefRelationPatch!
}

"All input for the `updateRefStatusByIdStatus` mutation."
input UpdateRefStatusByIdStatusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idStatus: Int!
  "An object where the defined keys will be set on the `RefStatus` being updated."
  refStatusPatch: RefStatusPatch!
}

"All input for the `updateRefStatus` mutation."
input UpdateRefStatusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefStatus` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `RefStatus` being updated."
  refStatusPatch: RefStatusPatch!
}

"All input for the `updateRefUserTypeByIdUserType` mutation."
input UpdateRefUserTypeByIdUserTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUserType: Int!
  "An object where the defined keys will be set on the `RefUserType` being updated."
  refUserTypePatch: RefUserTypePatch!
}

"All input for the `updateRefUserType` mutation."
input UpdateRefUserTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `RefUserType` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `RefUserType` being updated."
  refUserTypePatch: RefUserTypePatch!
}

"All input for the `updateSActivityById` mutation."
input UpdateSActivityByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `SActivity` being updated."
  sActivityPatch: SActivityPatch!
}

"All input for the `updateSActivity` mutation."
input UpdateSActivityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SActivity` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `SActivity` being updated."
  sActivityPatch: SActivityPatch!
}

"All input for the `updateSErrById` mutation."
input UpdateSErrByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `SErr` being updated."
  sErrPatch: SErrPatch!
}

"All input for the `updateSErr` mutation."
input UpdateSErrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SErr` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `SErr` being updated."
  sErrPatch: SErrPatch!
}

"All input for the `updateSLogByIdLog` mutation."
input UpdateSLogByIdLogInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idLog: Int!
  "An object where the defined keys will be set on the `SLog` being updated."
  sLogPatch: SLogPatch!
}

"All input for the `updateSLogCodeByIdCode` mutation."
input UpdateSLogCodeByIdCodeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idCode: Int!
  "An object where the defined keys will be set on the `SLogCode` being updated."
  sLogCodePatch: SLogCodePatch!
}

"All input for the `updateSLogCode` mutation."
input UpdateSLogCodeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLogCode` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `SLogCode` being updated."
  sLogCodePatch: SLogCodePatch!
}

"All input for the `updateSLogDetailByIdLogDetail` mutation."
input UpdateSLogDetailByIdLogDetailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idLogDetail: Int!
  "An object where the defined keys will be set on the `SLogDetail` being updated."
  sLogDetailPatch: SLogDetailPatch!
}

"All input for the `updateSLogDetail` mutation."
input UpdateSLogDetailInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLogDetail` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `SLogDetail` being updated."
  sLogDetailPatch: SLogDetailPatch!
}

"All input for the `updateSLog` mutation."
input UpdateSLogInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `SLog` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `SLog` being updated."
  sLogPatch: SLogPatch!
}

"All input for the `updateSTableById` mutation."
input UpdateSTableByIdInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: Int!
  "An object where the defined keys will be set on the `STable` being updated."
  sTablePatch: STablePatch!
}

"All input for the `updateSTable` mutation."
input UpdateSTableInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `STable` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `STable` being updated."
  sTablePatch: STablePatch!
}

"All input for the `updateSTableTypeByIdTabletype` mutation."
input UpdateSTableTypeByIdTabletypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idTabletype: Int!
  "An object where the defined keys will be set on the `STableType` being updated."
  sTableTypePatch: STableTypePatch!
}

"All input for the `updateSTableType` mutation."
input UpdateSTableTypeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `STableType` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `STableType` being updated."
  sTableTypePatch: STableTypePatch!
}

"All input for the `updateUsrCapacityByIdUsrCapacity` mutation."
input UpdateUsrCapacityByIdUsrCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrCapacity: Int!
  "An object where the defined keys will be set on the `UsrCapacity` being updated."
  usrCapacityPatch: UsrCapacityPatch!
}

"All input for the `updateUsrCapacity` mutation."
input UpdateUsrCapacityInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrCapacity` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrCapacity` being updated."
  usrCapacityPatch: UsrCapacityPatch!
}

"All input for the `updateUsrDocByIdUsrDoc` mutation."
input UpdateUsrDocByIdUsrDocInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrDoc: Int!
  "An object where the defined keys will be set on the `UsrDoc` being updated."
  usrDocPatch: UsrDocPatch!
}

"All input for the `updateUsrDoc` mutation."
input UpdateUsrDocInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrDoc` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrDoc` being updated."
  usrDocPatch: UsrDocPatch!
}

"All input for the `updateUsrDomainByIdUsrDomain` mutation."
input UpdateUsrDomainByIdUsrDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrDomain: Int!
  "An object where the defined keys will be set on the `UsrDomain` being updated."
  usrDomainPatch: UsrDomainPatch!
}

"All input for the `updateUsrDomain` mutation."
input UpdateUsrDomainInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrDomain` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrDomain` being updated."
  usrDomainPatch: UsrDomainPatch!
}

"All input for the `updateUsrFocusByIdUsrFocus` mutation."
input UpdateUsrFocusByIdUsrFocusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrFocus: Int!
  "An object where the defined keys will be set on the `UsrFocus` being updated."
  usrFocusPatch: UsrFocusPatch!
}

"All input for the `updateUsrFocus` mutation."
input UpdateUsrFocusInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrFocus` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrFocus` being updated."
  usrFocusPatch: UsrFocusPatch!
}

"All input for the `updateUsrNotifyByIdNotify` mutation."
input UpdateUsrNotifyByIdNotifyInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idNotify: Int!
  "An object where the defined keys will be set on the `UsrNotify` being updated."
  usrNotifyPatch: UsrNotifyPatch!
}

"All input for the `updateUsrNotify` mutation."
input UpdateUsrNotifyInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrNotify` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrNotify` being updated."
  usrNotifyPatch: UsrNotifyPatch!
}

"All input for the `updateUsrPracticeByIdUsrPractice` mutation."
input UpdateUsrPracticeByIdUsrPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrPractice: Int!
  "An object where the defined keys will be set on the `UsrPractice` being updated."
  usrPracticePatch: UsrPracticePatch!
}

"All input for the `updateUsrPractice` mutation."
input UpdateUsrPracticeInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrPractice` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrPractice` being updated."
  usrPracticePatch: UsrPracticePatch!
}

"All input for the `updateUsrRelationshipByIdUsrRelationship` mutation."
input UpdateUsrRelationshipByIdUsrRelationshipInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrRelationship: Int!
  "An object where the defined keys will be set on the `UsrRelationship` being updated."
  usrRelationshipPatch: UsrRelationshipPatch!
}

"All input for the `updateUsrRelationship` mutation."
input UpdateUsrRelationshipInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrRelationship` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrRelationship` being updated."
  usrRelationshipPatch: UsrRelationshipPatch!
}

"All input for the `updateUsrStrByIdUsrStr` mutation."
input UpdateUsrStrByIdUsrStrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idUsrStr: Int!
  "An object where the defined keys will be set on the `UsrStr` being updated."
  usrStrPatch: UsrStrPatch!
}

"All input for the `updateUsrStr` mutation."
input UpdateUsrStrInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `UsrStr` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `UsrStr` being updated."
  usrStrPatch: UsrStrPatch!
}

"All input for the `updateVwDistrictByIdDistrictNces` mutation."
input UpdateVwDistrictByIdDistrictNcesInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  idDistrictNces: Int!
  "An object where the defined keys will be set on the `VwDistrict` being updated."
  vwDistrictPatch: VwDistrictPatch!
}

"All input for the `updateVwDistrict` mutation."
input UpdateVwDistrictInput {
  """

  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  "The globally unique `ID` which will identify a single `VwDistrict` to be updated."
  nodeId: ID!
  "An object where the defined keys will be set on the `VwDistrict` being updated."
  vwDistrictPatch: VwDistrictPatch!
}

"""

A condition to be used against `UsrCapacity` object types. All fields are tested
for equality and combined with a logical and.
"""
input UsrCapacityCondition {
  "Checks for equality with the objects `capacityNote` field."
  capacityNote: String
  "Checks for equality with the objects `capacityScore` field."
  capacityScore: BigFloat
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `UsrCapacity`"
input UsrCapacityInput {
  capacityNote: String
  capacityScore: BigFloat
  idAdmCapacity: Int!
  idUsrCapacity: Int
  idUsrDomain: Int
  idUsrStr: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `UsrCapacity`. Fields that are set will be updated."
input UsrCapacityPatch {
  capacityNote: String
  capacityScore: BigFloat
  idAdmCapacity: Int
  idUsrCapacity: Int
  idUsrDomain: Int
  idUsrStr: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A condition to be used against `UsrDoc` object types. All fields are tested for equality and combined with a logical and."
input UsrDocCondition {
  "Checks for equality with the objects `docAttachmentPath` field."
  docAttachmentPath: String
  "Checks for equality with the objects `docNotes` field."
  docNotes: String
  "Checks for equality with the objects `docTitle` field."
  docTitle: String
  "Checks for equality with the objects `docUrlPath` field."
  docUrlPath: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDocCategory` field."
  idAdmDocCategory: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrDoc` field."
  idUsrDoc: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrPractice` field."
  idUsrPractice: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrAdd` field."
  idUsrStrAdd: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `UsrDoc`"
input UsrDocInput {
  docAttachmentPath: String
  docNotes: String
  docTitle: String!
  docUrlPath: String
  idAdmApp: Int!
  idAdmDocCategory: Int
  idAdmUser: Int!
  idUsrCapacity: Int
  idUsrDoc: Int
  idUsrDomain: Int
  idUsrPractice: Int
  idUsrStr: Int!
  idUsrStrAdd: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `UsrDoc`. Fields that are set will be updated."
input UsrDocPatch {
  docAttachmentPath: String
  docNotes: String
  docTitle: String
  docUrlPath: String
  idAdmApp: Int
  idAdmDocCategory: Int
  idAdmUser: Int
  idUsrCapacity: Int
  idUsrDoc: Int
  idUsrDomain: Int
  idUsrPractice: Int
  idUsrStr: Int
  idUsrStrAdd: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `UsrDomain` object types. All fields are tested
for equality and combined with a logical and.
"""
input UsrDomainCondition {
  "Checks for equality with the objects `addOpportunities` field."
  addOpportunities: String
  "Checks for equality with the objects `addStrengths` field."
  addStrengths: String
  "Checks for equality with the objects `domainScore` field."
  domainScore: BigFloat
  "Checks for equality with the objects `gapClosure` field."
  gapClosure: BigFloat
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `opportunities` field."
  opportunities: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `strengths` field."
  strengths: String
  "Checks for equality with the objects `themes` field."
  themes: String
}

"An input for mutations affecting `UsrDomain`"
input UsrDomainInput {
  addOpportunities: String
  addStrengths: String
  domainScore: BigFloat
  gapClosure: BigFloat
  idAdmDomain: Int!
  idUsrDomain: Int
  idUsrStr: Int!
  opportunities: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strengths: String
  themes: String
}

"Represents an update to a `UsrDomain`. Fields that are set will be updated."
input UsrDomainPatch {
  addOpportunities: String
  addStrengths: String
  domainScore: BigFloat
  gapClosure: BigFloat
  idAdmDomain: Int
  idUsrDomain: Int
  idUsrStr: Int
  opportunities: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strengths: String
  themes: String
}

"""

A condition to be used against `UsrFocus` object types. All fields are tested
for equality and combined with a logical and.
"""
input UsrFocusCondition {
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `idUsrFocus` field."
  idUsrFocus: Int
  "Checks for equality with the objects `idUsrPractice` field."
  idUsrPractice: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolYearEnding` field."
  schoolYearEnding: Int
  "Checks for equality with the objects `score` field."
  score: Int
}

"An input for mutations affecting `UsrFocus`"
input UsrFocusInput {
  idAdmPractice: Int!
  idSchoolNces: BigInt!
  idUsrFocus: Int
  idUsrPractice: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int!
  score: Int
}

"Represents an update to a `UsrFocus`. Fields that are set will be updated."
input UsrFocusPatch {
  idAdmPractice: Int
  idSchoolNces: BigInt
  idUsrFocus: Int
  idUsrPractice: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  schoolYearEnding: Int
  score: Int
}

"""

A condition to be used against `UsrNotify` object types. All fields are tested
for equality and combined with a logical and.
"""
input UsrNotifyCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idNotify` field."
  idNotify: Int
  "Checks for equality with the objects `isRead` field."
  isRead: Boolean
  "Checks for equality with the objects `linkedId` field."
  linkedId: Int
  "Checks for equality with the objects `linkedObject` field."
  linkedObject: Int
  "Checks for equality with the objects `linkedUser` field."
  linkedUser: Int
  "Checks for equality with the objects `message` field."
  message: String
  "Checks for equality with the objects `readReceipt` field."
  readReceipt: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `UsrNotify`"
input UsrNotifyInput {
  idAdmApp: Int!
  idAdmUser: Int!
  idNotify: Int
  isRead: Boolean
  linkedId: Int
  linkedObject: Int
  linkedUser: Int
  message: String!
  readReceipt: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `UsrNotify`. Fields that are set will be updated."
input UsrNotifyPatch {
  idAdmApp: Int
  idAdmUser: Int
  idNotify: Int
  isRead: Boolean
  linkedId: Int
  linkedObject: Int
  linkedUser: Int
  message: String
  readReceipt: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"""

A condition to be used against `UsrPractice` object types. All fields are tested
for equality and combined with a logical and.
"""
input UsrPracticeCondition {
  "Checks for equality with the objects `idAction` field."
  idAction: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrPractice` field."
  idUsrPractice: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `notes` field."
  notes: String
  "Checks for equality with the objects `practiceScore` field."
  practiceScore: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `uidPractice` field."
  uidPractice: String
  "Checks for equality with the objects `uidStr` field."
  uidStr: String
}

"An input for mutations affecting `UsrPractice`"
input UsrPracticeInput {
  idAction: Int
  idAdmPractice: Int!
  idUsrCapacity: Int!
  idUsrPractice: Int
  idUsrStr: Int!
  notes: String
  practiceScore: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  uidPractice: String
  uidStr: String
}

"Represents an update to a `UsrPractice`. Fields that are set will be updated."
input UsrPracticePatch {
  idAction: Int
  idAdmPractice: Int
  idUsrCapacity: Int
  idUsrPractice: Int
  idUsrStr: Int
  notes: String
  practiceScore: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  uidPractice: String
  uidStr: String
}

"""

A condition to be used against `UsrRelationship` object types. All fields are
tested for equality and combined with a logical and.
"""
input UsrRelationshipCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `idUsrRelationship` field."
  idUsrRelationship: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"An input for mutations affecting `UsrRelationship`"
input UsrRelationshipInput {
  idAdmApp: Int!
  idAdmUser: Int
  idRelation: Int!
  idUsrRelationship: Int
  idUsrStr: Int!
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"Represents an update to a `UsrRelationship`. Fields that are set will be updated."
input UsrRelationshipPatch {
  idAdmApp: Int
  idAdmUser: Int
  idRelation: Int
  idUsrRelationship: Int
  idUsrStr: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
}

"A condition to be used against `UsrStr` object types. All fields are tested for equality and combined with a logical and."
input UsrStrCondition {
  "Checks for equality with the objects `currentIdUsrRelationship` field."
  currentIdUsrRelationship: Int
  "Checks for equality with the objects `currentStatus` field."
  currentStatus: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPeriod` field."
  idAdmPeriod: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idLog` field."
  idLog: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `idStatus` field."
  idStatus: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrNext` field."
  idUsrStrNext: Int
  "Checks for equality with the objects `idUsrStrPrev` field."
  idUsrStrPrev: Int
  "Checks for equality with the objects `isComplete` field."
  isComplete: Boolean
  "Checks for equality with the objects `isScored` field."
  isScored: Boolean
  "Checks for equality with the objects `lastLog` field."
  lastLog: Datetime
  "Checks for equality with the objects `overallThemes` field."
  overallThemes: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `strDate` field."
  strDate: Date
  "Checks for equality with the objects `strScore` field."
  strScore: BigFloat
  "Checks for equality with the objects `strSeason` field."
  strSeason: String
  "Checks for equality with the objects `strTeam` field."
  strTeam: String
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidStr` field."
  uidStr: String
}

"An input for mutations affecting `UsrStr`"
input UsrStrInput {
  "The relationship currently managing the STR"
  currentIdUsrRelationship: Int
  currentStatus: String
  idAdmApp: Int
  idAdmFramework: Int!
  idAdmPeriod: Int!
  idAdmRubric: Int
  idAdmStrType: Int!
  "The user the str is owned by"
  idAdmUser: Int
  idLog: Int
  idSchoolNces: BigInt
  idStatus: Int
  idUsrStr: Int
  idUsrStrNext: Int
  idUsrStrPrev: Int
  isComplete: Boolean
  isScored: Boolean
  lastLog: Datetime
  overallThemes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strDate: Date!
  strScore: BigFloat
  strSeason: String
  strTeam: String
  tags: String
  uidStr: String
}

"Represents an update to a `UsrStr`. Fields that are set will be updated."
input UsrStrPatch {
  "The relationship currently managing the STR"
  currentIdUsrRelationship: Int
  currentStatus: String
  idAdmApp: Int
  idAdmFramework: Int
  idAdmPeriod: Int
  idAdmRubric: Int
  idAdmStrType: Int
  "The user the str is owned by"
  idAdmUser: Int
  idLog: Int
  idSchoolNces: BigInt
  idStatus: Int
  idUsrStr: Int
  idUsrStrNext: Int
  idUsrStrPrev: Int
  isComplete: Boolean
  isScored: Boolean
  lastLog: Datetime
  overallThemes: String
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  strDate: Date
  strScore: BigFloat
  strSeason: String
  strTeam: String
  tags: String
  uidStr: String
}

"""

A condition to be used against `VwCapacity` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwCapacityCondition {
  "Checks for equality with the objects `capacityDescription` field."
  capacityDescription: String
  "Checks for equality with the objects `capacityExemplar` field."
  capacityExemplar: String
  "Checks for equality with the objects `capacityName` field."
  capacityName: String
  "Checks for equality with the objects `capacityNote` field."
  capacityNote: String
  "Checks for equality with the objects `capacityScore` field."
  capacityScore: BigFloat
  "Checks for equality with the objects `capacityTag` field."
  capacityTag: String
  "Checks for equality with the objects `domainName` field."
  domainName: String
  "Checks for equality with the objects `domainOrder` field."
  domainOrder: Int
  "Checks for equality with the objects `domainShort` field."
  domainShort: String
  "Checks for equality with the objects `domainTag` field."
  domainTag: String
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"""

A condition to be used against `VwDefaultTemplate` object types. All fields are
tested for equality and combined with a logical and.
"""
input VwDefaultTemplateCondition {
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmNarrative` field."
  idAdmNarrative: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `narrativeName` field."
  narrativeName: String
  "Checks for equality with the objects `narrativeTags` field."
  narrativeTags: String
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `templateDescription` field."
  templateDescription: String
  "Checks for equality with the objects `templateLink` field."
  templateLink: String
  "Checks for equality with the objects `templateName` field."
  templateName: String
  "Checks for equality with the objects `templateText` field."
  templateText: String
}

"""

A condition to be used against `VwDistrict` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwDistrictCondition {
  "Checks for equality with the objects `districtName` field."
  districtName: String
  "Checks for equality with the objects `districtNameLocal` field."
  districtNameLocal: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `state` field."
  state: String
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidDistrict` field."
  uidDistrict: String
}

"An input for mutations affecting `VwDistrict`"
input VwDistrictInput {
  districtName: String
  districtNameLocal: String
  idAdmApp: Int
  idDistrictNces: Int!
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
}

"Represents an update to a `VwDistrict`. Fields that are set will be updated."
input VwDistrictPatch {
  districtName: String
  districtNameLocal: String
  idAdmApp: Int
  idDistrictNces: Int
  isActive: Boolean
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  state: String
  tags: String
  uidDistrict: String
}

"A condition to be used against `VwDoc` object types. All fields are tested for equality and combined with a logical and."
input VwDocCondition {
  "Checks for equality with the objects `docAttachmentPath` field."
  docAttachmentPath: String
  "Checks for equality with the objects `docCategoryName` field."
  docCategoryName: String
  "Checks for equality with the objects `docNotes` field."
  docNotes: String
  "Checks for equality with the objects `docTitle` field."
  docTitle: String
  "Checks for equality with the objects `docUrlPath` field."
  docUrlPath: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmDocCategory` field."
  idAdmDocCategory: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idReview` field."
  idReview: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrDoc` field."
  idUsrDoc: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrPractice` field."
  idUsrPractice: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrAdd` field."
  idUsrStrAdd: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sCreateUserEmail` field."
  sCreateUserEmail: String
  "Checks for equality with the objects `sCreateUserName` field."
  sCreateUserName: String
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `sUpdateUserEmail` field."
  sUpdateUserEmail: String
  "Checks for equality with the objects `sUpdateUserName` field."
  sUpdateUserName: String
  "Checks for equality with the objects `sortOrder` field."
  sortOrder: Int
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
}

"""

A condition to be used against `VwDomain` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwDomainCondition {
  "Checks for equality with the objects `addOpportunities` field."
  addOpportunities: String
  "Checks for equality with the objects `addStrengths` field."
  addStrengths: String
  "Checks for equality with the objects `domainDescription` field."
  domainDescription: String
  "Checks for equality with the objects `domainGapClosure` field."
  domainGapClosure: BigFloat
  "Checks for equality with the objects `domainName` field."
  domainName: String
  "Checks for equality with the objects `domainOrder` field."
  domainOrder: Int
  "Checks for equality with the objects `domainScore` field."
  domainScore: BigFloat
  "Checks for equality with the objects `domainShort` field."
  domainShort: String
  "Checks for equality with the objects `domainTag` field."
  domainTag: String
  "Checks for equality with the objects `exemplar` field."
  exemplar: String
  "Checks for equality with the objects `gapClosure` field."
  gapClosure: BigFloat
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `opportunities` field."
  opportunities: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `strengths` field."
  strengths: String
  "Checks for equality with the objects `themes` field."
  themes: String
}

"""

A condition to be used against `VwEngagementPeriod` object types. All fields are
tested for equality and combined with a logical and.
"""
input VwEngagementPeriodCondition {
  "Checks for equality with the objects `currentIdAdmUser` field."
  currentIdAdmUser: Int
  "Checks for equality with the objects `currentIdUsrRelationship` field."
  currentIdUsrRelationship: Int
  "Checks for equality with the objects `districtName` field."
  districtName: String
  "Checks for equality with the objects `engagementKind` field."
  engagementKind: String
  "Checks for equality with the objects `engagementType` field."
  engagementType: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPeriod` field."
  idAdmPeriod: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `idEngagementKind` field."
  idEngagementKind: Int
  "Checks for equality with the objects `idEngagementType` field."
  idEngagementType: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrNext` field."
  idUsrStrNext: Int
  "Checks for equality with the objects `idUsrStrPrev` field."
  idUsrStrPrev: Int
  "Checks for equality with the objects `isComplete` field."
  isComplete: Boolean
  "Checks for equality with the objects `isOfficialRecord` field."
  isOfficialRecord: Boolean
  "Checks for equality with the objects `isScored` field."
  isScored: Boolean
  "Checks for equality with the objects `overallThemes` field."
  overallThemes: String
  "Checks for equality with the objects `periodName` field."
  periodName: String
  "Checks for equality with the objects `relationUserEmail` field."
  relationUserEmail: String
  "Checks for equality with the objects `relationUserName` field."
  relationUserName: String
  "Checks for equality with the objects `relationshipDescription` field."
  relationshipDescription: String
  "Checks for equality with the objects `relationshipName` field."
  relationshipName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolName` field."
  schoolName: String
  "Checks for equality with the objects `schoolYearEnding` field."
  schoolYearEnding: Int
  "Checks for equality with the objects `strDate` field."
  strDate: Date
  "Checks for equality with the objects `strScore` field."
  strScore: BigFloat
  "Checks for equality with the objects `strSeason` field."
  strSeason: String
  "Checks for equality with the objects `strTeam` field."
  strTeam: String
  "Checks for equality with the objects `typeName` field."
  typeName: String
  "Checks for equality with the objects `typeTag` field."
  typeTag: String
  "Checks for equality with the objects `uidStr` field."
  uidStr: String
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
}

"""

A condition to be used against `VwPractice` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwPracticeCondition {
  "Checks for equality with the objects `capacityDescription` field."
  capacityDescription: String
  "Checks for equality with the objects `capacityName` field."
  capacityName: String
  "Checks for equality with the objects `capacityScore` field."
  capacityScore: BigFloat
  "Checks for equality with the objects `capacityTag` field."
  capacityTag: String
  "Checks for equality with the objects `domainDescription` field."
  domainDescription: String
  "Checks for equality with the objects `domainName` field."
  domainName: String
  "Checks for equality with the objects `domainOrder` field."
  domainOrder: Int
  "Checks for equality with the objects `domainScore` field."
  domainScore: BigFloat
  "Checks for equality with the objects `domainShort` field."
  domainShort: String
  "Checks for equality with the objects `domainTag` field."
  domainTag: String
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrPractice` field."
  idUsrPractice: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `notes` field."
  notes: String
  "Checks for equality with the objects `practiceDescription` field."
  practiceDescription: String
  "Checks for equality with the objects `practiceExemplar` field."
  practiceExemplar: String
  "Checks for equality with the objects `practiceName` field."
  practiceName: String
  "Checks for equality with the objects `practiceScore` field."
  practiceScore: Int
  "Checks for equality with the objects `practiceTag` field."
  practiceTag: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `uidPractice` field."
  uidPractice: String
  "Checks for equality with the objects `uidStr` field."
  uidStr: String
}

"""

A condition to be used against `VwRelationship` object types. All fields are
tested for equality and combined with a logical and.
"""
input VwRelationshipCondition {
  "Checks for equality with the objects `displayOrder` field."
  displayOrder: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `idUsrRelationship` field."
  idUsrRelationship: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `imageLink` field."
  imageLink: String
  "Checks for equality with the objects `imageUrl` field."
  imageUrl: String
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `nextIdRelation` field."
  nextIdRelation: Int
  "Checks for equality with the objects `relationStrTypeId` field."
  relationStrTypeId: Int
  "Checks for equality with the objects `relationshipDescription` field."
  relationshipDescription: String
  "Checks for equality with the objects `relationshipName` field."
  relationshipName: String
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
  "Checks for equality with the objects `userScore` field."
  userScore: Int
}

"""

A condition to be used against `VwReview` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwReviewCondition {
  "Checks for equality with the objects `currentIdAdmUser` field."
  currentIdAdmUser: Int
  "Checks for equality with the objects `currentIdUsrRelationship` field."
  currentIdUsrRelationship: Int
  "Checks for equality with the objects `currentStatus` field."
  currentStatus: String
  "Checks for equality with the objects `districtName` field."
  districtName: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPeriod` field."
  idAdmPeriod: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
  "Checks for equality with the objects `idAdmStrType` field."
  idAdmStrType: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `idRelation` field."
  idRelation: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `idStatus` field."
  idStatus: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `idUsrStrNext` field."
  idUsrStrNext: Int
  "Checks for equality with the objects `idUsrStrPrev` field."
  idUsrStrPrev: Int
  "Checks for equality with the objects `isComplete` field."
  isComplete: Boolean
  "Checks for equality with the objects `isOfficialRecord` field."
  isOfficialRecord: Boolean
  "Checks for equality with the objects `isScored` field."
  isScored: Boolean
  "Checks for equality with the objects `overallThemes` field."
  overallThemes: String
  "Checks for equality with the objects `periodName` field."
  periodName: String
  "Checks for equality with the objects `relationUserEmail` field."
  relationUserEmail: String
  "Checks for equality with the objects `relationUserName` field."
  relationUserName: String
  "Checks for equality with the objects `relationshipDescription` field."
  relationshipDescription: String
  "Checks for equality with the objects `relationshipName` field."
  relationshipName: String
  "Checks for equality with the objects `rubricDescription` field."
  rubricDescription: String
  "Checks for equality with the objects `rubricName` field."
  rubricName: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolName` field."
  schoolName: String
  "Checks for equality with the objects `schoolYearEnding` field."
  schoolYearEnding: Int
  "Checks for equality with the objects `strDate` field."
  strDate: Date
  "Checks for equality with the objects `strScore` field."
  strScore: BigFloat
  "Checks for equality with the objects `strSeason` field."
  strSeason: String
  "Checks for equality with the objects `strTeam` field."
  strTeam: String
  "Checks for equality with the objects `strYear` field."
  strYear: Float
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `typeName` field."
  typeName: String
  "Checks for equality with the objects `typeTag` field."
  typeTag: String
  "Checks for equality with the objects `uidStr` field."
  uidStr: String
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
}

"""

A condition to be used against `VwSchema` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwSchemaCondition {
  "Checks for equality with the objects `checksum` field."
  checksum: Int
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `executionTime` field."
  executionTime: Int
  "Checks for equality with the objects `installedBy` field."
  installedBy: String
  "Checks for equality with the objects `installedOn` field."
  installedOn: Datetime
  "Checks for equality with the objects `installedRank` field."
  installedRank: Int
  "Checks for equality with the objects `script` field."
  script: String
  "Checks for equality with the objects `success` field."
  success: Boolean
  "Checks for equality with the objects `type` field."
  type: String
  "Checks for equality with the objects `version` field."
  version: String
}

"""

A condition to be used against `VwSchool` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwSchoolCondition {
  "Checks for equality with the objects `districtName` field."
  districtName: String
  "Checks for equality with the objects `districtNameLocal` field."
  districtNameLocal: String
  "Checks for equality with the objects `districtTags` field."
  districtTags: String
  "Checks for equality with the objects `id` field."
  id: Int
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idDistrictNces` field."
  idDistrictNces: Int
  "Checks for equality with the objects `idSchoolNces` field."
  idSchoolNces: BigInt
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `schoolName` field."
  schoolName: String
  "Checks for equality with the objects `state` field."
  state: String
  "Checks for equality with the objects `tags` field."
  tags: String
  "Checks for equality with the objects `uidDistrict` field."
  uidDistrict: String
  "Checks for equality with the objects `uidSchool` field."
  uidSchool: String
}

"""

A condition to be used against `VwSeason` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwSeasonCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `strSeason` field."
  strSeason: String
}

"""

A condition to be used against `VwTestApp` object types. All fields are tested
for equality and combined with a logical and.
"""
input VwTestAppCondition {
  "Checks for equality with the objects `appPreferences` field."
  appPreferences: JSON
  "Checks for equality with the objects `description` field."
  description: String
  "Checks for equality with the objects `helpCalibrate` field."
  helpCalibrate: String
  "Checks for equality with the objects `helpFacilitate` field."
  helpFacilitate: String
  "Checks for equality with the objects `helpScore` field."
  helpScore: String
  "Checks for equality with the objects `helpSummary` field."
  helpSummary: String
  "Checks for equality with the objects `helpView` field."
  helpView: String
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `title` field."
  title: String
}

"An input for mutations affecting `VwTestApp`"
input VwTestAppInput {
  appPreferences: JSON
  description: String
  helpCalibrate: String
  helpFacilitate: String
  helpScore: String
  helpSummary: String
  helpView: String
  idAdmApp: Int
  sCreate: Datetime
  sCreateUser: Int
  sUpdate: Datetime
  sUpdateUser: Int
  title: String
}

"A condition to be used against `VwUser` object types. All fields are tested for equality and combined with a logical and."
input VwUserCondition {
  "Checks for equality with the objects `idAdmApp` field."
  idAdmApp: Int
  "Checks for equality with the objects `idAdmUser` field."
  idAdmUser: Int
  "Checks for equality with the objects `idManager` field."
  idManager: Int
  "Checks for equality with the objects `idUserType` field."
  idUserType: Int
  "Checks for equality with the objects `imageLink` field."
  imageLink: String
  "Checks for equality with the objects `imageUrl` field."
  imageUrl: String
  "Checks for equality with the objects `isActive` field."
  isActive: Boolean
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
  "Checks for equality with the objects `tags` field."
  tags: Int
  "Checks for equality with the objects `userEmail` field."
  userEmail: String
  "Checks for equality with the objects `userName` field."
  userName: String
  "Checks for equality with the objects `userPreferences` field."
  userPreferences: JSON
  "Checks for equality with the objects `userScore` field."
  userScore: Int
  "Checks for equality with the objects `userTypeNotes` field."
  userTypeNotes: String
  "Checks for equality with the objects `userTypeTitle` field."
  userTypeTitle: String
}

"""

A condition to be used against `_VwAdmCapacityFramework` object types. All
fields are tested for equality and combined with a logical and.
"""
input _VwAdmCapacityFrameworkCondition {
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
}

"""

A condition to be used against `_VwAdmCapacityRubric` object types. All fields
are tested for equality and combined with a logical and.
"""
input _VwAdmCapacityRubricCondition {
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
}

"""

A condition to be used against `_VwAdmPracticeFramework` object types. All
fields are tested for equality and combined with a logical and.
"""
input _VwAdmPracticeFrameworkCondition {
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
}

"""

A condition to be used against `_VwAdmPracticeFull` object types. All fields are
tested for equality and combined with a logical and.
"""
input _VwAdmPracticeFullCondition {
  "Checks for equality with the objects `analysisName` field."
  analysisName: String
  "Checks for equality with the objects `capacityDescription` field."
  capacityDescription: String
  "Checks for equality with the objects `capacityName` field."
  capacityName: String
  "Checks for equality with the objects `capacityTag` field."
  capacityTag: String
  "Checks for equality with the objects `domainDescription` field."
  domainDescription: String
  "Checks for equality with the objects `domainGapClosure` field."
  domainGapClosure: BigFloat
  "Checks for equality with the objects `domainName` field."
  domainName: String
  "Checks for equality with the objects `domainOrder` field."
  domainOrder: Int
  "Checks for equality with the objects `domainShort` field."
  domainShort: String
  "Checks for equality with the objects `domainTag` field."
  domainTag: String
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `practiceDescription` field."
  practiceDescription: String
  "Checks for equality with the objects `practiceGrouping` field."
  practiceGrouping: String
  "Checks for equality with the objects `practiceName` field."
  practiceName: String
  "Checks for equality with the objects `practiceTag` field."
  practiceTag: String
  "Checks for equality with the objects `sCreate` field."
  sCreate: Datetime
  "Checks for equality with the objects `sCreateUser` field."
  sCreateUser: Int
  "Checks for equality with the objects `sUpdate` field."
  sUpdate: Datetime
  "Checks for equality with the objects `sUpdateUser` field."
  sUpdateUser: Int
}

"""

A condition to be used against `_VwAdmPracticeRubric` object types. All fields
are tested for equality and combined with a logical and.
"""
input _VwAdmPracticeRubricCondition {
  "Checks for equality with the objects `idAdmCapacity` field."
  idAdmCapacity: Int
  "Checks for equality with the objects `idAdmDomain` field."
  idAdmDomain: Int
  "Checks for equality with the objects `idAdmFramework` field."
  idAdmFramework: Int
  "Checks for equality with the objects `idAdmPractice` field."
  idAdmPractice: Int
  "Checks for equality with the objects `idAdmRubric` field."
  idAdmRubric: Int
}

"""

A condition to be used against `_VwCapacityScore` object types. All fields are
tested for equality and combined with a logical and.
"""
input _VwCapacityScoreCondition {
  "Checks for equality with the objects `capacityScore` field."
  capacityScore: BigFloat
  "Checks for equality with the objects `idUsrCapacity` field."
  idUsrCapacity: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
}

"""

A condition to be used against `_VwDomainScore` object types. All fields are
tested for equality and combined with a logical and.
"""
input _VwDomainScoreCondition {
  "Checks for equality with the objects `domainScore` field."
  domainScore: BigFloat
  "Checks for equality with the objects `idUsrDomain` field."
  idUsrDomain: Int
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
}

"""

A condition to be used against `_VwStrScore` object types. All fields are tested
for equality and combined with a logical and.
"""
input _VwStrScoreCondition {
  "Checks for equality with the objects `idUsrStr` field."
  idUsrStr: Int
  "Checks for equality with the objects `strScore` field."
  strScore: BigFloat
}


"A location in a connection that can be used for resuming pagination."
scalar Cursor

"A floating point number that requires more precision than IEEE 754 binary 64"
scalar BigFloat

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf)."
scalar JSON

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"The day, does not include a time."
scalar Date
